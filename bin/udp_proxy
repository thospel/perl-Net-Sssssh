#!/usr/bin/perl -w
use strict;
use warnings;

# modprobe fou
# ip link add name fou1 type ipip remote 127.0.0.1 local 127.0.0.1 ttl 225 encap fou encap-sport auto encap-dport 1236
# ip link set fou1 up
# ip addr add 10.253.4.1/24 dev fou1
# # If you add "dev fou1" to the add port it seems to stop working
# # If you remove the "local 127.0.0.1" it keeps working
# ip fou add port 1237 ipproto 4 local 127.0.0.1

# Redirect packets to port 1234 into the fou1 tunnel:
# iptables -t mangle -N FWMARK2
# # iptables -t mangle -A FWMARK2 -j LOG --log-prefix 'iptables-mark2: ' --log-level info
# iptables -t mangle -A FWMARK2 -j MARK --set-mark 17
# iptables -t mangle -A OUTPUT -p udp --dport 1234 -j FWMARK2
# ip rule add fwmark 17 lookup 101
# ip route add default via 10.253.4.1 table 101

# Avoid other stuff sneaking into the tunnel
# (not sure how, but when using deluge (torrent): external traffic not on the marked port gets into the tunnel)
# iptables -t mangle -A INPUT -d 10.253.4.1 -j DROP
# iptables -t mangle -A OUTPUT -s 10.253.4.1 -j DROP

# sysctl -w net.ipv4.conf.all.rp_filter=0
# sysctl -w net.ipv4.conf.fou1.rp_filter=0

# ip fou del port 1237 ipproto 4 local 127.0.0.1
# ip link del name fou1

our $VERSION = "1.000";

use FindBin qw($Bin $Script);
use Getopt::Long 2.24 qw(:config bundling require_order);
use Carp;
use Sys::Hostname;
use Errno qw(EINTR);
use Time::Local qw(timegm);
use Socket qw(inet_aton inet_ntoa unpack_sockaddr_in);

use Data::Dumper;
$Data::Dumper::Indent   = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Useqq	= 1;

($Bin, $Script) = __FILE__ =~ m{^(.*)/(.+)\z} or
    die "Could not parse ", __FILE__ if $Script eq "-" && __FILE__ ne "-";

$SIG{PIPE} = "IGNORE";

my $MULTICAST_BEGIN = inet_aton("224.0.0.0") // die "Assertion: Bad address";
# multicast range *excludes* this END address
my $MULTICAST_END   = inet_aton("240.0.0.0") // die "Assertion: Bad address";

my $IP_VERSION = 4;
my $PROTO_UDP = getprotobyname("udp") // die "Unknown protocol UDP";
my $PROTO_TCP = getprotobyname("tcp") // die "Unknown protocol TCP";
my $IHL = 5;
my $UDP_HEADER = 8;
my $DF = 2;
my $TTL = 64;

my $ssh = "/usr/bin/ssh";
my $verbose = undef;
my $debug   = 0;
my $default_local_bind  = "127.0.0.1";
my $default_remote_bind = "127.0.0.1";

# How long a server UDP socket lingers without traffic
# How long an errored TCP connection tries to push lingering output
my $SOCKS_TIMEOUT = 120;
# How much we can typically fit into our communication channel
my $LINE_BLOCK_SIZE = int(2**14);
my $BLOCK_SIZE = int(2**16);
my $UDP_SIZE = int(2**16);
my $LISTEN_BACKLOG = 128;

my %settings = (
    EPOCH	=> undef,
    TIMEOUT	=> 120,
    KEEPALIVE	=> 300,
    UDP_MAX	=> 10,
);
my @setting_ids = sort keys %settings;
my %setting_ids;
$setting_ids{$setting_ids[$_]} = $_ for 0..$#setting_ids;

my $STUFFED = "GoNow";

# Line protocol commands
my $START	= "1";
my $SET		= "S";	# sets a server variable
my $UDP_REMOTE	= "r";
my $DATA	= "D";
my $RESPONSE	= "d";
my $KEEP	= "K";	# Keepalive packet

my $ERROR_ECONNREFUSED	= "Connection refused";
my $ERROR_ENETUNREACH	= "Network is unreachable";
my $ERROR_ETIMEDOUT	= "Timed out";
my $ERROR_ERESOLV	= "Could not resolve host";

my $msghdr_error;
BEGIN {
    # Can't use "require" later on since Socket::MsgHdr has INIT blocks
    eval sprintf(qq(#line %d "%s"\nuse Socket::MsgHdr qw(pack_cmsghdr unpack_cmsghdr sendmsg recvmsg); 1), __LINE__, __FILE__)
        or $msghdr_error = $@ || "Unknown error loading Socket::MsgHdr\n";
    $msghdr_error =~ s/^BEGIN failed.*\n\z// if $msghdr_error;
}

my $FREE_BSD = $^O eq "freebsd";
# IPPROTO_IP exists in Socket, but not in really old ones
my $IPPROTO_IP = 0;
my ($IP_RECVTTL, $IP_TTL, $IP_PKTINFO);
if (!$msghdr_error) {
    if (0 && $FREE_BSD) {
        # FreeBSD uses IP_RECVDSTADDR
        $IP_PKTINFO	=  7;
        $IP_RECVTTL	= 65;
        $IP_TTL		=  4;
    } elsif ($^O eq "linux") {
        $IP_PKTINFO	=  8;
        $IP_RECVTTL	= 12;
        $IP_TTL		=  2;
    } else {
        $msghdr_error = "Socket::MsgHdr constants for OS $^O not implemented (yet)\n";
    }
}
my $msghdr = $msghdr_error ? undef : Socket::MsgHdr->new();

my $role = "client";
my $role_peer;

# Determine some system settings
my $hostname = hostname();
my $me;
if ($^O eq "MSWin32") {
    require Win32;
    $me = Win32::LoginName();
} else {
    if (my $user = $ENV{LOGNAME}) {
        if (defined(my $uid = getpwnam($user))) {
            $me = $user if $> == $uid;
        }
    }
    $me ||= getpwuid $>;
}
die "Can't determine who I am" if !$me;

die "Bad file '", __FILE__, "'" if __FILE__ =~ /["\n\0]/;
# Client stuffer
my $POST_STUFFER = sprintf(qq(#line %d "%s"\n%s),
                           __LINE__, __FILE__, '
BEGIN {
    eval {
        open($SAVED_STDIN, "<&", \*STDIN);
        open(STDIN, "<", "/dev/null") || die "NULL: $!";
        1;
    } or do {
        print STDERR $@ || "Unknown error\n";
        exit 255;
    };
}
');
my $PRE_STUFFER = sprintf(qq(#line %d "%s"\n%s),
                           __LINE__, __FILE__, '
BEGIN { $^W = 1 }

my $SAVED_STDIN;
open(STDIN, "<&", $SAVED_STDIN) || die "Could not dup STDIN: $^E";
close($SAVED_STDIN) || die "Could not close SAVED_STDIN: $^E";
$| = 1;
print "' . $STUFFED . '";
');

package Events;
# A small event core
use Carp;
use Errno qw(EINTR);

my $read_mask  = "";
my $write_mask = "";
my $error_mask = "";
my (%read_refs, %write_refs, %error_refs);

sub add_read(*$ ) {
    defined(my $fd = fileno(shift)) || croak "Not a filehandle";
    ::caller_info("add_read $fd") if $debug;
    croak "Descriptor $fd already selected for read" if $read_refs{$fd};
    $read_refs{$fd} = shift;
    vec($read_mask, $fd, 1) = 1;
}

sub add_write(*$ ) {
    defined(my $fd = fileno(shift)) || croak "Not a filehandle";
    ::caller_info("add_write $fd") if $debug;
    croak "Descriptor $fd already selected for write" if $write_refs{$fd};
    $write_refs{$fd} = shift;
    vec($write_mask, $fd, 1) = 1;
}

sub add_error(*$ ) {
    defined(my $fd = fileno(shift)) || croak "Not a filehandle";
    ::caller_info("add_error $fd") if $debug;
    croak "Descriptor $fd already selected for error" if $error_refs{$fd};
    $error_refs{$fd} = shift;
    vec($error_mask, $fd, 1) = 1;
}

sub delete_read(*) {
    defined(my $fd = fileno(shift)) || croak "Not a filehandle";
    ::caller_info("delete_read $fd") if $debug;
    croak "Descriptor $fd wasn't selected for read" unless $read_refs{$fd};
    # This strange assign before delete is to poison the reference the for in
    # sub mainloop may still have
    $read_refs{$fd} = undef;
    delete $read_refs{$fd};
    if (%read_refs) {
        vec($read_mask, $fd, 1) = 0;
        $read_mask =~ s/\x00+\z//;
    } else {
        $read_mask = "";
    }
}

sub delete_write(*) {
    defined(my $fd = fileno(shift)) || croak "Not a filehandle";
    ::caller_info("delete_write $fd") if $debug;
    croak "Descriptor $fd wasn't selected for write" unless $write_refs{$fd};
    # This strange assign before delete is to poison the reference the for in
    # sub mainloop may still have
    $write_refs{$fd} = undef;
    delete $write_refs{$fd};
    if (%write_refs) {
        vec($write_mask, $fd, 1) = 0;
        $write_mask =~ s/\x00+\z//;
    } else {
        $write_mask = "";
    }
}

sub delete_error(*) {
    defined(my $fd = fileno(shift)) || croak "Not a filehandle";
    ::caller_info("delete_error $fd") if $debug;
    croak "Descriptor $fd wasn't selected for error" unless $error_refs{$fd};
    # This strange assign before delete is to poison the reference the for in
    # sub mainloop may still have
    $error_refs{$fd} = undef;
    delete $error_refs{$fd};
    if (%error_refs) {
        vec($error_mask, $fd, 1) = 0;
        $error_mask =~ s/\x00+\z//;
    } else {
        $error_mask = "";
    }
}

{
    no warnings "once";
    *IO::Handle::add_read     = \&add_read;
    *IO::Handle::add_write    = \&add_write;
    *IO::Handle::add_error    = \&add_error;
    *IO::Handle::delete_read  = \&delete_read;
    *IO::Handle::delete_write = \&delete_write;
    *IO::Handle::delete_error = \&delete_error;
}

sub mainloop {
    ::info($msghdr_error) if $msghdr_error && ($verbose || $debug);
    ::info("Entering mainloop") if $verbose || $debug;
    while (1) {
        my $timeout = Timer::timers_collect();
        $timeout // (%read_refs || %write_refs || %error_refs || last);
        if ((select(my $r = $read_mask, my $w = $write_mask, my $e = $error_mask, $timeout) || (Timer::timers_run(), next)) > 0) {
            $$_ && $$_->() for
                \@read_refs{ grep vec($r, $_, 1), keys %read_refs},
                \@write_refs{grep vec($w, $_, 1), keys %write_refs},
                \@error_refs{grep vec($e, $_, 1), keys %error_refs};
            Timer::timers_run();
        } elsif ($! != EINTR) {
            die "Select failed: $^E";
        }
    }
    ::info("Exiting mainloop") if $verbose || $debug;
}

package Timer;
# A small timer core
use Scalar::Util qw(weaken);
use Carp;
use Time::HiRes qw(clock_gettime CLOCK_REALTIME CLOCK_MONOTONIC);

# Timer indices
sub TIME	() { 0 };
sub INDEX	() { 1 };
sub CODE	() { 2 };	# Must come after INDEX

# @immediate must be persistent so no timers get lost if a callback dies
my @immediate;
my @timers = (undef);

my $CLOCK_TYPE;
my $CLOCK_TYPE_NAME =
    eval { $CLOCK_TYPE = CLOCK_MONOTONIC; "MONOTONIC" } ||
    eval { $CLOCK_TYPE = CLOCK_REALTIME;  "REAL" } ||
    die "Time::HiRes doesn't even have CLOCK_REALTIME";

sub realtime {
    return clock_gettime(CLOCK_REALTIME);
}

sub time : method {
    return clock_gettime($CLOCK_TYPE);
}

my $BASE_TIME = Timer->realtime();

# Timers are kept in a simple binary heap @timers
sub new {
    my ($class, $time, $fun) = @_;

    $time += clock_gettime($CLOCK_TYPE);
    my $i = @timers;
    while ($i > 1 && $time < $timers[$i >> 1][TIME]) {
        weaken($timers[$i] = $timers[$i >> 1]);
        $i = ($timers[$i][INDEX] = $i) >> 1;
    }
    my $timer = bless [$time, $i, $fun], $class;
    weaken($timers[$i] = $timer);
    return $timer;
}

sub delete : method {
    my ($timer) = @_;

    my $i = $timer->[INDEX];
    if (!$i) {
        croak "Not a timer reference" unless defined($i) && $i == 0;
        # Could be a timer sitting on the expired queue @immediate
        $#$timer = INDEX if @$timer > INDEX;
        return;
    }
    $timer->[INDEX] = 0;
    # Last element or beyond...
    if ($i >= $#timers) {
        croak "Not a timer reference" if $i > $#timers;
        pop(@timers);
        return;
    }
    my $time = $timers[-1][TIME];
    if ($i > 1 && $time < $timers[$i >> 1][TIME]) {
        # percolate to root
        do {
            weaken($timers[$i] = $timers[$i >> 1]);
            $i = ($timers[$i][INDEX] = $i) >> 1;
        } while ($i > 1 && $time < $timers[$i >> 1][TIME]);
    } else {
        # percolate to leafs
        my $n = @timers-2;
        my $l = $i * 2;
        while ($l < $n) {
            if ($timers[$l][TIME] < $time) {
                if ($timers[$l+1][TIME] < $timers[$l][TIME]) {
                    weaken($timers[$i] = $timers[$l+1]);
                    $timers[$i][INDEX] = $i;
                    $i = $l+1;
                } else {
                    weaken($timers[$i] = $timers[$l]);
                    $timers[$i][INDEX] = $i;
                    $i = $l;
                }
            } elsif ($timers[$l+1][TIME] < $time) {
                weaken($timers[$i] = $timers[$l+1]);
                $timers[$i][INDEX] = $i;
                $i = $l+1;
            } else {
                last;
            }
            $l = $i * 2;
        }
        if ($l == $n && $timers[$l][TIME] < $time) {
            weaken($timers[$i] = $timers[$l]);
            $timers[$i][INDEX] = $i;
            $i = $l;
        }
    }
    weaken($timers[$i] = pop @timers);
    $timers[$i][INDEX] = $i;
}

sub DESTROY {
    shift->delete;
}

sub timers_collect {
    return @immediate ? 0 : undef if @timers <= 1;
    my $now = clock_gettime($CLOCK_TYPE);
    return @immediate ? 0 : $timers[1][TIME] - $now if $timers[1][TIME] > $now;

    # We will expire at least 1 timer
    # @timers > 2 makes sure that if we pop @timers we don't remove $timers[1]
    while (@timers > 2) {
        $timers[1][INDEX] = 0;
        weaken($immediate[@immediate] = $timers[1]);

        my $time = $timers[-1][TIME];
        my $n = @timers-2;
        my $i = 1;
        my $l = 2;
        while ($l < $n) {
            if ($timers[$l][TIME] < $time) {
                if ($timers[$l+1][TIME] < $timers[$l][TIME]) {
                    weaken($timers[$i] = $timers[$l+1]);
                    $timers[$i][INDEX] = $i;
                    $i = $l+1;
                } else {
                    weaken($timers[$i] = $timers[$l]);
                    $timers[$i][INDEX] = $i;
                    $i = $l;
                }
            } elsif ($timers[$l+1][0] < $time) {
                weaken($timers[$i] = $timers[$l+1]);
                $timers[$i][INDEX] = $i;
                $i = $l+1;
            } else {
                last;
            }
            $l = $i * 2;
        }
        if ($l == $n && $timers[$l][TIME] < $time) {
            weaken($timers[$i] = $timers[$l]);
            $timers[$i][INDEX] = $i;
            $i = $l;
        }
        weaken($timers[$i] = pop @timers);
        $timers[$i][INDEX] = $i;
        return 0 if $timers[1][TIME] > $now;
    }
    if (@timers == 2) {
        $timers[1][INDEX] = 0;
        weaken($immediate[@immediate] = pop @timers);
    }
    return 0;
}

sub timers_run {
    @immediate || return;
    my $fun;

    # Using while instead of for in case a callback dies
    ($fun = shift @immediate) && $fun->[CODE] && $fun->[CODE]->() while @immediate;
}

package Ids;
# Allocate and free unique numbers

sub new {
    my $ids = bless {}, shift;
    $ids->id_init;
    return $ids;
}

sub id_init {
    my ($ids) = @_;

    $ids->{free_ids} = [];
    $ids->{free_id}  = 0;
}

sub id_alloc {
    my ($ids) = @_;

    return shift @{$ids->{free_ids}} || ++$ids->{free_id};
}

sub id_free {
    my ($ids, $id) = @_;

    push @{$ids->{free_ids}}, $id;
    # Decrease free_ids some if we are lucky
    while (@{$ids->{free_ids}}) {
        if ($ids->{free_ids}[-1] == $ids->{free_id}) {
            --$ids->{free_id};
            pop @{$ids->{free_ids}};
        } elsif ($ids->{free_ids}[0] == $ids->{free_id}) {
            --$ids->{free_id};
            shift @{$ids->{free_ids}};
        } else {
            last;
        }
    }
}

package Sender::UDP;
# Send out packets at the remote side (and wait for replies)
use Scalar::Util qw(weaken);
use Socket qw(pack_sockaddr_in unpack_sockaddr_in inet_ntoa
              MSG_TRUNC MSG_CTRUNC);
use Errno qw(EINTR EAGAIN EWOULDBLOCK EMSGSIZE);

sub new {
    my ($class, $line, $id) = @_;

    die "Already have Sender::UDP socket '$id'" if $line->{sockets_udp}{$id};

    my ($host, $port, $socket) = $line->socket_udp("0.0.0.0", 0);
    !$msghdr || setsockopt($socket, $IPPROTO_IP, $IP_RECVTTL, 1) ||
        die "setsockopt(IPPROTO_IP, IP_RECVTTL): $^E";

    my $sender = bless {
        id		=> $id,
        out		=> [],
        socket		=> $socket,
        local_host	=> $host,
        local_port	=> $port,
        timeout		=> undef,
    }, $class;
    weaken($sender->{line} = $line);

    ::info("Creating new Sender::UDP socket[$id] '$host:$port'") if $debug;
    $socket->add_read(sub { $sender->reader });

    $line->{sockets_udp}{$id} = $sender;
    return $sender;
}

sub timeout {
    my ($sender) = @_;

    die "Timeout. Could not UDP send[$sender->{id}";
}

sub write : method {
    my $sender = shift;
    if (1 == push @{$sender->{out}}, $msghdr ?
        bless {
            name => pack_sockaddr_in(shift, shift),
            buf  => shift,
            control => ::pack_cmsghdr(
                $IPPROTO_IP,
                $IP_TTL,
                pack("I", shift || die "Assertion: TTL 0")),
            flags => 0,
        }, "Socket::MsgHdr" :
        [pack_sockaddr_in(shift, shift), shift]) {
        $sender->{socket}->add_write(sub { $sender->writer});
        $sender->{timeout} = Timer->new($settings{TIMEOUT}, sub { $sender->timeout } );
    }
}

sub writer {
    my ($sender) = @_;

    my $data = $sender->{out}[0];
    if ($msghdr) {
        my $rc = ::sendmsg($sender->{socket}, $data);
        if (!defined $rc) {
            return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK;
            if ($! == EMSGSIZE) {
                ::info("Cannot send oversized UDP packet. Dropped") if $debug;
                goto DROP;
            }
            die "Could not write to sender UDP socket: $^E";
        }
        if ($debug) {
            my ($port, $addr) = unpack_sockaddr_in($data->{name});
            my $host = inet_ntoa($addr);
            ::info("Wrote %d bytes to %s:%d (%d left): %s",
                   $rc, $host, $port, length($data->{buf}) - $rc, ::display(substr($data->{buf}, 0, $rc)));
        }
        $rc == length($data->{buf}) || die "Assertion: Incomplete UDP write ($rc of " . length($data->{buf}) . ")";
    } else {
        my $rc = send($sender->{socket}, $data->[1], 0, $data->[0]);
        if (!defined $rc) {
            return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK;
            if ($! == EMSGSIZE) {
                ::info("Cannot send oversized UDP packet. Dropped") if $debug;
                goto DROP;
            }
            die "Could not write to sender UDP socket: $^E";
        }
        if ($debug) {
            my ($port, $addr) = unpack_sockaddr_in($data->[0]);
            my $host = inet_ntoa($addr);
            ::info("Wrote %d bytes to %s:%d (%d left): %s",
                   $rc, $host, $port, length($data->[1]) - $rc, ::display(substr($data->[1], 0, $rc)));
        }
        $rc == length($data->[1]) || die "Assertion: Incomplete UDP write ($rc of " . length($data->[1]) . ")";
    }

  DROP:
    shift @{$sender->{out}};
    if (@{$sender->{out}}) {
        $sender->{timeout} = Timer->new($settings{TIMEOUT}, sub { $sender->timeout } );
    } else {
        $sender->{socket}->delete_write;
        $sender->{timeout} = undef;
    }
}

sub reader {
    my ($sender) = @_;

    my ($sockaddr, $buffer, $ttl);
    if ($msghdr) {
        $msghdr->{name} = "\0" x 256;
        $msghdr->{buf}  = "\0" x $UDP_SIZE;
        $msghdr->{control} = "\0" x 256;
        $msghdr->{flags} = 0;
        if (defined ::recvmsg($sender->{socket}, $msghdr)) {
            # I suspect Socket::MsgHdr has a bug so that flags is never set
            die "Yikes! Buffer was truncated\n" if
                $msghdr->flags & MSG_TRUNC;
            die "Yikes! Ancillary data was truncated\n" if
                $msghdr->flags & MSG_CTRUNC;
            $buffer = $msghdr->{buf};
            $sockaddr = $msghdr->{name};
            my ($level, $type, $data) = ::unpack_cmsghdr($msghdr->{control}) or
                die "No ancillary data from socket";
            $level == $IPPROTO_IP ||
                die "Unexpected level in ancillary data from socket";
            $type == $IP_TTL ||
                die "Unexpected type in ancillary data from socket";
            $ttl = unpack("I", $data);
        }
    } else {
        $sockaddr = recv($sender->{socket}, $buffer, $UDP_SIZE, 0);
        $ttl = $TTL;
    }
    if (!defined $sockaddr) {
        return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK;
        die "Could not read from sending UDP socket: $^E";
    }
    # No special handling for length 0.
    # It's perfectly fine to send and receve empty UDP packets
    my ($port, $addr) = unpack_sockaddr_in($sockaddr);
    if ($debug) {
        my $host = inet_ntoa($addr);
        ::info("Received %d bytes %sfrom %s:%d on sender UDP socket[%d]: %s",
               length($buffer), $msghdr ? "(TTL $ttl) " : "",
               $host, $port, $sender->{id}, ::display($buffer));
    }
    $sender->{line}->write($RESPONSE, pack("wa4nC", $sender->{id}, $addr, $port, $ttl-1), $buffer) if $ttl > 1;
}

package Listener::UDP;
# Wait for packets at the local (client) side
use Errno qw(EINTR EAGAIN EWOULDBLOCK);
use Socket qw(inet_ntoa pack_sockaddr_in
              MSG_TRUNC MSG_CTRUNC);
use Scalar::Util qw(weaken);

sub new {
    my ($class, $line, $host, $port, $fou) = @_;

    my ($h, $p, $socket) = $line->socket_udp($host, $port);

    my $listener = bless {
        fou_id		=> $fou->id,
        socket		=> $socket,
        local_host	=> $h,
        local_port	=> $p,
    }, $class;
    weaken($listener->{line} = $line);

    ::info("Listening on UDP socket '$h:$p'") if $debug;
    $socket->add_read(sub { $listener->reader });

    my $id = $line->id_alloc;
    $listener->{id} = $id;
    $line->{listeners}{$id} = $listener;
    return $listener;
}

sub id {
    return shift->{id};
}

sub reader {
    my ($listener) = @_;

    my $rc = $listener->{socket}->sysread(my $buffer, $UDP_SIZE);
    if (!defined $rc) {
        return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK;
        die "Could not read from listening $role UDP socket: $^E";
    }
    # No special handling for length 0.
    # It's perfectly fine to send and receve empty UDP packets
    my $debug_str = $debug && sprintf("Received %d bytes on $role UDP socket: %s", $rc, ::display($buffer));
    if (length $buffer < 20) {
        ::info($debug_str) if $debug_str;
        return;
    }
    my ($ihl, $ecn, $length, $id, $fragment, $ttl, $proto, $chksum, $nsrc, $ndst) = unpack("CCnnnCCna4a4", $buffer);
    # print STDERR "TEMP: IHL=$ihl, ECN=$ecn, LEN=$length, ID=$id, FRAGMENT=$fragment, TTL=$ttl, PROTO=$proto, CHK=$chksum, SRC=$nsrc, DST=$ndst\n";

    # Don't handle spammy multicast stuff
    return if $MULTICAST_BEGIN le $ndst && $ndst lt $MULTICAST_END;
    ::info($debug_str) if $debug_str;

    my $version = $ihl >> 4;
    $ihl &= 0xf;
    my $flags = $fragment >> 13;
    $fragment &= 0x1fff;
    # only TCP4
    $version == $IP_VERSION || return;
    # Only UDP
    $proto == $PROTO_UDP || return;
    # Sanity check on buffer
    length($buffer) == $length || return;
    # We don't handle IP options (yet)
    $ihl == $IHL || return;
    # Too many hops
    $ttl > 1 || return;
    # Don't handle fragments (fragment offset)
    return if $fragment;
    # Don't handle fragments (MF flag set)
    return if $flags & 0x1;

    my $pseudo10 = pack("a4a4xC", $nsrc, $ndst, $proto);

    $ihl *= 4;
    my $header = substr($buffer, 0, $ihl, "");
    $length -= $ihl;

    # No buffer padding needed since length($header) is even
    my $sum = unpack("%32n*", $header);
    while ($sum > 0xffff) {
        my $carry = $sum >> 16;
        $sum &= 0xffff;
        $sum += $carry;
    }
    $sum == 0xffff || return;

    my $src = inet_ntoa($nsrc);
    my $dst = inet_ntoa($ndst);

    # print "Sender $peer:$peer_port, Receiver $local [$msg_dst]\n";

    my $dscp = $ecn >> 3;
    $ecn &= 0x7;
    # print "HEADER: DSCP=$dscp, ECN=$ecn, ID=$id, FLAGS=$flags, FRAGMENT=$fragment, TTL=$ttl, CHKSUM=$chksum, SRC=$src, DST=$dst\n";

    # Must have space for UDP header
    return if $length < $UDP_HEADER;

    # Pad buffer 0 so a last single byte still gets processed as "n"
    $sum = unpack("%32n*", $buffer . "\x0") + unpack("%32n*", $pseudo10) + $length;
    my ($sprt, $dprt, $udp_len, $udp_chksum) = unpack("nnnn", substr($buffer, 0, $UDP_HEADER, ""));
    $udp_len == $length || die "Inconsistent UDP length (inner UDP payload length: $udp_len, Inner IP packet length - inner UDP header length $ihl = $length)";
    $length -= $UDP_HEADER;

    if ($udp_chksum) {
        while ($sum > 0xffff) {
            my $carry = $sum >> 16;
            $sum &= 0xffff;
            $sum += $carry;
        }
        $sum == 0xffff || return;
    }

    ::info("FOU decoded %d bytes (TTL %d) on $role UDP socket(%s:%d -> %s:%d): %s",
           length($buffer), $ttl, $src, $sprt, $dst, $dprt,
           ::display($buffer)) if $debug;

    my $line = $listener->{line};
    # On the remote side we will be able to distinguish packets coming back from
    # ($dst, $dport) so we can share a single Sender::UDP for a given ($src,$port)
    my $map_src = $line->{map_udp}{"$dst:$dprt"} ||= [
        0,		# Next seq counter
        {},		# Map "src:port" to map
        [undef],	# Map id to map (the undef makes id start at 1)
        # $ndst,	# Packed destination address
        # $dprt,	# Destination Port
    ];
    my $fou_id = $listener->{fou_id};
    my $key = "$src:$sprt:$fou_id";
    my $map = $map_src->[1]{$key} ||= {
        key	=> $key,
        port	=> $sprt,
        host	=> $src,
        addr	=> $nsrc,
        fou_id	=> $fou_id,
    };
    $map->{seq} = $map_src->[0]++;
    # We should be able to handle many billions of packets before this overflows
    die "Too many packets to $dst:$dprt" if $map->{seq} == $map_src->[0];
    $id = $map->{id};
    if (!defined $id) {
        # A source we haven't saeen befre or we have forgotten
        if (values %{$map_src->[1]} > $settings{UDP_MAX}) {
            my @old = sort {$a->{seq} <=> $b->{seq}} values %{$map_src->[1]};
            # Ignore the map we just added (it will have the highest packet number)
            pop @old;
            for my $old (@old) {
                # Try to allocate the socket. If we can that means the
                # ($src,$port) combination is not in local use anymore and we
                # can completely drop it
                # Notice if we receive FOU packets from a remote host we also
                # won't be able to bind(), so this works out OK. There is a
                # problem if we share IP addresses with the sender of the FOU
                # packets though. So we probably need an option to turn this
                # off and have another strategy to free up entries
                # (e.g. a timeout)
                # print STDERR "Probe $old->{host}, $old->{port}\n";
                if ($line->socket_udp($old->{host}, $old->{port}, 1)) {
                    ::info("Releasing map '$key' (socket not in use any more)") if $debug;
                    $id = $old->{id};
                    last;
                }
            }
            $id // die "Assertion: no Free id's";
            # $id //= $old[0]{id} // die "Assertion: no Free id's";
            my $remove = $map_src->[2][$id];
            delete $map_src->[1]{$remove->{key}} == $remove ||
                die "Assertion: Removing unexpected entry";
        } else {
            $id = @{$map_src->[2]};
        }
        $map->{id} = $id;
        $map_src->[2][$id] = $map;
    }
    # print STDERR ::Dumper($id, $line->{map_udp});
    $line->write($DATA, pack("wa4nC", $id, $ndst, $dprt, $ttl-1), $buffer);
}

package Fou::UDP;
# Send out proxied packets at the local (client) side usinga FOU tunnel
use Errno qw(EINTR EAGAIN EWOULDBLOCK EMSGSIZE);
use Scalar::Util qw(weaken);

my @FOU;
{
    my %fou;
    my $fou_ids = Ids->new;
    sub new {
        my ($class, $host, $port) = @_;

        my ($h, $p, $socket) = LineProtocol->socket_udp_connected($host, $port);
        return $fou{"$h:$p"} if exists $fou{"$h:$p"};

        my $id = $fou_ids->id_alloc;
        my $fou = bless {
            id		=> $id,
            out		=> [],
            socket	=> $socket,
            host	=> $h,
            port	=> $p,
            timeout	=> undef,
        }, $class;
        $fou{"$h:$p"} = $FOU[$id] = $fou;

        return $fou;
    }
}

sub timeout {
    my ($fou) = @_;

    die "Timeout. Could not FOU send[$fou->{id}";
}

sub id {
    return shift->{id};
}

sub write : method {
    my $fou = shift;
    if (1 == push @{$fou->{out}}, shift) {
        $fou->{socket}->add_write(sub { $fou->writer});
        $fou->{timeout} = Timer->new($settings{TIMEOUT}, sub { $fou->timeout } );
    }
}

sub writer {
    my ($fou) = @_;

    my $rc = $msghdr ?
        ::sendmsg($fou->{socket}, $fou->{out}[0]) :
        syswrite($fou->{socket}, $fou->{out}[0]);
    if (!defined $rc) {
        return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK;
        if ($! == EMSGSIZE) {
            ::info("Cannot send oversized FOU packet. Dropped") if $debug;
            goto DROP;
        }
        die "Could not write to Fou UDP socket: $^E";
    }
    if ($msghdr) {
        ::info("Wrote %d bytes (TTL %d) to Fou UDP socket %s:%d (%d left): %s",
               $rc,
               unpack("I", (::unpack_cmsghdr($fou->{out}[0]->{control}))[2]),
               $fou->{host}, $fou->{port}, length($fou->{out}[0]{buf}) - $rc,
               ::display(substr($fou->{out}[0]{buf}, 0, $rc))) if $debug;
        $rc == length($fou->{out}[0]{buf}) ||
            die "Assertion: Incomplete UDP write ($rc of " . length($fou->{out}[0]{buf}) . ")";
    } else {
        ::info("Wrote %d bytes to Fou UDP socket %s:%d (%d left): %s",
               $rc, $fou->{host}, $fou->{port}, length($fou->{out}[0]) - $rc,
               ::display(substr($fou->{out}[0], 0, $rc))) if $debug;
        $rc == length($fou->{out}[0]) ||
            die "Assertion: Incomplete UDP write ($rc of " . length($fou->{out}[0]) . ")";
    }
  DROP:
    shift @{$fou->{out}};
    if (@{$fou->{out}}) {
        $fou->{timeout} = Timer->new($settings{TIMEOUT}, sub { $fou->timeout } );
    } else {
        $fou->{socket}->delete_write;
        $fou->{timeout} = undef;
    }
}

package LineProtocol0;
use base qw(Ids);

my $LINE = __PACKAGE__->new;
sub new {
    my ($class) = @_;

    my $line = bless {
        started		=> undef,	# Normal operations started
        utime_offset	=> 0,	# Estimated round trip time in microsecond
        keepalive	=> undef,
        timeout		=> undef,
        listeners	=> {},
        map_udp		=> {},
        sockets_udp	=> {},
    }, $class;
    $line->id_init;

    return $line;
}

package LineProtocol;
# Handle traffic between client and server
use Errno qw(EINTR EAGAIN EWOULDBLOCK EADDRINUSE);
use Carp;
use FindBin qw($Script);
use Socket qw(PF_INET SOCK_DGRAM SOCK_STREAM SOL_SOCKET SO_REUSEADDR
              inet_ntoa inet_aton pack_sockaddr_in unpack_sockaddr_in);

use base qw(LineProtocol0);

my %process = (
    $SET		=> \&process_SET,
    $START		=> \&process_START,
    $KEEP		=> \&process_KEEP,
    $UDP_REMOTE		=> \&process_UDP_REMOTE,
    $DATA		=> \&process_DATA,
    $RESPONSE		=> \&process_RESPONSE,
);

sub new {
    my ($class, $socket_in, $socket_out) = @_;

    binmode($socket_in);
    binmode($socket_out);

    $socket_in ->blocking(0);
    $socket_out->blocking(0);

    my $line = $class->SUPER::new();

    $line->{socket_in}  = $socket_in;
    $line->{socket_out} = $socket_out;
    $line->{in}  = "";
    $line->{out} = "";

    $socket_in->add_read(sub { $line->reader });

    return $line;
}

sub writer {
    my ($line) = @_;

    while (1) {
        my $rc = $line->{socket_out}->syswrite($line->{out}, $BLOCK_SIZE);
        if (!defined $rc) {
            if ($! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK) {
                $line->{timeout} //= Timer->new($settings{TIMEOUT}, sub { $line->timeout } );
                return;
            }
            $line->{socket_out}->delete_write;
            die "Could not write to $role_peer: $^E"
        }
        die "Zero write. Is this even possible ?" if $rc == 0;
        ::info("Wrote %d bytes to %s (%d left): %s",
             $rc, $role_peer, length($line->{out})-$rc, ::display(substr($line->{out}, 0, $rc))) if $debug;

        substr($line->{out}, 0, $rc, "");
        $line->{timeout} = undef;
        if ($line->{out} eq "") {
            $line->{socket_out}->delete_write;
            $line->{keepalive} = Timer->new($settings{KEEPALIVE}, sub { $line->keepalive } );
            return;
        }
    }
}

sub keepalive {
    my ($line) = @_;

    $line->write($KEEP, sprintf("%.0f %.0f",
                                (Timer->realtime() - $BASE_TIME)*1e6,
                                $line->{utime_offset}));
}

sub timeout {
    die "Timeout. Could not write to $role_peer";
}

sub line_message {
    my $out   = \shift;
    my $command = shift;

    # One initial BER byte + proto = 2 bytes
    my $length = 2;
    $length += length for @_;
    ++$length if $length >= 128;
    ++$length if $length >= 128*128;
    # Don't accept more than 3 BER bytes (~ 2**21 byte message)
    croak "Message too long" if $length >= 128*128*128;

    $$out .= pack("wa", $length, $command);
    $$out .= $_ for @_;
    # ::info("Constructed %s: %s", $command, unpack("H*", substr($$out, -$length)));
    return $length;
}

sub write : method {
    my $line = shift;

    my $length = line_message($line->{out}, @_);
    if ($length == length $line->{out}) {
        $line->{socket_out}->add_write(sub { $line->writer });
        $line->{keepalive} = undef;
        $line->{timeout} = Timer->new($settings{TIMEOUT}, sub { $line->timeout } );
    }
}

sub reader {
    my ($line) = @_;

    my $rc = $line->{socket_in}->sysread($line->{in}, $BLOCK_SIZE, length($line->{in}));
    if (!defined $rc) {
        return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK;
        die "Could not read from $role_peer: $^E"
    }
    if ($rc == 0) {
        ::info("exit") if $verbose;
        exit 0;
    }
    ::info("Read %d bytes from $role_peer: %s", $rc, ::display(substr($line->{in}, -$rc))) if $debug;
    while ($line->{in} =~ /^([\x80-\xff]{0,2}[\x00-\x7f].)/s) {
        my ($length, $command) = unpack("wa", $line->{in});
        last if length($line->{in}) < $length;
        my $message = substr($line->{in}, 0, $length, "");
        substr($message, 0, length $1, "");
        ::info("Processing %s: '%s' (%d bytes)",
               $command, ::display($message), length $message) if $debug;
        my $fun = $process{$command} ||
            die "No handler for proto '$command'";
        $fun->($line, $message, $command);
    }
}

sub process_SET {
    my $line  = shift;

    my $i = unpack("C", substr($_[0], 0, 1, ""));
    my $name = $setting_ids[$i] || die "Unknown variable $i";
    $settings{$name} = $_[0];
    ::info("Set %s=%s", $name, $_[0]) if $debug;
}

sub process_START {
    my $line  = shift;

    defined $settings{EPOCH} || die "Lost early epoch message";

    my $ready = "$Script $role $me\@$hostname ready (clock=$CLOCK_TYPE_NAME, pid=$$)";
    $line->{started} = 1;

    if ($role eq "server") {
        $line->write($START, $ready);
    }
    ::info($ready);
    print STDERR "\n";
}

sub process_KEEP {
    my $line  = shift;

    # Transit time is of course meaningless if the clocks aren't
    # synchronized very well. offset tries to compensate for that

    my ($utime, $uoffset) = split " ", $_[0];

    # uoffset has     peertime - mytime + transit_time (me -> peer)
    # This calculates mytme - peertime  + transit time (peer -> me)
    $line->{utime_offset} = (Timer->realtime() - $settings{EPOCH})*1e6 -$utime || 1;
    if ($uoffset) {
        ::info("Keepalive transit=%.3f ms, roundtrip=%.3f ms, offset=%.0f ms",
               $line->{utime_offset}/1e3,
               ($line->{utime_offset}+$uoffset)/1e3,
               ($line->{utime_offset}-$uoffset)/2e3) if $debug;
    } else {
        ::info("Keepalive transit=%.3f ms",
               $line->{utime_offset}/1e3) if $debug;
    }
}

sub process_UDP_REMOTE {
    my ($line, $udp) = @_;

    my ($from_port, $separator, $to_port) =
        $udp =~ m{^([^/]+)([/=])([^/]+)\z} or
        die "Invalid udp_remote '$udp'";
    my $from_host = $from_port =~ s{(.*):}{}s ? $1 :
        $default_local_bind;
    my $to_host   = $to_port   =~ s{(.*):}{}s ? $1 :
        $default_local_bind;

    my $l = $separator eq "/" ? $line : $LINE;
    my $fou = Fou::UDP->new($to_host, $to_port);
    my $listener = Listener::UDP->new($l, $from_host, $from_port, $fou);
}

sub process_DATA {
    my $line = shift;
    my ($id, $dst, $port, $ttl, $data) = unpack("wa4nCa*", shift);
    $id || die "Assertion: Sender socket id $id == 0";
    $id <= $settings{UDP_MAX} ||
        die "Assertion: Sender socket id $id > $settings{UDP_MAX}";
    ::info("Need to send %d bytes of UDP data (TTL %d) on socket %d to %s:%d: %s",
           length($data), $ttl, $id, inet_ntoa($dst), $port, ::display($data)) if $debug;
    my $sender = $line->{sockets_udp}{$id} || Sender::UDP->new($line, $id);
    $sender->write($port, $dst, $data, $ttl);
}

sub process_RESPONSE {
    my $line = shift;

    my ($id, $nsrc, $sprt, $ttl, $data) = unpack("wa4nCa*", shift);
    $id || die "Assertion: Sender socket id $id == 0";
    $id <= $settings{UDP_MAX} ||
        die "Assertion: Sender socket id $id > $settings{UDP_MAX}";
    my $src = inet_ntoa($nsrc);
    ::info("\u$role_peer received %d bytes of UDP data on socket %d from %s:%d: %s",
           length($data), $id, $src, $sprt, ::display($data)) if $debug;
    my $map_src = $line->{map_udp}{"$src:$sprt"};
    if (!$map_src) {
        ::info("No map for $src:$sprt. Dropping packet");
        return;
    }
    my $map = $map_src->[2][$id] || die "Assertion: No Sender socket[$id]";
    $map->{seq} = $map_src->[0]++;
    die "Too many packets from $src:$sprt" if $map->{seq} == $map_src->[0];
    my $fou = $FOU[$map->{fou_id}] ||
        die "Assertion: No Fou::UDP with id '$map->{fou_id}'";
    my $ndst = $map->{addr};
    my $dprt = $map->{port};

    # Build FOU IP packet

    # Packet ID is meaningless for atomic packets (RFC 6864)
    my $packet_id = int rand 2**16;
    my $flags = $DF;

    my $length = length($data);
    my $new_length = $length + $IHL * 4 + $UDP_HEADER;
    # Currently we don't handle overly large FOU packets
    if ($new_length >= 2**16) {
        ::info("Cannot build oversized FOU packet. Dropped") if $debug;
        return;
    }

    my $header = pack("CCnnnCCx2a4a4",
                      $IP_VERSION << 4 | $IHL,
                      0,
                      $new_length,
                      $packet_id,
                      $DF << 13 | 0,
                      $ttl,
                      $PROTO_UDP,
                      $nsrc,
                      $ndst,
                  );
    my $sum = unpack("%32n*", $header);
    while ($sum > 0xffff) {
        my $carry = $sum >> 16;
        $sum &= 0xffff;
        $sum += $carry;
    }
    substr($header, 10, 2, pack("n", 0xffff - $sum));

    my $pseudo10 = pack("a4a4xC", $nsrc, $ndst, $PROTO_UDP);
    my $udp_header = pack("nnn", $sprt, $dprt, $length + $UDP_HEADER);
    # Temporarily add a 0 byte so we can do even padding
    $data .= "\0";

    $sum = unpack("%32n*", $pseudo10) + unpack("%32n*", $udp_header) + unpack("%32n*", $data) + $length + $UDP_HEADER;

    while ($sum > 0xffff) {
        my $carry = $sum >> 16;
        $sum &= 0xffff;
        $sum += $carry;
    }
    chop $data;
    my $buffer = $header . $udp_header . pack("n", 0xffff - $sum || 0xffff) . $data;

    if (0) {
        my $buf = $buffer;
        # For FOU packet construction debug
        my ($ihl, $ecn, $length, $packet_id, $fragment, $ttl, $proto, $chksum, $src, $dst) = unpack("CCnnnCCna4a4", $buf);
        my $version = $ihl >> 4;
        $ihl &= 0xf;
        my $flags = $fragment >> 13;
        $fragment &= 0x1fff;
        # only TCP4
        $version == $IP_VERSION || die "Wrong version $version";
        # Only UDP
        $proto == $PROTO_UDP || die "Wrong proto $proto";
        # Sanity check on buffer
        length($buf) == $length ||
            die "Wrong length ", length($buf);
        # We don't handle IP options (yet)
        $ihl == $IHL || die "Wrong ihl $ihl";
        # Too many hops
        $ttl || die "Bad TTL $ttl";
        # Don't handle fragments (fragment offset)
        die "Unexpected fragment $fragment" if $fragment;
        # Don't handle fragments (MF flag set)
        die "Bad flags $flags" if $flags & 0x1;

        my $pseudo10 = pack("a4a4xC", $src, $dst, $proto);

        $ihl *= 4;
        my $header = substr($buf, 0, $ihl, "");
        $length -= $ihl;

        # No buffer padding needed since length($header) is even
        my $sum = unpack("%32n*", $header);
        while ($sum > 0xffff) {
            my $carry = $sum >> 16;
            $sum &= 0xffff;
            $sum += $carry;
        }
        $sum == 0xffff || die "Bad IP checksum $sum";

        $src = inet_ntoa($src);
        $dst = inet_ntoa($dst);

        my $dscp = $ecn >> 3;
        $ecn &= 0x7;
        ::info("HEADER: DSCP=$dscp, ECN=$ecn, ID=$packet_id, FLAGS=$flags, FRAGMENT=$fragment, TTL=$ttl, CHKSUM=$chksum, SUM=$sum, SRC=$src, DST=$dst");

        # Must have space for UDP header
        die "Bad UDP length $length" if $length < $UDP_HEADER;

        # Pad buffer 0 so a last single byte still gets processed as "n"
        $sum = unpack("%32n*", $buf . "\x0") + unpack("%32n*", $pseudo10) + $length;
        my ($sprt, $dprt, $udp_len, $udp_chksum) = unpack("nnnn", substr($buf, 0, $UDP_HEADER, ""));
        $udp_len == $length || die "Inconsistent UDP length";
        $length -= $UDP_HEADER;

        if ($udp_chksum) {
            while ($sum > 0xffff) {
                my $carry = $sum >> 16;
                $sum &= 0xffff;
                $sum += $carry;
            }
            $sum == 0xffff || die "Bad UDP chksum $sum";
        }

        ::info("SPRT=$sprt, DPRT=$dprt, LEN=$udp_len, CHK=$udp_chksum");
    }
    ::info("Queue packet (TTL %d) for FOU[%d]: %s:%d -> %s:%d",
           $ttl, $map->{fou_id}, $src, $sprt, $map->{host}, $map->{port}) if
               $debug;
    if ($msghdr) {
        $fou->write(bless {
            name => "",
            buf  => $buffer,
            control => ::pack_cmsghdr(
                $IPPROTO_IP,
                $IP_TTL,
                pack("I", $ttl || die "Assertion: TTL 0")),
            flags => 0,
        }, "Socket::MsgHdr");
    } else {
        $fou->write($buffer);
    }
}

sub set_peer {
    my ($line, $name, $value) = @_;

    my $i = $setting_ids{$name};
    defined $i || croak "Unknown global variable '$name'";
    $value //= $settings{$name} // die "Assertion: Setting '$name' to undef";
    $line->write($SET, pack("w", $i), $value);
}

sub socket_udp_connected {
    my ($class, $host, $port) = @_;

    $port = $port =~ /^0\z|^[1-9][0-9]*\z/ ? int($port) :
        getservbyname($port, "udp") || die "Unknown UDP service '$port'";
    my $addr = inet_aton($host) || die "Could nor resolve '$host'";
    socket(my $socket, PF_INET, SOCK_DGRAM, $PROTO_UDP) ||
        die "Could not create UDP socket: $^E";
    my $remote = pack_sockaddr_in($port, $addr);
    connect($socket, $remote) || die "Could not connect socket: $^E";
    $socket->blocking(0);

    wantarray || return $socket;

    my $sockaddr = getpeername($socket) ||
        die "Assertion: Could not getpeername: $^E";
    my ($p, $address) = unpack_sockaddr_in($sockaddr);
    my $h = inet_ntoa($address);
    return $h, $p, $socket;
}

sub socket_udp {
    my ($class, $host, $port, $probe) = @_;

    $port = $port =~ /^0\z|^[1-9][0-9]*\z/ ? int($port) :
        getservbyname($port, "udp") || die "Unknown UDP service '$port'";
    my $addr = inet_aton($host) || die "Could nor resolve '$host'";
    socket(my $socket, PF_INET, SOCK_DGRAM, $PROTO_UDP) ||
        die "Could not create UDP socket: $^E";
    my $local = pack_sockaddr_in($port, $addr);
    if ($probe) {
        return 1 if bind($socket, $local);
        $! == EADDRINUSE || die "Could not bind socket: $^E";
        return 0;
    }
    bind($socket, $local) || die "Could not bind socket: $^E";
    $socket->blocking(0);
    wantarray || return $socket;

    my $sockaddr = getsockname($socket) ||
        die "Assertion: Could not getsockname: $^E";
    my ($p, $address) = unpack_sockaddr_in($sockaddr);
    my $h = inet_ntoa($address);
    return $h, $p, $socket;
}

sub socket_tcp {
    my ($class, $host, $port, $listen) = @_;

    $port = $port =~ /^0\z|^[1-9][0-9]*\z/ ? int($port) :
        getservbyname($port, "tcp") || die "Unknown TCP service '$port'";
    $host = "0.0.0.0" if $host eq "";
    my $addr = inet_aton($host) || die "Could nor resolve '$host'";
    socket(my $socket, PF_INET, SOCK_STREAM, $PROTO_TCP) ||
        die "Could not create TCP socket: $^E";
    my $local = pack_sockaddr_in($port, $addr);
    if ($listen) {
        setsockopt($socket, SOL_SOCKET, SO_REUSEADDR, 1) ||
            die "Assertion: Could not setsockopt(SOL_SOCKET, SO_REUSEADDR): $^E";
        bind($socket, $local) || die "Could not bind socket: $^E";
        listen($socket, $LISTEN_BACKLOG) || die "Could not listen: $^E";
    } else {
        connect($socket, $local) || die "Could not connect to $host:$port: $^E";
    }
    $socket->blocking(0);
    wantarray || return $socket;

    my $sockaddr = getsockname($socket) ||
        die "Assertion: Could not getsockname: $^E";
    my ($p, $address) = unpack_sockaddr_in($sockaddr);
    my $h = inet_ntoa($address);
    return $h, $p, $socket;
}

package main;
# use Scalar::Util qw(weaken);

sub _info {
    local ($!, $^E);
    my $role = ucfirst(shift);
    if (!@_) {
        my (undef, $filename, $line) = caller(1);
        @_ = ("$filename $line");
    }
    my $format = shift;
    $format =~ s/\n?\z/\n/;
    if (!@_) {
        @_ = ($format);
        $format = "%s";
    }
    my $time = Timer->realtime;
    my $itime = int($time);
    my ($sec, $min, $hour, $day, $mon, $year) = localtime($itime);
    my $gtime = timegm($sec, $min, $hour, $day, $mon, $year);
    my $offset = ($gtime - $itime) / 60;
    my $sign = "+";
    if ($offset < 0) {
        $sign = "-";
        $offset = -$offset;
    }
    my $hoffset = $offset / 60;
    my $moffset = $offset % 60;
    printf(STDERR "%04d-%02d-%02d %02d:%02d:%06.3f %s%02d%02d %s: $format",
           $year+1900, $mon+1, $day, $hour, $min, $time-$itime+$sec,
           $sign, $hoffset, $moffset,
           $role, @_);
}

sub info {
    _info($role, @_);
}

sub peer_info {
    _info($role_peer, @_);
}

sub caller_info {
    my $format = shift;
    my (@lines, $line, $i);
    push @lines, $line while $line = (caller(++$i))[2];
    if (@_) {
        info("$format [line %s]", @_, "@lines");
    } else {
        info("$format [line @lines]");
    }
}

my %display = (
    "\r"	=> '\r',
    "\n"	=> '\n',
    "\t"	=> '\t',
    "\0"	=> '\0',
    "\\"	=> '\\',
    );
sub display {
    my ($data) = @_;

    my $long = length $data > 30;
    $data = substr($data, 0, 37) if $long;
    # $data =~ s{([^\x20-\x7e])}{sprintf('\x%02x', ord $1)}eg;
    my $hex = unpack("H*", $data);
    $data =~ s{([^\x20-\x7e])}{$display{$1} || "."}eg;
    $data .= " ($hex)";
    $data .= " ..." if $long;
    return $data;
}

sub client {
    my ($socket_in, $socket_out, $udp_locals, $udp_remotes) = @_;

    eval {
        my $line = LineProtocol->new($socket_in, $socket_out);

        for my $udp (@$udp_locals) {
            my ($from_port, $separator, $to_port) =
                $udp =~ m{^([^/]+)([/=])([^/]+)\z} or
                die "Invalid udp_local '$udp'";
            my $from_host = $from_port =~ s{(.*):}{}s ? $1 :
                $default_local_bind;
            my $to_host   = $to_port   =~ s{(.*):}{}s ? $1 :
                $default_local_bind;
            my $l = $separator eq "/" ? $line : $LINE;
            my $fou = Fou::UDP->new($to_host, $to_port);
            my $listener = Listener::UDP->new($l, $from_host, $from_port, $fou);
        }

        $line->set_peer(EPOCH      => $BASE_TIME);
        $line->set_peer(TIMEOUT    => $settings{TIMEOUT});
        $line->set_peer(KEEPALIVE  => $settings{KEEPALIVE});
        # $line->set_peer(LOW_WATER  => $settings{LOW_WATER});
        # $line->set_peer(HIGH_WATER => $settings{HIGH_WATER});

        for my $udp (@$udp_remotes) {
            $udp =~ m{^[^/]+[/=][^/]+\z} or die "Invalid udp remote '$udp'";
            $line->write($UDP_REMOTE, $udp);
        }

        $line->write($START);

        Events->mainloop();
    };
    die "\u$role: $@" if $@;
}

sub server {
    my ($socket_in, $socket_out) = @_;
    eval {
        my $line = LineProtocol->new($socket_in, $socket_out);

        $line->set_peer(EPOCH => $BASE_TIME);

        Events->mainloop();
    };
    die "\u$role: $@" if $@;
}

my $remote_perl = "/usr/bin/perl";
GetOptions("server:s"		=> \my $server,
           "client=s"		=> \my $client,
           "server_lib=s"	=> \my @server_lib,
           "ssh=s"		=> \$ssh,
           "M|master"		=> \my $ssh_master,
           "perl=s"		=> \$remote_perl,
           "server_verbose!"	=> \my $server_verbose,
           "client_verbose!"	=> \my $client_verbose,
           "verbose!"		=> \$verbose,
           "server_debug!"	=> \my $server_debug,
           "client_debug!"	=> \my $client_debug,
           "debug!"		=> \$debug,
           "keepalive=o"	=> \$settings{KEEPALIVE},
           "timeout=o"		=> \$settings{TIMEOUT},
           "stuff!"		=> \my $stuff,
           "l=s"		=> \my @udp_local,
           "r=s"		=> \my @udp_remote,
           "udp_max=i"		=> \my $udp_max,
           "version!"		=> \my $version,
           "U|unsafe!"		=> \my $unsafe,
           "h|help!"		=> \my $help) ||
    die "Could not parse your command line. Try $Script -h\n";

if ($version) {
    print<<"EOF";
udp_proxy (Ton Utils) $VERSION
EOF
    exit 0;
}

if ($help) {
    require Config;
    $ENV{PATH} .= ":" unless $ENV{PATH} eq "";
    $ENV{PATH} = "$ENV{PATH}$Config::Config{'installscript'}";
    exec("perldoc", "-F", $unsafe ? "-U" : (), $0) || exit 1;
    # make parser happy
    %Config::Config = ();
}

$role = "server" if defined $server;
$role_peer = $role eq "server" ? "client" : "server";

if ($role eq "server") {
    die "Cannot be both server and client\n" if defined $client;
    die "Cannot have stuff in server mode\n" if $stuff;
    die "Cannot set udp_max at server\n" if defined $udp_max;

    my $socket_in  = \*STDIN;
    my $socket_out = \*STDOUT;
    if (defined $server && $server ne "") {
        my $host = $server =~ s{(.*):}{}s ? $1 :
            $default_local_bind;
        my ($h, $p, $socket) = LineProtocol->socket_tcp($host, $server, 1);
        $socket->blocking(1);
        ::info("Listening on port $p") if $server eq "0";
        my $from = accept(my $accepted, $socket) || die "Accept failed: $^E";
        if ($debug || $verbose) {
            my ($port, $addr) = unpack_sockaddr_in($from);
            my $host = inet_ntoa($addr);
            ::info("Accepted TCP line connection from %s:%d", $host, $port);
        }
        $socket_in = $socket_out = $accepted;
    }
    server($socket_in, $socket_out);
    die "Assertion: \u$role fell off the mainloop";
}

# From here on we are the client

if (defined $udp_max) {
    die "udp_max must be positive" if $udp_max < 1;
    $settings{UDP_MAX} = $udp_max;
}
if (defined $client) {
    die "Cannot have arguments in client mode" if @ARGV;
    die "Cannot have stuff in client mode" if $stuff;
} else {
    @ARGV || die "Missing remote host argument, Try $Script -h\n";
    $stuff //= 1;
    if ($stuff) {
        @ARGV == 1 || die "Spurious arguments\n";
    }
}

$verbose        = $debug        if $debug        && !defined $verbose;
$client_verbose = $client_debug if $client_debug && !defined $client_verbose;
$server_verbose = $server_debug if $server_debug && !defined $server_verbose;

$server_debug   = $client_debug   = 1 if $debug;
$server_verbose = $client_verbose = 1 if $verbose;

die "timeout $settings{TIMEOUT} must be positive\n" if $settings{TIMEOUT} <= 0;
die "keepalive $settings{KEEPALIVE} must be positive\n" if $settings{KEEPALIVE} <= 0;

if ($client) {
    my $host = $client =~ s{(.*):}{}s ? $1 : "127.0.0.1";
    my $socket = LineProtocol->socket_tcp($host, $client);
    client($socket, $socket, \@udp_local, \@udp_remote);
    die "Assertion: \u$role fell off the mainloop";
}

pipe(my $rd0, my $wr0) || die "Could not pipe: $^E";
pipe(my $rd1, my $wr1) || die "Could not pipe: $^E";
defined(my $pid = fork()) || die "could not fork: $^E";

if ($pid) {
    # Parent
    # This side does the ssh connection so that ^C goes to ssh
    eval {
        close $wr0;
        close $rd1;
        open(STDIN,  "<&", $rd0) || die "Could not dup STDIN: $^E";
        close $rd0;
        open(STDOUT, ">&", $wr1) || die "Could not dup STDOUT: $^E";
        close $wr1;

        if ($stuff) {
            # delete @ENV{qw(LANGUAGE LC_ALL LANG)};
            my $remote_host = shift;
            exec($ssh, $ssh_master ? "-M" : (), "-e", "none", $remote_host, $remote_perl) ||
                die "Could not exec $ssh: $^E";
        } else {
            push @ARGV, "$Bin/$Script" if @ARGV == 1;
            exec($ssh, $ssh_master ? "-M" : (), "-e", "none", @ARGV) ||
                die "Could not exec $ssh: $^E";
        }
    };
    die $@ || "No error";
}

# Child
close $rd0;
close $wr1;
$wr0->autoflush(1);

if ($stuff) {
    my $self = "$Bin/$Script";
    open(my $fh, "<", $self) || die "Could not open $self: $^E";
    my $content = qq(#line 1 "$Bin/$Script"\n);
    $content .= do { local $/; <$fh> };
    $content =~ s/\n__END__\n.*/\n/s || die "Could not find __END__";
    # Remove full line comments, but not #line statements.
    # Leave the \n so line numbers in error messages keep working
    $content =~ s/^[^\S\n]*#(?![^\S\n]*line\s).*//mg;
    # Drop leading spaces. Saves about 20%
    # (less of course if the ssh does compression, as it does by default)
    $content =~ s/^[^\S\n]+//mg;

    # Change a few variables in the server code
    my %replace =
        (verbose	=> $server_verbose,
         debug		=> $server_debug,
         role		=> "server",
     );
    while (my ($name, $value) = each %replace) {
        local $Data::Dumper::Indent  = 0;
        local $Data::Dumper::Purity  = 1;
        local $Data::Dumper::Varname = $name;
        $value = Dumper($value);
        $value =~ s/\$\Q$name\E1\b/\$$name/g || die "Assertion: No VAR1";
        # info("Value=<$value>") if $verbose;
        $content =~ s{^([^\S\n]*(?:my|our)\s*)\$\Q$name\E\s*=[^;\n]*;[^\S\n]*\n}{$1$value\n}m || die "Could not set $name";
    }

    print($wr0 $PRE_STUFFER) || die "Write error:$^E";
    for my $server_lib (map split(/:/), @server_lib) {
        print($wr0 qq(use lib "$server_lib";\n)) || die "Write error:$^E";
    }
    # print($wr0 qq(\$Script="\$Script"\n)) || die "Write error:$^E";
    print($wr0 $content) || die "Write error:$^E";
    print($wr0 $POST_STUFFER) || die "Write error:$^E";
    my $line = "";
    while (length($line) < length($STUFFED)) {
        alarm(60);
        my $rc = sysread($rd1, $line, length($STUFFED)-length $line, length $line);
        if (!defined $rc) {
            next if $! == EINTR;
            die "Read error: $^E";
        }
        die "Unexpected EOF" if $rc == 0;
    }
    alarm(0);
    $line eq $STUFFED || die "Bad server confirm $line";
}
client($rd1, $wr0, \@udp_local, \@udp_remote);
die "Assertion: \u$role fell off the mainloop";

__END__
Implementation notes:
