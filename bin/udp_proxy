#!/usr/bin/perl -w
my $null;
BEGIN {
    # This must come before any modules, even use strict/warnings
    # (to avoid these modules keeping open early file handles for __DATA__)
    open($null, "+<", "/dev/null") || die "Could not open '/dev/null': $^E";
    die "Assertion: Should at least have the source code open at fileno 0" if
        fileno($null) == 0;
    if (fileno($null) == 1) {
        # Perl will automatically subsume fd 1 into STDOUT
        open($null = undef, "+>&STDOUT") || die "Could not dup STDOUT: $^E";
    }
    if (fileno($null) == 2) {
        # Perl will automatically subsume fd 2 into STDERR
        open($null = undef, "+>&STDERR") || die "Could not dup STDERR: $^E";
    }
    $^F == 2 || die "Assertion: Invalid CLO_EXEC range";
    fileno($null) > 2 || die "Assertion: Invalid NULL handle";
    # So now we are absolutely sure $null has CLO_EXEC
}
# Now take over STDIN in case we had no STDIN and perl opened it as source code
# We should have a DATA filehandle because this file has an __END__ section
# (but for unclear reasons it does not when stuffing --Ton)
if (defined fileno(DATA)) {
    fileno(DATA) != fileno(STDIN) ||
        open(STDIN, "<&", $null) || die "Could not dup to STDIN: $^E";
    close(DATA);
}

use strict;
use warnings;

# modprobe fou
# ip link add name fou1 type ipip remote 127.0.0.1 local 127.0.0.1 ttl 225 encap fou encap-sport auto encap-dport 1236
# ip link set fou1 up
# ip addr add 10.253.4.1/24 dev fou1
# # If you add "dev fou1" to the add port it seems to stop working
# # If you remove the "local 127.0.0.1" it keeps working
# ip fou add port 1237 ipproto 4 local 127.0.0.1

# Redirect packets to port 1234 into the fou1 tunnel:
# iptables -t mangle -N FWMARK2
# # iptables -t mangle -A FWMARK2 -j LOG --log-prefix 'iptables-mark2: ' --log-level info
# iptables -t mangle -A FWMARK2 -j MARK --set-mark 17
# iptables -t mangle -A OUTPUT -p udp --dport 1234 -j FWMARK2
# # Also catch ping requests
# # iptables -t mangle -A OUTPUT -p icmp --icmp-type 8 -j FWMARK2
# ip rule add fwmark 17 lookup 101
# ip route add default via 10.253.4.1 table 101

# Avoid other stuff sneaking into the tunnel
# (not sure how, but when using deluge (torrent): external traffic not on the marked port gets into the tunnel)
# iptables -t mangle -A INPUT -d 10.253.4.1 -j DROP
# iptables -t mangle -A OUTPUT -s 10.253.4.1 -j DROP

# sysctl -w net.ipv4.conf.all.rp_filter=0
# sysctl -w net.ipv4.conf.fou1.rp_filter=0

# ip fou del port 1237 ipproto 4 local 127.0.0.1
# ip link del name fou1

# Ping forwarding needs permission to open a IPPROTO_ICMP sockets on the
# forwarded host.
# E.g. On linux:
#   Query current permissions:
#      sysctl net.ipv4.ping_group_range
#   Allow group 1014:
#      sysctl net.ipv4.ping_group_range='1014 1014'

our $VERSION = "1.000";

use FindBin qw($Bin $Script);
use Getopt::Long 2.24 qw(:config bundling require_order);
use Carp;
use Sys::Hostname;
use Errno qw(EINTR);
use Time::Local qw(timegm);
use Socket qw(inet_aton inet_ntoa unpack_sockaddr_in);

use Data::Dumper;
$Data::Dumper::Indent   = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Useqq	= 1;

($Bin, $Script) = __FILE__ =~ m{^(.*)/(.+)\z} or
    die "Could not parse ", __FILE__ if $Script eq "-" && __FILE__ ne "-";

$SIG{PIPE} = "IGNORE";
$SIG{CHLD} = "IGNORE";

delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};
$ENV{PATH}="/usr/bin:/bin";

my $MULTICAST_BEGIN = inet_aton("224.0.0.0") || die "Assertion: Bad address";
# multicast range *excludes* this END address
my $MULTICAST_END   = inet_aton("240.0.0.0") || die "Assertion: Bad address";

my $IP_VERSION = 4;
defined(my $PROTO_ICMP = getprotobyname("icmp")) || die "Unknown protocol ICMP";
defined(my $PROTO_UDP  = getprotobyname("udp"))  || die "Unknown protocol UDP";
defined(my $PROTO_TCP  = getprotobyname("tcp"))  || die "Unknown protocol TCP";
my $IHL = 5;
my $ICMP_HEADER = 8;
my $UDP_HEADER  = 8;
my $DF = 2;
my $TTL = 64;
my $ICMP_ECHO_REQUEST = 8;
my $ICMP_ECHO_REPLY = 0;

my $ssh = "/usr/bin/ssh";
my $verbose = undef;
my $debug   = 0;
my $timeout = 120;
my $keepalive = 300;
my $udp_max = 10;
my $ping_max = 10;
my $global_timeout = undef;
my $default_local_bind  = "127.0.0.1";
my $default_remote_bind = "127.0.0.1";
my $exit = 0;

# How long a server UDP socket lingers without traffic
# How long an errored TCP connection tries to push lingering output
my $SOCKS_TIMEOUT = 120;
# How much we can typically fit into our communication channel
my $LINE_BLOCK_SIZE = int(2**14);
my $BLOCK_SIZE = int(2**16);
my $UDP_SIZE = int(2**16);
my $LISTEN_BACKLOG = 128;

my @PING =
    $^O eq "solaris" ? (["/bin/ping", "-s"], ["64", "1"]) :
    (["/bin/ping", "-c", "1"], []);

my %settings_global = (
    EPOCH	=> undef,
    MSGHDR	=> undef,
    READLINE	=> undef,
    TIMEOUT	=> undef,
    KEEPALIVE	=> undef,
    UDP_MAX	=> undef,
    PING_MAX	=> undef,
    # ACK_LIMIT should be greater than KEEPALIVE/ACK packet
    # (Code will increase it if not, but you will still send way too many ACKs)
    ACK_LIMIT	=> int(1e6),
    # For debugging:
    # ACK_LIMIT	=> 0,
);
my @setting_ids = sort keys %settings_global;
my %setting_ids;
$setting_ids{$setting_ids[$_]} = $_ for 0..$#setting_ids;

my $SECRET = pack("NNNN", $$ ^ rand 2**32, $^T ^ rand 2**32, rand 2**32, rand 2**32);

my $STUFFED = "GoNow";

# Line protocol commands
my $START	= "1";
my $SET		= "S";	# sets a server variable
my $UDP_REMOTE	= "r";
my $PING	= "P";
my $RESPONSE_PING= "p";
my $RESPONSE_UDP= "d";
my $DATA_UDP	= "D";
my $KEEP	= "K";	# Keepalive/ACK packet

my $ERROR_ECONNREFUSED	= "Connection refused";
my $ERROR_ENETUNREACH	= "Network is unreachable";
my $ERROR_ETIMEDOUT	= "Timed out";
my $ERROR_ERESOLV	= "Could not resolve host";

my $msghdr_error;
BEGIN {
    # Can't use "require" later on since Socket::MsgHdr has INIT blocks
    $msghdr_error = eval(sprintf(qq(#line %d "%s"\nuse Socket::MsgHdr qw(pack_cmsghdr unpack_cmsghdr sendmsg recvmsg); 1), __LINE__, __FILE__)) ? "" :
        $@ || "Unknown error loading Socket::MsgHdr\n";
    $msghdr_error =~ s/^BEGIN failed.*\n\z//m;
}
my $readline_error = eval(sprintf(qq(#line %d "%s"\nuse Term::ReadLine; 1), __LINE__, __FILE__)) ? "" :
        $@ || "Unknown error loading Term::ReadLine\n";
$readline_error =~ s/^BEGIN failed.*\n\z//m;

END {
    # Carp.pm can stash objects in @DB::args causing them not to get freed
    @DB::args = ();
}

my $FREE_BSD = $^O eq "freebsd";
# IPPROTO_IP exists in Socket, but not in really old ones
my $IPPROTO_IP = 0;
my ($IP_RECVTTL, $IP_TTL, $IP_PKTINFO, $ICMP_FILTER, $SOL_RAW);
if (!$msghdr_error) {
    if (0 && $FREE_BSD) {
        # FreeBSD uses IP_RECVDSTADDR
        $IP_PKTINFO	=  7;
        $IP_RECVTTL	= 65;
        $IP_TTL		=  4;
    } elsif ($^O eq "linux") {
        $IP_PKTINFO	=  8;
        $IP_RECVTTL	= 12;
        $IP_TTL		=  2;
        $ICMP_FILTER	=  1;
        $SOL_RAW	=255;
    } else {
        $msghdr_error = "Socket::MsgHdr constants for OS $^O not implemented (yet)\n";
    }
}

my $msghdr = $msghdr_error ? undef : Socket::MsgHdr->new();
my $loops;

my $role = "client";
my $role_peer;

# Determine some system settings
my $hostname = hostname();
my $me;
if ($^O eq "MSWin32") {
    require Win32;
    $me = Win32::LoginName();
} else {
    if (my $user = $ENV{LOGNAME}) {
        if (defined(my $uid = getpwnam($user))) {
            $me = $user if $> == $uid;
        }
    }
    $me ||= getpwuid $>;
}
die "Can't determine who I am" if !$me;

die "Bad file '", __FILE__, "'" if __FILE__ =~ /["\n\0]/;
# Client stuffer
my $POST_STUFFER = sprintf(qq(#line %d "%s"\n%s),
                           __LINE__, __FILE__, '
BEGIN {
    eval {
        open($SAVED_STDIN, "<&", \*STDIN);
        open(STDIN, "<", "/dev/null") || die "NULL: $!";
        1;
    } or do {
        print STDERR $@ || "Unknown error\n";
        exit 255;
    };
}
');
my $PRE_STUFFER = sprintf(qq(#line %d "%s"\n%s),
                           __LINE__, __FILE__, '
BEGIN { $^W = 1 }

my $SAVED_STDIN;
open(STDIN, "<&", $SAVED_STDIN) || die "Could not dup STDIN: $^E";
close($SAVED_STDIN) || die "Could not close SAVED_STDIN: $^E";
$| = 1;
print "' . $STUFFED . '";
');

my $nr_events = 0;
{
    package Events;
    # A small event core
    use Carp;
    use Errno qw(EINTR);

    my $read_mask  = "";
    my $write_mask = "";
    my $error_mask = "";
    my (%read_refs, %write_refs, %error_refs);

    # All placeholder subs are the same sub
    use constant NOP => sub {};

    sub Events::Read::DESTROY {
        defined(my $fd = ${shift()}) || die "No filedescriptor";
        ::caller_info("delete_read $fd") if $debug;
        # This strange assign after delete is to update the reference the for in
        # sub mainloop may still have in such a way that element 0 keeps existing
        # (otherwise a confess during the callback will access freed memory)
        # We could set either the object (index 0) or the callback (index 1)
        # But the object is already weak and the callback may be a closure
        delete($read_refs{$fd})->[1] = NOP;
        if (%read_refs) {
            vec($read_mask, $fd, 1) = 0;
            $read_mask =~ s/\x00+\z//;
        } else {
            $read_mask = "";
        }
        --$nr_events;
    }

    sub Events::Read0::DESTROY {
        defined(my $fd = ${shift()}) || die "No filedescriptor";
        ::caller_info("delete_read0 $fd") if $debug;
        # This strange assign after delete is to update the reference the for in
        # sub mainloop may still have in such a way that element 0 keeps existing
        # (otherwise a confess during the callback will access freed memory)
        # We could set either the object (index 0) or the callback (index 1)
        # But the object is already weak and the callback may be a closure
        delete($read_refs{$fd})->[1] = NOP;
        if (%read_refs) {
            vec($read_mask, $fd, 1) = 0;
            $read_mask =~ s/\x00+\z//;
        } else {
            $read_mask = "";
        }
    }

    sub Events::Write::DESTROY {
        defined(my $fd = ${shift()}) || die "No filedescriptor";
        ::caller_info("delete_write $fd") if $debug;
        # This strange assign after delete is to update the reference the for in
        # sub mainloop may still have in such a way that element 0 keeps existing
        # (otherwise a confess during the callback will access freed memory)
        # We could set either the object (index 0) or the callback (index 1)
        # But the object is already weak and the callback may be a closure
        delete($write_refs{$fd})->[1] = NOP;
        if (%write_refs) {
            vec($write_mask, $fd, 1) = 0;
            $write_mask =~ s/\x00+\z//;
        } else {
            $write_mask = "";
        }
        --$nr_events;
    }

    sub Events::Write0::DESTROY {
        defined(my $fd = ${shift()}) || die "No filedescriptor";
        ::caller_info("delete_write0 $fd") if $debug;
        # This strange assign after delete is to update the reference the for in
        # sub mainloop may still have in such a way that element 0 keeps existing
        # (otherwise a confess during the callback will access freed memory)
        # We could set either the object (index 0) or the callback (index 1)
        # But the object is already weak and the callback may be a closure
        delete($write_refs{$fd})->[1] = NOP;
        if (%write_refs) {
            vec($write_mask, $fd, 1) = 0;
            $write_mask =~ s/\x00+\z//;
        } else {
            $write_mask = "";
        }
    }

    sub Events::Error::DESTROY {
        defined(my $fd = ${shift()}) || die "No filedescriptor";
        ::caller_info("delete_error $fd") if $debug;
        # This strange assign after delete is to update the reference the for in
        # sub mainloop may still have in such a way that element 0 keeps existing
        # (otherwise a confess during the callback will access freed memory)
        # We could set either the object (index 0) or the callback (index 1)
        # But the object is already weak and the callback may be a closure
        delete($error_refs{$fd})->[1] = NOP;
        if (%error_refs) {
            vec($error_mask, $fd, 1) = 0;
            $error_mask =~ s/\x00+\z//;
        } else {
            $error_mask = "";
        }
        --$nr_events;
    }

    sub Events::Error0::DESTROY {
        defined(my $fd = ${shift()}) || die "No filedescriptor";
        ::caller_info("delete_error0 $fd") if $debug;
        # This strange assign after delete is to update the reference the for in
        # sub mainloop may still have in such a way that element 0 keeps existing
        # (otherwise a confess during the callback will access freed memory)
        # We could set either the object (index 0) or the callback (index 1)
        # But the object is already weak and the callback may be a closure
        delete($error_refs{$fd})->[1] = NOP;
        if (%error_refs) {
            vec($error_mask, $fd, 1) = 0;
            $error_mask =~ s/\x00+\z//;
        } else {
            $error_mask = "";
        }
    }

    package Events;
    use Scalar::Util qw(weaken);

    sub add_read {
        defined(my $fd = fileno(shift)) || croak "Not a filehandle";
        ::caller_info("add_read $fd") if $debug;
        croak "Descriptor $fd already selected for read" if $read_refs{$fd};
        vec($read_mask, $fd, 1) = 1;
        weaken(($read_refs{$fd} = [shift, shift])->[0]);
        ++$nr_events;
        return bless \$fd, "Events::Read";
    }

    sub add_read0 {
        defined(my $fd = fileno(shift)) || croak "Not a filehandle";
        ::caller_info("add_read0 $fd") if $debug;
        croak "Descriptor $fd already selected for read" if $read_refs{$fd};
        vec($read_mask, $fd, 1) = 1;
        weaken(($read_refs{$fd} = [shift, shift])->[0]);
        return bless \$fd, "Events::Read0";
    }

    sub add_write {
        defined(my $fd = fileno(shift)) || croak "Not a filehandle";
        ::caller_info("add_write $fd") if $debug;
        croak "Descriptor $fd already selected for write" if $write_refs{$fd};
        vec($write_mask, $fd, 1) = 1;
        weaken(($write_refs{$fd} = [shift, shift])->[0]);
        ++$nr_events;
        return bless \$fd, "Events::Write";
    }

    sub add_write0 {
        defined(my $fd = fileno(shift)) || croak "Not a filehandle";
        ::caller_info("add_write0 $fd") if $debug;
        croak "Descriptor $fd already selected for write" if $write_refs{$fd};
        vec($write_mask, $fd, 1) = 1;
        weaken(($write_refs{$fd} = [shift, shift])->[0]);
        return bless \$fd, "Events::Write0";
    }

    sub add_error {
        defined(my $fd = fileno(shift)) || croak "Not a filehandle";
        ::caller_info("add_error $fd") if $debug;
        croak "Descriptor $fd already selected for error" if $error_refs{$fd};
        vec($error_mask, $fd, 1) = 1;
        weaken(($error_refs{$fd} = [shift, shift])->[0]);
        ++$nr_events;
        return bless \$fd, "Events::Error";
    }

    sub add_error0 {
        defined(my $fd = fileno(shift)) || croak "Not a filehandle";
        ::caller_info("add_error0 $fd") if $debug;
        croak "Descriptor $fd already selected for error" if $error_refs{$fd};
        vec($error_mask, $fd, 1) = 1;
        weaken(($error_refs{$fd} = [shift, shift])->[0]);
        return bless \$fd, "Events::Error0";
    }

    sub __unloop {
        no warnings "exiting";
        last MAINLOOP;
    }

    my $unloop;
    sub _unloop {
        return if $unloop;
        $unloop = bless {};
        $unloop->{timer} = Timer::immediate(
            $unloop,
            sub {
                $unloop = undef;
                no warnings "exiting";
                last MAINLOOP;
            });
    }

    sub mainloop {
        # ::info("WARNING (can safely be ignored): $msghdr_error") if
        #    $msghdr_error && ($verbose || $debug);
        ::info("Entering mainloop $$ (nr_events=$nr_events)") if
            $verbose || $debug;
        _mainloop();
        ::info("Exiting mainloop $$ (nr_events=$nr_events)") if
            $verbose || $debug;
    }

    sub _mainloop {
        my ($r, $w, $e);
        # my $name;
      MAINLOOP:
        while ($nr_events) {
            if ((select($r = $read_mask,
                        $w = $write_mask,
                        $e = $error_mask,
                        Timer::timers_collect()) || next) > 0) {
                # The copy to @tmp is because the stack doesn't keep values
                # alive, so any deletes on xxx_refs during the loop can make
                # the value go poof. The copy temporarily increases the
                # refcount so the value doesn't go away. That is also why the
                # delete_xxx functions modify the value before delete
                # $name = $_->[1], $_->[0]->$name for my @tmp=(
                $_->[1]->($_->[0] || next) for my @tmp=(
                    # $$_ and $$_->[0]->(@{$$_->[1]}[1..$#{$$_->[1]}]) for
                    @read_refs{ grep vec($r, $_, 1), keys %read_refs},
                    @write_refs{grep vec($w, $_, 1), keys %write_refs},
                    @error_refs{grep vec($e, $_, 1), keys %error_refs});
            } elsif ($! == EINTR) {
                redo;
            } else {
                die "Select failed: $^E";
            }
        } continue {
            Timer::timers_run();
        }
    }

    no warnings "once";
    *IO::Handle::add_read	= \&add_read;
    *IO::Handle::add_read0	= \&add_read0;
    *IO::Handle::add_write	= \&add_write;
    *IO::Handle::add_write0	= \&add_write0;
    *IO::Handle::add_error	= \&add_error;
    *IO::Handle::add_error0	= \&add_error0;
}

my $CLOCK_TYPE_NAME;
{
    package Timer;
    # A small timer core
    use Scalar::Util qw(weaken refaddr);
    use Carp;
    use Time::HiRes qw(clock_gettime CLOCK_REALTIME CLOCK_MONOTONIC);

    # Timer indices
    sub INDEX	() { 0 };
    sub TIME	() { 1 };
    sub OBJ	() { 2 }; # Must come after TIME
    sub CODE	() { 3 };
    sub KEEPDEAD() { 4 };
    sub CALLERS	() { 5 };

    my @timers = (undef);
    # @expired must be persistent so no timers get lost if a callback dies
    my @expired;
    # Simular for @expired. @immediate contains timeout 0 timers that we don't
    # even bother to put in @timers
    my @immediate;

    my $CLOCK_TYPE;
    $CLOCK_TYPE_NAME =
        eval { $CLOCK_TYPE = CLOCK_MONOTONIC; "MONOTONIC" } ||
    eval { $CLOCK_TYPE = CLOCK_REALTIME;  "REAL" } ||
    die "Time::HiRes doesn't even have CLOCK_REALTIME";

    sub realtime {
        return clock_gettime(CLOCK_REALTIME);
    }

    sub clocktime : method {
        return clock_gettime($CLOCK_TYPE);
    }

    # Timers are kept in a simple binary heap @timers
    sub timer {
        if ($debug) {
            my $d = $debug;
            $debug = 0;
            my $timer = timer(@_);
            $debug = $d;
            my $callers = ::callers();
            $timer->[CALLERS] = $callers;
            ::info("add Timer(%s) %08x [%s]", $_[0], refaddr($timer), $callers);
            return $timer;
        }
        my $time = shift() + clocktime();
        my $i = @timers;
        while ($i > 1 && $time < $timers[$i >> 1][TIME]) {
            weaken($timers[$i] = $timers[$i >> 1]);
            $i = ($timers[$i][INDEX] = $i) >> 1;
        }
        my $timer = bless [$i, $time, shift, shift, 0];
        weaken($timer->[OBJ]);
        weaken($timers[$i] = $timer);
        ++$nr_events;
        return $timer;
    }

    sub timer0 {
        if ($debug) {
            my $d = $debug;
            $debug = 0;
            my $timer = timer(@_);
            $debug = $d;
            my $callers = ::callers();
            $timer->[CALLERS] = $callers;
            ::info("add0 Timer(%s) %08x [%s]", $_[0], refaddr($timer), $callers);
            return $timer;
        }
        my $time = shift() + clocktime();
        my $i = @timers;
        while ($i > 1 && $time < $timers[$i >> 1][TIME]) {
            weaken($timers[$i] = $timers[$i >> 1]);
            $i = ($timers[$i][INDEX] = $i) >> 1;
        }
        my $timer = bless [$i, $time, shift, shift, 1];
        weaken($timer->[OBJ]);
        weaken($timers[$i] = $timer);
        return $timer;
    }

    sub immediate {
        # If we ever expose the TIME element we should put clocktime() there
        my $timer = bless [0, 0, shift, shift, 0];
        weaken($timer->[OBJ]);
        weaken($immediate[@immediate] = $timer);
        if ($debug) {
            my $callers = ::callers();
            $timer->[CALLERS] = $callers;
            ::info("add Immediate Timer(0) %08x [%s]", refaddr($timer), $callers);
        }
        ++$nr_events;
        return $timer;
    }

    sub DESTROY {
        my ($timer) = @_;

        my $i = $timer->[INDEX];
        if ($debug && defined $i) {
            if ($timer->[CALLERS]) {
                my $callers = ::callers();
                ::info("delete Timer %08x [%s], added at [%s]", refaddr($timer), $callers, $timer->[CALLERS]);
            } else {
                ::caller_info("delete Timer %08x", refaddr($timer));
            }
        }
        if (!$i) {
            croak "Not a timer reference" unless defined($i);
            # Could be a timer sitting on the expired queue in run_now
            if (@$timer > TIME) {
                --$nr_events unless $timer->[KEEPDEAD];
                $#$timer = TIME;
            }
            return;
        }
        --$nr_events unless $timer->[KEEPDEAD];
        $timer->[INDEX] = 0;
        # Last element or beyond...
        if ($i >= $#timers) {
            croak "Not a timer reference" if $i > $#timers;
            pop @timers;
            return;
        }
        my $time = $timers[-1][TIME];
        if ($i > 1 && $time < $timers[$i >> 1][TIME]) {
            # percolate to root
            do {
                weaken($timers[$i] = $timers[$i >> 1]);
                $i = ($timers[$i][INDEX] = $i) >> 1;
            } while ($i > 1 && $time < $timers[$i >> 1][TIME]);
        } else {
            # percolate to leafs
            my $n = @timers-2;
            my $l = $i * 2;
            while ($l < $n) {
                if ($timers[$l][TIME] < $time) {
                    if ($timers[$l+1][TIME] < $timers[$l][TIME]) {
                        weaken($timers[$i] = $timers[$l+1]);
                        $timers[$i][INDEX] = $i;
                        $i = $l+1;
                    } else {
                        weaken($timers[$i] = $timers[$l]);
                        $timers[$i][INDEX] = $i;
                        $i = $l;
                    }
                } elsif ($timers[$l+1][TIME] < $time) {
                    weaken($timers[$i] = $timers[$l+1]);
                    $timers[$i][INDEX] = $i;
                    $i = $l+1;
                } else {
                    last;
                }
                $l = $i * 2;
            }
            if ($l == $n && $timers[$l][TIME] < $time) {
                weaken($timers[$i] = $timers[$l]);
                $timers[$i][INDEX] = $i;
                $i = $l;
            }
        }
        weaken($timers[$i] = pop @timers);
        $timers[$i][INDEX] = $i;
    }

    sub timers_collect {
        if (@immediate) {
            my $from = @expired;
            push @expired, @immediate;
            weaken($expired[$_]) for $from .. $#expired;
            @immediate = ();
        }
        return @expired ? 0 : undef if @timers <= 1;
        my $now = clocktime();
        return @expired ? 0 : $timers[1][TIME] - $now if $timers[1][TIME] > $now;

        # We will expire at least 1 timer
        # @timers > 2 makes sure that if we pop @timers we don't remove $timers[1]
        while (@timers > 2) {
            $timers[1][INDEX] = 0;
            weaken($expired[@expired] = $timers[1]);

            my $time = $timers[-1][TIME];
            my $n = @timers-2;
            my $i = 1;
            my $l = 2;
            while ($l < $n) {
                if ($timers[$l][TIME] < $time) {
                    if ($timers[$l+1][TIME] < $timers[$l][TIME]) {
                        weaken($timers[$i] = $timers[$l+1]);
                        $timers[$i][INDEX] = $i;
                        $i = $l+1;
                    } else {
                        weaken($timers[$i] = $timers[$l]);
                        $timers[$i][INDEX] = $i;
                        $i = $l;
                    }
                } elsif ($timers[$l+1][0] < $time) {
                    weaken($timers[$i] = $timers[$l+1]);
                    $timers[$i][INDEX] = $i;
                    $i = $l+1;
                } else {
                    last;
                }
                $l = $i * 2;
            }
            if ($l == $n && $timers[$l][TIME] < $time) {
                weaken($timers[$i] = $timers[$l]);
                $timers[$i][INDEX] = $i;
                $i = $l;
            }
            weaken($timers[$i] = pop @timers);
            $timers[$i][INDEX] = $i;
            return 0 if $timers[1][TIME] > $now;
        }
        if (@timers == 2) {
            $timers[1][INDEX] = 0;
            weaken($expired[@expired] = pop @timers);
        }

        return 0;
    }

    sub timers_run {
        @expired || return;
        my $fun;

        # Using while instead of for in case a callback dies
        ($fun = shift @expired and
         $fun->[KEEPDEAD]++ || $nr_events-- and
         $fun->[OBJ] and
         $fun->[CODE]->($fun->[OBJ])) while @expired;
    }
}

package Ids;
# Allocate and free unique numbers

sub new {
    my $ids = bless {}, shift;
    $ids->id_init;
    return $ids;
}

sub id_init {
    my ($ids) = @_;

    $ids->{free_ids} = [];
    $ids->{free_id}  = 0;
}

sub id_alloc {
    my ($ids) = @_;

    return shift @{$ids->{free_ids}} || ++$ids->{free_id};
}

sub id_free {
    my ($ids, $id) = @_;

    push @{$ids->{free_ids}}, $id;
    # Decrease free_ids some if we are lucky
    while (@{$ids->{free_ids}}) {
        if ($ids->{free_ids}[-1] == $ids->{free_id}) {
            --$ids->{free_id};
            pop @{$ids->{free_ids}};
        } elsif ($ids->{free_ids}[0] == $ids->{free_id}) {
            --$ids->{free_id};
            shift @{$ids->{free_ids}};
        } else {
            last;
        }
    }
}

package Pinger;
use Scalar::Util qw(weaken refaddr);
use Errno qw(EINTR EAGAIN EWOULDBLOCK);
use Socket qw(inet_aton);
use POSIX qw(_exit);

{
    my @queued;
    sub queue {
        my ($class, $icmp) = @_;

        die "Assertion: Already pending" if $icmp->{pending};
        weaken($queued[@queued] = $icmp);
        $icmp->{pending} = 1;
    }

    sub activate_ping {
        while (@queued && $ping_max > 0) {
            my $icmp = shift @queued || next;
            $icmp->unqueue_ping();
        }
    }
}

sub new {
    my ($class, $host, $data, $icmp) = @_;

    $ping_max > 0 || die "Assertion: Ping max $ping_max > 0";

    pipe(my $rd0, my $wr0) || die "Could not open pipe: $^E";
    pipe(my $rd1, my $wr1) || die "Could not open pipe: $^E";

    defined(my $pid = fork()) || die "Could not fork: $^E";
    if ($pid == 0) {
        # Child
        select($wr1);
        $| = 1;
        eval {
            close($rd0) || die "Could not close pipe: $^E";
            close($rd1) || die "Could not close pipe: $^E";
            open(STDIN,  "<&", $null) || die "Could not dup to STDIN: $^E";
            open(STDOUT, ">&", $wr0)  || die "Could not dup to STDOUT: $^E";
            close($wr0) || die "Could not close pipe: $^E";
            # open(STDERR, ">&STDOUT")  || die "Could not dup to STDERR: $^E";
            $SIG{CHLD} = "DEFAULT";
            no warnings "exec";
            exec(@{$PING[0]}, $host, @{$PING[1]}) ||
                die "Could not exec $PING[0][0]: $^E";
        };
        print $@ || "Assertion: Pinger ended without error\n";
        _exit(1);
    }
    # Parent
    close($wr0) || die "Could not close pipe: $^E";
    close($wr1) || die "Could not close pipe: $^E";
    $rd0->blocking(0);
    $rd1->blocking(0);
    my $pinger = bless {
        handle	=> $rd0,
        exec_fh	=> $rd1,
        pid	=> $pid,
        parent	=> $$,
        in	=> "",
        host	=> $host,
        data	=> $data,
        reader	=> undef,
    }, $class;

    $pinger->{id} = refaddr($pinger);
    weaken($pinger->{icmp} = $icmp);
    $pinger->{reader} = $rd1->add_read($pinger, \&exec_reader);

    ::info("Start ping '$pinger->{host}' (ID $pinger->{id})") if $debug;

    return $pinger;
}

sub wait : method {
    return if defined $SIG{CHLD} && $SIG{CHLD} eq "IGNORE";
    my ($pinger) = @_;

    my $pid = $pinger->{pid};
    return if $pinger->{parent} != $$ || !$pid;
    $pinger->{pid} = undef;
    my $p = waitpid($pid, 0);
    if ($p != $pid) {
        die "Could not wait for pid '$pid'" if $p < 0;
        die "Assertion: Invalid pid result" if $p != $pid;
    }
    die "Unexpected exitcode $? from ping $pinger->{host} (pid $pid)" if $?;
}

sub exec_reader {
    my ($pinger) = @_;

    my $rc = $pinger->{exec_fh}->sysread(my $buffer, $BLOCK_SIZE);
    if (!defined $rc) {
        # Error
        return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK;
        $pinger->{reader} = undef;
        die "Assertion: Could not read from pinger[$pinger->{pid}] exec handle: $^E";
    }
    if ($rc) {
        $pinger->{in} .= $buffer;
        return;
    }

    # EOF
    $pinger->{reader} = undef;
    close($pinger->{exec_fh}) || die "Could not close exec ping handle: $^E";
    if ($pinger->{in} ne "") {
        close($pinger->{handle}) || die "Could not close ping handle: $^E";
        $pinger->wait;
        die $pinger->{in};
    }
    $pinger->{reader} = $pinger->{handle}->add_read($pinger, \&reader);
}

sub reader {
    my ($pinger) = @_;

    my $rc = $pinger->{handle}->sysread(my $buffer, $BLOCK_SIZE);
    if (!defined $rc) {
        # Error
        return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK;
        $pinger->{reader} = undef;
        die "Could not read from pinger[$pinger->{pid}]: $^E";
    }
    if ($rc) {
        $pinger->{in} .= $buffer;
        return;
    }

    # EOF
    $pinger->{reader} = undef;
    close($pinger->{handle});
    $pinger->wait;
    my $icmp = $pinger->{icmp};
    if (my ($ip, $ttl, $time) = $pinger->{in} =~ /from (\d+\.\d+\.\d\.\d+).* icmp_[sr]eq.* ttl=(\d+).* time=(\S+ (?:ms|usec))/) {
        ::info("Got ping response from '$ip' ttl=$ttl, time=$time (ID $pinger->{id})") if $debug;
        $ip eq $pinger->{host} ||
            die "Asertion: Inconsistent: pinged '$pinger->{host}', got aswer from '$ip'";
        $icmp->{line}->write($RESPONSE_PING, pack("wa4C", $icmp->{id}, inet_aton($pinger->{host}), $ttl-1), $pinger->{data}) if $ttl > 1;
    } else {
        ::info("Got no ping response from '$pinger->{host}' (ID $pinger->{id})") if $debug;
    }
    $icmp->unget($pinger);
}

package Sender::ICMP;
use Scalar::Util qw(weaken);
use Socket qw(pack_sockaddr_in unpack_sockaddr_in inet_ntoa
              MSG_TRUNC MSG_CTRUNC);
use Errno qw(EINTR EAGAIN EWOULDBLOCK EMSGSIZE);

sub new {
    my ($class, $line, $id) = @_;

    die "Already have Sender::ICMP socket '$id'" if $line->{sockets_icmp}{$id};

    # Notice this can return nothing if we can't open an UDP icmp socket
    # (either not supported on OS or user not in allowed grooup)
    my ($host, $icmp_id, $socket) = $line->socket_icmp("0.0.0.0", 0);
    !$msghdr || !$socket || setsockopt($socket, $IPPROTO_IP, $IP_RECVTTL, 1) ||
        die "setsockopt(IPPROTO_IP, IP_RECVTTL): $^E";
    # ICMP_FILTER always gets me ENOPROTOOPT
    # However when /bin/ping does it (when sysctl group NOT set) it works...
    # !$socket || setsockopt($socket, $SOL_RAW, $ICMP_FILTER, 0xffffffff ^ 1<<$ICMP_ECHO_REPLY) ||
    #    die "setsockopt(SOL_RAW, ICMP_FILTER): $^E" if defined $ICMP_FILTER;

    my $icmp = bless {
        id		=> $id,
        pid		=> $$,
        out		=> [],
        socket		=> $socket,
        local_host	=> $host,
        icmp_id		=> $icmp_id,
        reader		=> undef,
        writer		=> undef,
        timeout		=> undef,
        pingers		=> {},
        pending		=> 0,
    }, $class;
    $icmp->{reader} = $socket->add_read($icmp, \&reader) if $socket;
    weaken($icmp->{line} = $line);
    $line->{sockets_icmp}{$id} = $icmp;

    if ($debug) {
        if ($socket) {
            ::info("Creating new Sender::ICMP socket[$id] '$host:$icmp_id'");
        } else {
            ::info("Creating new Sender::ICMP socket[$id] (using external ping)");
        }
    }

    return $icmp;
}

sub write : method {
    # @_ = ($icmp, $dst, $seqno, $data, $ttl)
    my $icmp = shift;

    if (!$icmp->{socket}) {
        push @{$icmp->{out}}, [shift, shift, shift];
        $icmp->activate_ping;
        return;
    }
    my $data = {
        name	=> pack_sockaddr_in(0, shift),
        # $icmp->{icmp_id} doesn't need to be set here. Whatever you use
        # will get ignored and the socket bind properties are used
        buf	=> pack("Cx3n2a*x", $ICMP_ECHO_REQUEST, $icmp->{icmp_id}, shift, shift)
    };
    my $sum = unpack("%32n*", $data->{buf});
    chop $data->{buf};
    while ($sum > 0xffff) {
        my $carry = $sum >> 16;
        $sum &= 0xffff;
        $sum += $carry;
    }
    substr($data->{buf}, 2, 2, pack("n", 0xffff - $sum));

    if ($msghdr) {
        $data->{flags} = 0;
        $data->{control} = ::pack_cmsghdr(
                $IPPROTO_IP,
                $IP_TTL,
                pack("I", shift || die "Assertion: TTL 0"));
        bless $data, "Socket::MsgHdr";
    } else {
        $data->{ttl} = shift || die "Assertion: TTL 0"
    }
    if (1 == push @{$icmp->{out}}, $data) {
        $icmp->{writer} = $icmp->{socket}->add_write($icmp, \&writer);
        $icmp->{timeout} = Timer::timer($icmp->{line}{settings}{TIMEOUT},
                                        $icmp, \&timeout);
    }
}

sub timeout {
    my ($icmp) = @_;

    die "Timeout. Could not ICMP send[$icmp->{id}]";
}

sub writer {
    my ($icmp) = @_;

    my $data = $icmp->{out}[0];
    my $rc;
    if ($msghdr) {
        $rc = ::sendmsg($icmp->{socket}, $data);
    } else {
        $rc = send($icmp->{socket}, $data->{buf}, 0, $data->{name});
    }
    if (!defined $rc) {
        return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK;
        if ($! == EMSGSIZE) {
            ::info("Cannot send oversized ICMP packet. Dropped") if $debug;
            goto DROP;
        }
        die "Could not write to sender ICMP socket: $^E";
    }
    if ($debug) {
        my ($port, $addr) = unpack_sockaddr_in($data->{name});
        my $host = inet_ntoa($addr);

        my ($type, $code, $icmp_id, $seqno) = unpack("wwx2n2", $data->{buf});

        if ($rc >= $ICMP_HEADER) {
            ::info("Wrote %d ICMP bytes [Type %d, Code %d, Id %d, Seqno %d] to %s (%d left): %s",
                   $rc-$ICMP_HEADER, $type, $code, $icmp_id, $seqno, $host,
                   length($data->{buf}) - $rc,
                   ::display(substr($data->{buf}, $ICMP_HEADER, $rc-$ICMP_HEADER)));
        } else {
            ::info("Wrote %d ICMP bytes (including header) [Type %d, Code %d, Id %d, Seqno %d] to %s (%d left): %s",
                   $rc, $type, $code, $icmp_id, $seqno, $host,
                   length($data->{buf}) - $rc,
                   ::display(substr($data->{buf}, 0, $rc)));
        }
    }
    $rc == length($data->{buf}) || die "Assertion: Incomplete ICMP write ($rc of " . length($data->{buf}) . ")";

  DROP:
    shift @{$icmp->{out}};
    if (@{$icmp->{out}}) {
        $icmp->{timeout} = Timer::timer($icmp->{line}{settings}{TIMEOUT},
                                          $icmp, \&timeout);
    } else {
        $icmp->{writer}  = undef;
        $icmp->{timeout} = undef;
    }
}

sub reader {
    my ($icmp) = @_;

    my ($sockaddr, $buffer, $ttl);
    if ($msghdr) {
        $msghdr->{name} = "\0" x 256;
        $msghdr->{buf}  = "\0" x $UDP_SIZE;
        $msghdr->{control} = "\0" x 256;
        $msghdr->{flags} = 0;
        if (defined ::recvmsg($icmp->{socket}, $msghdr)) {
            # I suspect Socket::MsgHdr has a bug so that flags is never set
            die "Yikes! Buffer was truncated\n" if
                $msghdr->flags & MSG_TRUNC;
            die "Yikes! Ancillary data was truncated\n" if
                $msghdr->flags & MSG_CTRUNC;
            $buffer = $msghdr->{buf};
            $sockaddr = $msghdr->{name};
            my ($level, $type, $data) = ::unpack_cmsghdr($msghdr->{control}) or
                die "No ancillary data from socket";
            $level == $IPPROTO_IP ||
                die "Unexpected level in ancillary data from socket";
            $type == $IP_TTL ||
                die "Unexpected type in ancillary data from socket";
            $ttl = unpack("I", $data);
        }
    } else {
        $sockaddr = recv($icmp->{socket}, $buffer, $UDP_SIZE, 0);
        $ttl = $TTL;
    }
    if (!defined $sockaddr) {
        return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK;
        die "Could not read from sending ICMP socket: $^E";
    }

    # 16 bytes MD5, 4 bytes rand, 4 bytes src, 2 bytes id, 2 bytes seqno
    # and at least 1 fou_id byte
    length $buffer >= $ICMP_HEADER + (16+4+4+2+2+1) || return;
    $buffer .= "\0";
    my $sum = unpack("%32n*", $buffer);
    my ($type, $code, $icmp_chksum, $icmp_id, $seqno) =
        unpack("wwn3", substr($buffer, 0, $ICMP_HEADER, ""));
    chop $buffer;
    if (1 || $icmp_chksum) {
        while ($sum > 0xffff) {
            my $carry = $sum >> 16;
            $sum &= 0xffff;
            $sum += $carry;
        }
        $sum == 0xffff || return;
    }
    $type == $ICMP_ECHO_REPLY || return;
    $code == 0 || return;

    my ($port, $addr) = unpack_sockaddr_in($sockaddr);
    if ($debug) {
        my $host = inet_ntoa($addr);
        ::info("Received %d bytes (%sType %d, Code %d, Id %d, Seqno %d) from %s on sender ICMP socket[%d]: %s",
               length($buffer), $msghdr ? "TTL $ttl, " : "", $type, $code,
               $icmp_id, $seqno,
               $host, $icmp->{id}, ::display($buffer));
    }
    $icmp->{line}->write($RESPONSE_PING, pack("wa4C", $icmp->{id}, $addr, $ttl-1), $buffer) if $ttl > 1;
}

sub activate_ping {
    my ($icmp) = @_;

    @{$icmp->{out}} || return;
    return if $icmp->{pending};

    if ($ping_max <= 0) {
        Pinger->queue($icmp);
        return;
    }

    my $line = $icmp->{line};
    if ($line->{nr_pingers} >= $line->{settings}{PING_MAX}) {
        $line->queue_ping($icmp);
        return;
    }

    my $pinger = Pinger->new(inet_ntoa($icmp->{out}[0][0]),
                             shift(@{$icmp->{out}})->[2], $icmp);
    $icmp->{pingers}{$pinger->{id}} = $pinger;
    ++$line->{nr_pingers};
    --$ping_max;
}

sub unget {
    my ($icmp, $pinger) = @_;

    delete $icmp->{pingers}{$pinger->{id}};
    if (my $line = $icmp->{line}) {
        --$line->{nr_pingers};
        $line->activate_ping;
    }
    ++$ping_max;
    Pinger->activate_ping;
}

sub unqueue_ping {
    my ($icmp) = @_;

    $icmp->{pending} || die "Assertion: Not pending";
    $icmp->{pending} = 0;
    $icmp->activate_ping;
}

sub DESTROY {
    my ($icmp) = @_;

    # Avoid new pings being started during cleanup in children
    $icmp->{pid} == $$ || return;

    # Avoid recursive calls to activate from starting stuff again
    # This only stops recursion into ourselves. Other Sender::ICMP can still be
    # activated, so this is not perfect during LineProtocol object destruction.
    # Except that we currently do only one Sender::ICMP object per LineProtocol.
    @{$icmp->{out}} = ();
    $icmp->unget($_) for values %{$icmp->{pingers}};
}

package Sender::UDP;
# Send out packets at the remote side (and wait for replies)
use Scalar::Util qw(weaken);
use Socket qw(pack_sockaddr_in unpack_sockaddr_in inet_ntoa
              MSG_TRUNC MSG_CTRUNC);
use Errno qw(EINTR EAGAIN EWOULDBLOCK EMSGSIZE);

sub new {
    my ($class, $line, $id) = @_;

    die "Already have Sender::UDP socket '$id'" if $line->{sockets_udp}{$id};

    my ($host, $port, $socket) = $line->socket_udp("0.0.0.0", 0);
    !$msghdr || setsockopt($socket, $IPPROTO_IP, $IP_RECVTTL, 1) ||
        die "setsockopt(IPPROTO_IP, IP_RECVTTL): $^E";

    my $sender = bless {
        id		=> $id,
        out		=> [],
        socket		=> $socket,
        local_host	=> $host,
        local_port	=> $port,
        reader		=> undef,
        writer		=> undef,
        timeout		=> undef,
    }, $class;
    $sender->{reader} = $socket->add_read($sender, \&reader);
    weaken($sender->{line} = $line);
    $line->{sockets_udp}{$id} = $sender;

    ::info("Creating new Sender::UDP socket[$id] '$host:$port'") if $debug;

    return $sender;
}

sub timeout {
    my ($sender) = @_;

    die "Timeout. Could not UDP send[$sender->{id}]";
}

sub write : method {
    my $sender = shift;
    if (1 == push @{$sender->{out}}, $msghdr ?
        bless {
            name => pack_sockaddr_in(shift, shift),
            buf  => shift,
            control => ::pack_cmsghdr(
                $IPPROTO_IP,
                $IP_TTL,
                pack("I", shift || die "Assertion: TTL 0")),
            flags => 0,
        }, "Socket::MsgHdr" :
        [pack_sockaddr_in(shift, shift), shift]) {
        $sender->{writer} = $sender->{socket}->add_write($sender, \&writer);
        $sender->{timeout} = Timer::timer($sender->{line}{settings}{TIMEOUT},
                                          $sender, \&timeout);
    }
}

sub writer {
    my ($sender) = @_;

    my $data = $sender->{out}[0];
    if ($msghdr) {
        my $rc = ::sendmsg($sender->{socket}, $data);
        if (!defined $rc) {
            return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK;
            if ($! == EMSGSIZE) {
                ::info("Cannot send oversized UDP packet. Dropped") if $debug;
                goto DROP;
            }
            die "Could not write to sender UDP socket: $^E";
        }
        if ($debug) {
            my ($port, $addr) = unpack_sockaddr_in($data->{name});
            my $host = inet_ntoa($addr);
            ::info("Wrote %d bytes to %s:%d (%d left): %s",
                   $rc, $host, $port, length($data->{buf}) - $rc, ::display(substr($data->{buf}, 0, $rc)));
        }
        $rc == length($data->{buf}) || die "Assertion: Incomplete UDP write ($rc of " . length($data->{buf}) . ")";
    } else {
        my $rc = send($sender->{socket}, $data->[1], 0, $data->[0]);
        if (!defined $rc) {
            return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK;
            if ($! == EMSGSIZE) {
                ::info("Cannot send oversized UDP packet. Dropped") if $debug;
                goto DROP;
            }
            die "Could not write to sender UDP socket: $^E";
        }
        if ($debug) {
            my ($port, $addr) = unpack_sockaddr_in($data->[0]);
            my $host = inet_ntoa($addr);
            ::info("Wrote %d bytes to %s:%d (%d left): %s",
                   $rc, $host, $port, length($data->[1]) - $rc, ::display(substr($data->[1], 0, $rc)));
        }
        $rc == length($data->[1]) || die "Assertion: Incomplete UDP write ($rc of " . length($data->[1]) . ")";
    }

  DROP:
    shift @{$sender->{out}};
    if (@{$sender->{out}}) {
        $sender->{timeout} = Timer::timer($sender->{line}{settings}{TIMEOUT},
                                          $sender, \&timeout);
    } else {
        $sender->{writer}  = undef;
        $sender->{timeout} = undef;
    }
}

sub reader {
    my ($sender) = @_;

    my ($sockaddr, $buffer, $ttl);
    if ($msghdr) {
        $msghdr->{name} = "\0" x 256;
        $msghdr->{buf}  = "\0" x $UDP_SIZE;
        $msghdr->{control} = "\0" x 256;
        $msghdr->{flags} = 0;
        if (defined ::recvmsg($sender->{socket}, $msghdr)) {
            # I suspect Socket::MsgHdr has a bug so that flags is never set
            die "Yikes! Buffer was truncated\n" if
                $msghdr->flags & MSG_TRUNC;
            die "Yikes! Ancillary data was truncated\n" if
                $msghdr->flags & MSG_CTRUNC;
            $buffer = $msghdr->{buf};
            $sockaddr = $msghdr->{name};
            my ($level, $type, $data) = ::unpack_cmsghdr($msghdr->{control}) or
                die "No ancillary data from socket";
            $level == $IPPROTO_IP ||
                die "Unexpected level in ancillary data from socket";
            $type == $IP_TTL ||
                die "Unexpected type in ancillary data from socket";
            $ttl = unpack("I", $data);
        }
    } else {
        $sockaddr = recv($sender->{socket}, $buffer, $UDP_SIZE, 0);
        $ttl = $TTL;
    }
    if (!defined $sockaddr) {
        return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK;
        die "Could not read from sending UDP socket: $^E";
    }
    # No special handling for length 0.
    # It's perfectly fine to send and receve empty UDP packets
    my ($port, $addr) = unpack_sockaddr_in($sockaddr);
    if ($debug) {
        my $host = inet_ntoa($addr);
        ::info("Received %d bytes %sfrom %s:%d on sender UDP socket[%d]: %s",
               length($buffer), $msghdr ? "(TTL $ttl) " : "",
               $host, $port, $sender->{id}, ::display($buffer));
    }
    $sender->{line}->write($RESPONSE_UDP, pack("wa4nC", $sender->{id}, $addr, $port, $ttl-1), $buffer) if $ttl > 1;
}

package Listener::UDP;
# Wait for packets at the local (client) side
use Errno qw(EINTR EAGAIN EWOULDBLOCK);
use Socket qw(inet_ntoa pack_sockaddr_in
              MSG_TRUNC MSG_CTRUNC);
use Scalar::Util qw(weaken);
use Digest::MD5 qw(md5);

sub new {
    my ($class, $line, $host, $port, $fou) = @_;

    my ($h, $p, $socket) = $line->socket_udp($host, $port);

    my $listener = bless {
        fou_id		=> $fou->id,
        socket		=> $socket,
        local_host	=> $h,
        local_port	=> $p,
        reader		=> undef,
    }, $class;
    $listener->{reader} = $socket->add_read($listener, \&reader);
    weaken($listener->{line} = $line);

    ::info("Listening on UDP socket '$h:$p'") if $debug;


    my $id = $line->id_alloc;
    $listener->{id} = $id;
    $line->{listeners}{$id} = $listener;
    return $listener;
}

sub id {
    return shift->{id};
}

sub reader {
    my ($listener) = @_;

    my $rc = $listener->{socket}->sysread(my $buffer, $UDP_SIZE);
    if (!defined $rc) {
        return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK;
        die "Could not read from listening $role UDP socket: $^E";
    }
    # No special handling for length 0.
    # It's perfectly fine to send and receve empty UDP packets
    my $debug_str = $debug && sprintf("Received %d bytes on listening UDP socket: %s", $rc, ::display($buffer));
    if (length $buffer < 20) {
        ::info($debug_str) if $debug_str;
        return;
    }
    my ($ihl, $ecn, $length, $id, $fragment, $ttl, $proto, $chksum, $nsrc, $ndst) = unpack("CCnnnCCna4a4", $buffer);
    if (0) {
        printf(STDERR "TEMP: IHL=%d, ECN=%d, LEN=%d, ID=%d, FRAGMENT=%#04X, TTL=%d, PROTO=%d, CHK=%#04X, SRC=%s, DST=%s\n",
               $ihl, $ecn, $length, $id, $fragment, $ttl, $proto, $chksum,
               inet_ntoa($nsrc), inet_ntoa($ndst));
    }

    # Don't handle spammy multicast stuff
    return if $MULTICAST_BEGIN le $ndst && $ndst lt $MULTICAST_END;
    ::info($debug_str) if $debug_str;

    my $version = $ihl >> 4;
    $ihl &= 0xf;
    my $flags = $fragment >> 13;
    $fragment &= 0x1fff;
    # only TCP4
    $version == $IP_VERSION || return;
    # Sanity check on buffer
    length($buffer) == $length || return;
    # We don't handle IP options (yet)
    $ihl == $IHL || return;
    # Too many hops
    $ttl > 1 || return;
    # Don't handle fragments (fragment offset)
    return if $fragment;
    # Don't handle fragments (MF flag set)
    return if $flags & 0x1;

    $ihl *= 4;
    my $header = substr($buffer, 0, $ihl, "");
    $length -= $ihl;

    # No buffer padding needed since length($header) is even
    my $sum = unpack("%32n*", $header);
    while ($sum > 0xffff) {
        my $carry = $sum >> 16;
        $sum &= 0xffff;
        $sum += $carry;
    }
    $sum == 0xffff || return;

    my $src = inet_ntoa($nsrc);
    my $dst = inet_ntoa($ndst);

    # print "Sender $peer:$peer_port, Receiver $local [$msg_dst]\n";

    my $dscp = $ecn >> 3;
    $ecn &= 0x7;
    # print "HEADER: DSCP=$dscp, ECN=$ecn, ID=$id, FLAGS=$flags, FRAGMENT=$fragment, TTL=$ttl, CHKSUM=$chksum, SRC=$src, DST=$dst\n";

    if ($proto == $PROTO_UDP) {
        # Only UDP

        # Must have space for UDP header
        return if $length < $UDP_HEADER;

        my $pseudo10 = pack("a4a4xC", $nsrc, $ndst, $proto);
        # Pad buffer with \0 so a last single byte still gets processed as "n"
        $sum = unpack("%32n*", $buffer . "\x0") + unpack("%32n*", $pseudo10) + $length;
        my ($sprt, $dprt, $udp_len, $udp_chksum) = unpack("nnnn", substr($buffer, 0, $UDP_HEADER, ""));
        $udp_len == $length || die "Inconsistent UDP length (inner UDP payload length: $udp_len, Inner IP packet length - inner UDP header length $ihl = $length)";
        $length -= $UDP_HEADER;

        if ($udp_chksum) {
            while ($sum > 0xffff) {
                my $carry = $sum >> 16;
                $sum &= 0xffff;
                $sum += $carry;
            }
            $sum == 0xffff || return;
        }

        ::info("FOU decoded %d UDP bytes (TTL %d) on $role UDP socket(%s:%d -> %s:%d): %s",
               length($buffer), $ttl, $src, $sprt, $dst, $dprt,
               ::display($buffer)) if $debug;

        my $line = $listener->{line};
        # On the remote side we will be able to distinguish packets coming back
        # from ($dst, $dport) so we can share a single Sender::UDP for a given
        # ($src,$port)
        my $map_src = $line->{map_udp}{"$dst:$dprt"} ||= [
            0,                 # Next seq counter
            {
            },                 # Map "src:port" to map
            [undef],           # Map id to map (the undef makes id start at 1)
            # $ndst,	# Packed destination address
            # $dprt,	# Destination Port
        ];
        my $fou_id = $listener->{fou_id};
        my $key = "$src:$sprt:$fou_id";
        my $map = $map_src->[1]{$key} ||= {
            key		=> $key,
            port	=> $sprt,
            host	=> $src,
            addr	=> $nsrc,
            fou_id	=> $fou_id,
        };
        $map->{seq} = $map_src->[0]++;
        # We should be able to handle many billions of packets before this overflows
        die "Too many packets to $dst:$dprt" if $map->{seq} == $map_src->[0];
        $id = $map->{id};
        if (!defined $id) {
            my $settings = $listener->{line}{settings};
            # A source we haven't saeen befre or we have forgotten
            if (values %{$map_src->[1]} > $settings->{UDP_MAX}) {
                my @old = sort {$a->{seq} <=> $b->{seq}} values %{$map_src->[1]};
                # Ignore the map we just added (it will have the highest packet number)
                pop @old;
                for my $old (@old) {
                    # Try to allocate the socket. If we can that means the
                    # ($src,$port) combination is not in local use anymore and we
                    # can completely drop it
                    # Notice if we receive FOU packets from a remote host we also
                    # won't be able to bind(), so this works out OK. There is a
                    # problem if we share IP addresses with the sender of the FOU
                    # packets though. So we probably need an option to turn this
                    # off and have another strategy to free up entries
                    # (e.g. a timeout)
                    # print STDERR "Probe $old->{host}, $old->{port}\n";
                    if ($line->socket_udp($old->{host}, $old->{port}, 1)) {
                        ::info("Releasing map '$key' (socket not in use any more)") if $debug;
                        $id = $old->{id};
                        last;
                    }
                }
                defined $id || die "Assertion: no Free id's";
                # $id //= $old[0]{id} // die "Assertion: no Free id's";
                my $remove = $map_src->[2][$id];
                delete $map_src->[1]{$remove->{key}} == $remove ||
                    die "Assertion: Removing unexpected entry";
            } else {
                $id = @{$map_src->[2]};
            }
            $map->{id} = $id;
            $map_src->[2][$id] = $map;
        }
        # print STDERR ::Dumper($id, $line->{map_udp});
        $line->write($DATA_UDP, pack("wa4nC", $id, $ndst, $dprt, $ttl-1), $buffer);
    } elsif ($proto == $PROTO_ICMP) {
        # Must have ToS 0
        $dscp == 0 && $ecn == 0 || return;
        # Must have space for ICMP header
        return if $length < $ICMP_HEADER;

        # Pad buffer with \0 so a last single byte still gets processed as "n"
        $sum = unpack("%32n*", $buffer . "\x0");
        my ($type, $code, $icmp_chksum, $id, $seqno) =
            unpack("WWn3", substr($buffer, 0, $ICMP_HEADER, ""));
        $length -= $ICMP_HEADER;

        # For mow we only support ICMP ECHO REQUEST
        $code == 0 || return;
        my $extra = "";
        if ($type == $ICMP_ECHO_REQUEST) {
            # Resulting packet must fit
            $extra = pack("a16Na4nnw", $SECRET, rand int 2**32, $nsrc, $id, $seqno, $listener->{fou_id});
            return if $length + $ICMP_HEADER + $IHL * 4 + length($extra) >> 16;
        } else {
            return;
        }

        if (1 || $icmp_chksum) {
            while ($sum > 0xffff) {
                my $carry = $sum >> 16;
                $sum &= 0xffff;
                $sum += $carry;
            }
            $sum == 0xffff || return;
        }

        ::info("FOU decoded %d ICMP bytes (TTL %d) on $role UDP socket(%s -> %s): type %d, code %d, id %d, seqno %d, data=%s",
               length($buffer), $ttl, $src, $dst,
               $type, $code, $id, $seqno,
               ::display($buffer)) if $debug;

        my $line = $listener->{line};
        # We leak $src here. We could do some unique remote port mapping instead
        substr($buffer, 0, 0, $extra);
        substr($buffer, 0, 16, md5($buffer));
        my $remote_seqno = ++$line->{seqno_echo};
        $line->{seqno_echo} = $remote_seqno = 1 if $remote_seqno >> 16;
        $line->write($PING, pack("wa4nC", 1, $ndst, $remote_seqno, $ttl-1), $buffer);
    }
}

package Fou::UDP;
# Send out proxied packets at the local (client) side usinga FOU tunnel
use Errno qw(EINTR EAGAIN EWOULDBLOCK EMSGSIZE);
use Scalar::Util qw(weaken);
use Socket qw(inet_aton inet_ntoa pack_sockaddr_in);

my @FOU;
{
    my %fou;
    my $fou_ids = Ids->new;

    sub free {
        %fou = ();
        @FOU = ();
    }

    sub new {
        my ($class, $host, $port) = @_;

        my $addr = inet_aton($host) || die "Could not resolve '$host'";
        $host = inet_ntoa($addr);
        $port = $port =~ /^0\z|^[1-9][0-9]*\z/ ? int($port) :
            getservbyname($port, "udp") || die "Unknown UDP service '$port'";
        return $fou{"$host:$port"} if exists $fou{"$host:$port"};
        my $to = pack_sockaddr_in($port, $addr);

        # For now listen on any with a random port. Make this an option
        my ($h, $p, $socket) = LineProtocol->socket_udp("0.0.0.0", 0);

        my $id = $fou_ids->id_alloc;
        my $fou = bless {
            id		=> $id,
            out		=> [],
            socket	=> $socket,
            host	=> $host,
            port	=> $port,
            to		=> $to,
            host_local	=> $h,
            port_local	=> $p,
            writer	=> undef,
            timeout	=> undef,
        }, $class;
        $fou{"$h:$p"} = $FOU[$id] = $fou;

        return $fou;
    }
}

sub timeout {
    my ($fou) = @_;

    die "Timeout. Could not FOU send[$fou->{id}]";
}

sub id {
    return shift->{id};
}

sub write : method {
    my $fou = shift;

    if (1 == push @{$fou->{out}}, $msghdr ? bless {
        name => $fou->{to},
        buf  => shift,
        control => ::pack_cmsghdr(
            $IPPROTO_IP,
            $IP_TTL,
            pack("I", shift || die "Assertion: TTL 0")),
        flags => 0,
    }, "Socket::MsgHdr" : shift) {
        $fou->{writer} = $fou->{socket}->add_write($fou, \&writer);
        $fou->{timeout} = Timer::timer($settings_global{TIMEOUT},
                                       $fou, \&timeout);
    }
}

sub writer {
    my ($fou) = @_;

    my $rc = $msghdr ?
        ::sendmsg($fou->{socket}, $fou->{out}[0]) :
        send($fou->{socket}, $fou->{out}[0], 0, $fou->{to});
    if (!defined $rc) {
        return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK;
        if ($! == EMSGSIZE) {
            ::info("Cannot send oversized FOU packet. Dropped") if $debug;
            goto DROP;
        }
        die "Could not write to Fou UDP socket: $^E";
    }
    if ($msghdr) {
        ::info("Wrote %d bytes (TTL %d) to Fou UDP socket %s:%d (%d left): %s",
               $rc,
               unpack("I", (::unpack_cmsghdr($fou->{out}[0]->{control}))[2]),
               $fou->{host}, $fou->{port}, length($fou->{out}[0]{buf}) - $rc,
               ::display(substr($fou->{out}[0]{buf}, 0, $rc))) if $debug;
        $rc == length($fou->{out}[0]{buf}) ||
            die "Assertion: Incomplete UDP write ($rc of " . length($fou->{out}[0]{buf}) . ")";
    } else {
        ::info("Wrote %d bytes to Fou UDP socket %s:%d (%d left): %s",
               $rc, $fou->{host}, $fou->{port}, length($fou->{out}[0]) - $rc,
               ::display(substr($fou->{out}[0], 0, $rc))) if $debug;
        $rc == length($fou->{out}[0]) ||
            die "Assertion: Incomplete UDP write ($rc of " . length($fou->{out}[0]) . ")";
    }
  DROP:
    shift @{$fou->{out}};
    if (@{$fou->{out}}) {
        $fou->{timeout} = Timer::timer($settings_global{TIMEOUT},
                                       $fou, \&timeout);
    } else {
        $fou->{writer}  = undef;
        $fou->{timeout} = undef;
    }
}

package LineProtocol0;
use base qw(Ids);

my %lines;
{
    my $line_ids = Ids->new;

    sub _delete_all {
        %lines = ();
    }

    sub new {
        my ($class) = @_;

        my $line = bless {
            id			=> $line_ids->id_alloc,
            started		=> undef, # Normal operations started
            utime_offset	=> 0, # Estimated round trip time in microsecond
            keepalive		=> undef,
            timeout		=> undef,
            settings		=> { %settings_global },
            listeners		=> {},
            map_udp		=> {},
            seqno_echo		=> 0,
            sockets_udp		=> {},
            sockets_icmp	=> {},
        }, $class;
        $line->id_init;

        return $lines{$line->{id}} = $line;
    }

    sub DESTROY {
        $line_ids->id_free(shift->{id});
    }
}

package LineProtocol;
# Handle traffic between client and server
use Errno qw(EINTR EAGAIN EWOULDBLOCK EADDRINUSE EPROTONOSUPPORT EACCES);
use Carp;
use FindBin qw($Script);
use Socket qw(PF_INET SOCK_DGRAM SOCK_STREAM SOL_SOCKET SO_REUSEADDR
              inet_ntoa inet_aton pack_sockaddr_in unpack_sockaddr_in);
use Digest::MD5 qw(md5);

use constant {
    ACK_MASK	=> 0xffffffff,
};

use base qw(LineProtocol0);

my $BASE_TIME  = Timer->realtime();
my $BASE_CLOCK = Timer->clocktime();

my %process_name = (
    $SET		=> "SET",
    $START		=> "START",
    $KEEP		=> "KEEP",
    $UDP_REMOTE		=> "UDP_REMOTE",
    $DATA_UDP		=> "DATA_UDP",
    $PING		=> "PING",
    $RESPONSE_UDP	=> "RESPONSE_UDP",
    $RESPONSE_PING	=> "RESPONSE_PING",
);

my %process = %process_name;
$_ = __PACKAGE__->can("process_$_") || die "Unknown sub 'process_$_'" for
    values %process;

sub new {
    my ($class, $socket_in, $socket_out) = @_;

    binmode($socket_in);
    binmode($socket_out);

    $socket_in ->blocking(0);
    $socket_out->blocking(0);

    my $line = $class->SUPER::new();

    $line->{socket_in}  = $socket_in;
    $line->{socket_out} = $socket_out;
    $line->{in}  = "";
    $line->{unacked} = 0;
    $line->{in_acked} = 0;
    $line->{out} = "";
    $line->{out_sent} = 0;
    $line->{out_base} = 0;
    $line->{nr_pingers} = 0;
    $line->{queue_ping} = [];

    $line->{reader} = $socket_in->add_read($line, \&reader);

    return $line;
}

sub line_message {
    my $out   = \shift;
    my $command = shift;

    # One initial BER byte + proto = 2 bytes
    my $length = 2;
    $length += length for @_;
    ++$length if $length >= 128;
    ++$length if $length >= 128*128;
    # Don't accept more than 3 BER bytes (~ 2**21 byte message)
    croak "Message too long" if $length >= 128*128*128;

    $$out .= pack("wa", $length, $command);
    $$out .= $_ for @_;
    # ::info("Constructed %s: %s", $command, unpack("H*", substr($$out, -$length)));
    return $length;
}

sub writer {
    my ($line) = @_;

    while (1) {
        my $rc = $line->{socket_out}->syswrite($line->{out}, $BLOCK_SIZE, $line->{out_sent});
        if (!defined $rc) {
            if ($! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK) {
                $line->{timeout} ||= Timer::timer($line->{settings}{TIMEOUT},
                                                  $line, \&timeout);
                return;
            }
            $line->{writer} = undef;
            die "Could not write to $role_peer: $^E"
        }
        die "Zero write. Is this even possible ?" if $rc == 0;
        ::info("Wrote %d bytes to %s (%d left): %s",
             $rc, $role_peer, length($line->{out})-$line->{out_sent}-$rc,
               ::display(substr($line->{out}, $line->{out_sent}, $rc))) if $debug;

        $line->{timeout} = undef;
        $line->{out_sent} += $rc;
        if (length $line->{out} == $line->{out_sent}) {
            $line->{writer} = undef;
            $line->{keepalive} = Timer::timer($line->{settings}{KEEPALIVE},
                                              $line, \&keepalive);
            return;
        }
    }
}

sub keepalive {
    my ($line) = @_;

    ::info("Sending KEEPALIVE/ACK %d (new base %d)",
           $line->{unacked},
           $line->{in_acked} + $line->{unacked} & ACK_MASK) if $debug;
    die "Assertion: Unacked $line->{unacked} is out of range" if
        $line->{unacked} > 0xffffffff;
    my $msg = sprintf("%.0f\0%0.f\0%s",
                      (Timer->realtime() - $BASE_TIME)*1e6,
                      $line->{utime_offset}, pack("V", $line->{unacked}));
    $msg =~ s/\0+\z//;
    my $length = $line->write($KEEP, $msg);
    if ($length >= $line->{settings}{ACK_LIMIT}) {
        $line->{settings}{ACK_LIMIT} = ++$length;
        ::info("Increasing ACK_LIMIT to $length") if $verbose;
    }
    $line->{in_acked} = $line->{in_acked} + $line->{unacked} & ACK_MASK;
    $line->{unacked} = 0;
}

sub timeout {
    die "Timeout. Could not write to $role_peer";
}

sub write : method {
    my $line = shift;

    my $length = line_message($line->{out}, @_);
    if ($line->{out_sent} + $length == length $line->{out}) {
        $line->{keepalive} = undef;
        $line->{writer} = $line->{socket_out}->add_write($line, \&writer);
        $line->{timeout} = Timer::timer($line->{settings}{TIMEOUT},
                                        $line, \&timeout);
    }
    return $length;
}

sub reader {
    my ($line) = @_;

    my $rc = $line->{socket_in}->sysread($line->{in}, $BLOCK_SIZE, length($line->{in}));
    if (!defined $rc) {
        return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK;
        die "Could not read from $role_peer: $^E"
    }
    if ($rc == 0) {
        ::info("Line $line->{id}: Remote EOF. Closing") if $verbose || $debug;
        # This currently leaves ping forks running even though their sockets are
        # disconnected. So repeated connects with slow pings can do a processes
        # DOS attack
        delete $lines{$line->{id}};
        return;
    }
    ::info("Read %d bytes from $role_peer: %s", $rc, ::display(substr($line->{in}, -$rc))) if $debug;

    $line->{unacked} += $rc;
    $line->keepalive() if $line->{unacked} >= $line->{settings}{ACK_LIMIT};

    while ($line->{in} =~ /^([\x80-\xff]{0,2}[\x00-\x7f].)/s) {
        my ($length, $command) = unpack("wa", $line->{in});
        last if length($line->{in}) < $length;
        my $message = substr($line->{in}, 0, $length, "");
        substr($message, 0, length $1, "");
        ::info("Processing %s: '%s' (%d bytes)",
               $process_name{$command} || "Unknown command $command",
               ::display($message), length $message) if $debug;
        my $fun = $process{$command} ||
            die "No handler for proto '$command'";
        $fun->($line, $message, $command);
    }
}

sub queue_ping {
    my ($line, $icmp) = @_;

    die "Assertion: Already pending" if $icmp->{pending};
    weaken($line->{queue_ping}[@{$line->{queue_ping}}] = $icmp);
    $icmp->{pending} = 2;
}

sub activate_ping {
    my ($line) = @_;

    while (@{$line->{queue_ping}} && $line->{nr_pingers} < $line->{settings}{PING_MAX}) {
        my $icmp = shift @{$line->{queue_ping}} || next;
        $icmp->unqueue_ping();
    }
}

sub process_SET {
    my $line  = shift;

    my $i = unpack("C", substr($_[0], 0, 1, ""));
    my $name = $setting_ids[$i] || die "Unknown variable $i";
    # At the moment all values are numbers
    $line->{settings}{$name} = $_[0] =~ /^0\z|^[1-9][0-9]*\z/ ? $_[0]+0 : $_[0];
    ::info("Set %s=%s", $name, $_[0]) if $debug;
}

sub process_START {
    my $line  = shift;

    defined $line->{settings}{EPOCH} || die "Lost early epoch message";

    my $ready = "$Script $role $me\@$hostname ready (clock=$CLOCK_TYPE_NAME, pid=$$)";
    $line->{started} = 1;

    if ($role eq "server") {
        $line->write($START, $ready);
    }
    ::info($ready);
    print STDERR "\n";
}

sub process_KEEP {
    my $line  = shift;

    # Transit time is of course meaningless if the clocks aren't
    # synchronized very well. offset tries to compensate for that

    # add 5 \0 in case they were trimmed (1 for the last Z and 4 for V)
    my ($utime, $uoffset, $acked) = unpack("Z*Z*V", shift() . "\0" x 5);

    die "Assertion: Impossible ACK" if $acked > $line->{out_sent};
    substr($line->{out}, 0, $acked, "");
    $line->{out_sent} -= $acked;
    $line->{out_base} = $line->{out_base} + $acked & ACK_MASK;

    # uoffset has     peertime - mytime + transit_time (me -> peer)
    # This calculates mytime - peertime + transit_time (peer -> me)
    $line->{utime_offset} = (Timer->realtime() - $line->{settings}{EPOCH})*1e6 -$utime || 1;
    ::info("Received ACK=%d (base=%d, sent=%d), Keepalive transit=%.3f ms" .
           ($uoffset ? ", roundtrip=%.3f ms, offset=%.0f ms" : ""),
           $acked, $line->{out_base}, $line->{out_sent},
           $line->{utime_offset}/1e3,
           $uoffset ? (
               ($line->{utime_offset}+$uoffset)/1e3,
               ($line->{utime_offset}-$uoffset)/2e3) : ()) if $debug;
}

sub process_UDP_REMOTE {
    my ($line, $udp) = @_;

    my ($from_port, $separator, $to_port) =
        $udp =~ m{^([^%=]+)([%=])([^%=]+)\z} or
        die "Invalid udp_remote '$udp'";
    my $from_host = $from_port =~ s{(.*):}{}s ? $1 :
        $default_local_bind;
    $from_host = "0.0.0.0" if $from_host eq "" || $from_host eq "*";
    my $to_host   = $to_port   =~ s{(.*):}{}s ? $1 :
        $default_local_bind;

    my $l = $separator eq "%" ? $line : $lines{1};
    my $fou = Fou::UDP->new($to_host, $to_port);
    my $listener = Listener::UDP->new($l, $from_host, $from_port, $fou);
}

sub process_DATA_UDP {
    my $line = shift;
    my ($id, $dst, $port, $ttl, $data) = unpack("wa4nCa*", shift);
    $id || die "Assertion: Sender socket id $id == 0";
    $id <= $line->{settings}{UDP_MAX} ||
        die "Assertion: Sender socket id $id > $line->{settings}{UDP_MAX}";
    ::info("Need to send %d bytes of UDP data (TTL %d) from socket %d to %s:%d: %s",
           length($data), $ttl, $id, inet_ntoa($dst), $port, ::display($data)) if $debug;
    my $sender = $line->{sockets_udp}{$id} || Sender::UDP->new($line, $id);
    $sender->write($port, $dst, $data, $ttl);
}

sub process_RESPONSE_UDP {
    my $line = shift;

    my ($id, $nsrc, $sprt, $ttl, $data) = unpack("wa4nCa*", shift);
    $id || die "Assertion: Sender socket id $id == 0";
    $id <= $line->{settings}{UDP_MAX} ||
        die "Assertion: Sender socket id $id > $line->{settings}{UDP_MAX}";
    my $src = inet_ntoa($nsrc);
    ::info("\u$role_peer received %d bytes of UDP data on socket %d from %s:%d: %s",
           length($data), $id, $src, $sprt, ::display($data)) if $debug;
    my $map_src = $line->{map_udp}{"$src:$sprt"};
    if (!$map_src) {
        ::info("No map for $src:$sprt. Dropping packet");
        return;
    }
    my $map = $map_src->[2][$id] || die "Assertion: No Sender socket[$id]";
    $map->{seq} = $map_src->[0]++;
    die "Too many packets from $src:$sprt" if $map->{seq} == $map_src->[0];
    my $fou = $FOU[$map->{fou_id}] ||
        die "Assertion: No Fou::UDP with id '$map->{fou_id}'";
    my $ndst = $map->{addr};
    my $dprt = $map->{port};

    # Build FOU IP packet

    # Packet ID is meaningless for atomic packets (RFC 6864)
    my $packet_id = int rand 2**16;
    my $flags = $DF;

    my $length = length($data);
    my $new_length = $length + $IHL * 4 + $UDP_HEADER;
    # Currently we don't handle overly large FOU packets
    if ($new_length >= 2**16) {
        ::info("Cannot build oversized FOU packet. Dropped") if $debug;
        return;
    }

    my $header = pack("CCnnnCCx2a4a4",
                      $IP_VERSION << 4 | $IHL,
                      0,
                      $new_length,
                      $packet_id,
                      $DF << 13 | 0,
                      $ttl,
                      $PROTO_UDP,
                      $nsrc,
                      $ndst,
                  );
    my $sum = unpack("%32n*", $header);
    while ($sum > 0xffff) {
        my $carry = $sum >> 16;
        $sum &= 0xffff;
        $sum += $carry;
    }
    substr($header, 10, 2, pack("n", 0xffff - $sum));

    my $pseudo10 = pack("a4a4xC", $nsrc, $ndst, $PROTO_UDP);
    my $udp_header = pack("nnn", $sprt, $dprt, $length + $UDP_HEADER);
    # Temporarily add a 0 byte so we can do even padding
    $data .= "\0";

    $sum = unpack("%32n*", $pseudo10) + unpack("%32n*", $udp_header) + unpack("%32n*", $data) + $length + $UDP_HEADER;

    while ($sum > 0xffff) {
        my $carry = $sum >> 16;
        $sum &= 0xffff;
        $sum += $carry;
    }
    chop $data;
    my $buffer = $header . $udp_header . pack("n", 0xffff - $sum || 0xffff) . $data;

    if (0) {
        my $buf = $buffer;
        # For FOU packet construction debug
        my ($ihl, $ecn, $length, $packet_id, $fragment, $ttl, $proto, $chksum, $src, $dst) = unpack("CCnnnCCna4a4", $buf);
        my $version = $ihl >> 4;
        $ihl &= 0xf;
        my $flags = $fragment >> 13;
        $fragment &= 0x1fff;
        # only TCP4
        $version == $IP_VERSION || die "Wrong version $version";
        # Only UDP
        $proto == $PROTO_UDP || die "Wrong proto $proto";
        # Sanity check on buffer
        length($buf) == $length ||
            die "Wrong length ", length($buf);
        # We don't handle IP options (yet)
        $ihl == $IHL || die "Wrong ihl $ihl";
        # Too many hops
        $ttl || die "Bad TTL $ttl";
        # Don't handle fragments (fragment offset)
        die "Unexpected fragment $fragment" if $fragment;
        # Don't handle fragments (MF flag set)
        die "Bad flags $flags" if $flags & 0x1;

        my $pseudo10 = pack("a4a4xC", $src, $dst, $proto);

        $ihl *= 4;
        my $header = substr($buf, 0, $ihl, "");
        $length -= $ihl;

        # No buffer padding needed since length($header) is even
        my $sum = unpack("%32n*", $header);
        while ($sum > 0xffff) {
            my $carry = $sum >> 16;
            $sum &= 0xffff;
            $sum += $carry;
        }
        $sum == 0xffff || die "Bad IP checksum $sum";

        $src = inet_ntoa($src);
        $dst = inet_ntoa($dst);

        my $dscp = $ecn >> 3;
        $ecn &= 0x7;
        ::info("HEADER: DSCP=$dscp, ECN=$ecn, ID=$packet_id, FLAGS=$flags, FRAGMENT=$fragment, TTL=$ttl, CHKSUM=$chksum, SUM=$sum, SRC=$src, DST=$dst");

        # Must have space for UDP header
        die "Bad UDP length $length" if $length < $UDP_HEADER;

        # Pad buffer 0 so a last single byte still gets processed as "n"
        $sum = unpack("%32n*", $buf . "\x0") + unpack("%32n*", $pseudo10) + $length;
        my ($sprt, $dprt, $udp_len, $udp_chksum) = unpack("nnnn", substr($buf, 0, $UDP_HEADER, ""));
        $udp_len == $length || die "Inconsistent UDP length";
        $length -= $UDP_HEADER;

        if ($udp_chksum) {
            while ($sum > 0xffff) {
                my $carry = $sum >> 16;
                $sum &= 0xffff;
                $sum += $carry;
            }
            $sum == 0xffff || die "Bad UDP chksum $sum";
        }

        ::info("SPRT=$sprt, DPRT=$dprt, LEN=$udp_len, CHK=$udp_chksum");
    }
    ::info("Queue UDP packet (TTL %d) for FOU[%d]: %s:%d -> %s:%d",
           $ttl, $map->{fou_id}, $src, $sprt, $map->{host}, $map->{port}) if
               $debug;
    $fou->write($buffer, $ttl);
}

sub process_PING {
    my $line = shift;
    my ($id, $dst, $seqno, $ttl, $data) = unpack("wa4nCa*", shift);
    # Currently we only ever use one pinger
    $id == 1 || die "Assertion: Pinger socket id $id != 1";
    ::info("Need to send %d bytes of ICMP ECHO data (seqno %d, TTL %d) from socket %d to %s: %s",
           length($data), $seqno, $ttl, $id, inet_ntoa($dst), ::display($data))
        if $debug;
    my $pinger = $line->{sockets_icmp}{$id} || Sender::ICMP->new($line, $id);
    $pinger->write($dst, $seqno, $data, $ttl);
}

sub process_RESPONSE_PING {
    my $line = shift;

    my ($id, $nsrc, $ttl, $buffer) = unpack("wa4Ca*", shift);
    my $md5 = substr($buffer, 0, 16, $SECRET);
    md5($buffer) eq $md5 || return;
    my ($ndst, $icmp_id, $seqno, $fou_id, $data) =
        unpack("x20a4n2wa*", $buffer);
    my $fou = $FOU[$fou_id] || die "Assertion: No Fou::UDP with id '$fou_id'";

    # Build FOU IP packet
    my $ip_len = $IHL * 4;
    $buffer = pack("x${ip_len}CCx2nna*x", $ICMP_ECHO_REPLY, 0, $icmp_id, $seqno, $data);
    my $new_length = length($buffer)-1;
    substr($buffer, 0, $ip_len, "");
    my $sum = unpack("%32n*", $buffer);
    chop $buffer;
    while ($sum > 0xffff) {
        my $carry = $sum >> 16;
        $sum &= 0xffff;
        $sum += $carry;
    }
    substr($buffer, 2, 2, pack("n", 0xffff - $sum));

    # Packet ID is meaningless for atomic packets (RFC 6864)
    my $packet_id = int rand 2**16;
    my $header = pack("CCnnnCCx2a4a4",
                      $IP_VERSION << 4 | $IHL,
                      0,
                      $new_length,
                      $packet_id,
                      $DF << 13 | 0,
                      $ttl,
                      $PROTO_ICMP,
                      $nsrc,
                      $ndst,
                  );
    $sum = unpack("%32n*", $header);
    while ($sum > 0xffff) {
        my $carry = $sum >> 16;
        $sum &= 0xffff;
        $sum += $carry;
    }
    substr($header, 10, 2, pack("n", 0xffff - $sum));
    substr($buffer, 0, 0, $header);

    ::info("Queue ICMP packet (TTL %d) for FOU[%d]: %s -> %s",
           $ttl, $fou_id, inet_ntoa($nsrc), inet_ntoa($ndst)) if $debug;
    $fou->write($buffer, $ttl);
}

sub set_peer {
    my ($line, $name, $value) = @_;

    my $i = $setting_ids{$name};
    defined $i || croak "Unknown global variable '$name'";
    if (!defined $value) {
        defined($value = $line->{settings}{$name}) ||
            die "Assertion: Setting '$name' to undef";
    }
    $line->write($SET, pack("w", $i), $value);
}

sub socket_udp_connected {
    my ($class, $host, $port) = @_;

    $port = $port =~ /^0\z|^[1-9][0-9]*\z/ ? int($port) :
        getservbyname($port, "udp") || die "Unknown UDP service '$port'";
    my $addr = inet_aton($host) || die "Could not resolve '$host'";
    socket(my $socket, PF_INET, SOCK_DGRAM, $PROTO_UDP) ||
        die "Could not create UDP socket: $^E";
    my $remote = pack_sockaddr_in($port, $addr);
    connect($socket, $remote) || die "Could not connect socket: $^E";
    $socket->blocking(0);

    wantarray || return $socket;

    my $sockaddr = getpeername($socket) ||
        die "Assertion: Could not getpeername: $^E";
    my ($p, $address) = unpack_sockaddr_in($sockaddr);
    my $h = inet_ntoa($address);
    return $h, $p, $socket;
}

sub socket_udp {
    my ($class, $host, $port, $probe) = @_;

    $port = $port =~ /^0\z|^[1-9][0-9]*\z/ ? int($port) :
        getservbyname($port, "udp") || die "Unknown UDP service '$port'";
    my $addr = inet_aton($host) || die "Could not resolve '$host'";
    socket(my $socket, PF_INET, SOCK_DGRAM, $PROTO_UDP) ||
        die "Could not create UDP socket: $^E";
    my $local = pack_sockaddr_in($port, $addr);
    if ($probe) {
        return 1 if bind($socket, $local);
        $! == EADDRINUSE || die "Could not bind socket: $^E";
        return 0;
    }
    bind($socket, $local) || die "Could not bind socket: $^E";
    $socket->blocking(0);
    wantarray || return $socket;

    my $sockaddr = getsockname($socket) ||
        die "Assertion: Could not getsockname: $^E";
    my ($p, $address) = unpack_sockaddr_in($sockaddr);
    my $h = inet_ntoa($address);
    return $h, $p, $socket;
}

sub socket_tcp {
    my ($class, $host, $port, $listen) = @_;

    $port = $port =~ /^0\z|^[1-9][0-9]*\z/ ? int($port) :
        getservbyname($port, "tcp") || die "Unknown TCP service '$port'";
    $host = "0.0.0.0" if $host eq "";
    my $addr = inet_aton($host) || die "Could not resolve '$host'";
    socket(my $socket, PF_INET, SOCK_STREAM, $PROTO_TCP) ||
        die "Could not create TCP socket: $^E";
    my $local = pack_sockaddr_in($port, $addr);
    if ($listen) {
        setsockopt($socket, SOL_SOCKET, SO_REUSEADDR, 1) ||
            die "Assertion: Could not setsockopt(SOL_SOCKET, SO_REUSEADDR): $^E";
        bind($socket, $local) || die "Could not bind socket: $^E";
        listen($socket, $LISTEN_BACKLOG) || die "Could not listen: $^E";
    } else {
        connect($socket, $local) || die "Could not connect to $host:$port: $^E";
    }
    $socket->blocking(0);
    wantarray || return $socket;

    my $sockaddr = getsockname($socket) ||
        die "Assertion: Could not getsockname: $^E";
    my ($p, $address) = unpack_sockaddr_in($sockaddr);
    my $h = inet_ntoa($address);
    return $h, $p, $socket;
}

sub socket_icmp {
    my ($class, $host, $id) = @_;

    $host = "0.0.0.0" if !defined $host;
    $id = 0 if !defined $id;

    $id =~ /^0\z|^[1-9][0-9]*\z/  || die "Invalid id '$id'";
    my $addr = inet_aton($host) || die "Could not resolve '$host'";
    socket(my $socket, PF_INET, SOCK_DGRAM, $PROTO_ICMP) || do {
        return if $! == EPROTONOSUPPORT || $! == EACCES;
        die "Could not create ICMP socket: $^E";
    };
    my $local = pack_sockaddr_in($id, $addr);
    bind($socket, $local) || die "Could not bind socket: $^E";
    $socket->blocking(0);
    wantarray || return $socket;

    my $sockaddr = getsockname($socket) ||
        die "Assertion: Could not getsockname: $^E";
    my ($i, $address) = unpack_sockaddr_in($sockaddr);
    my $h = inet_ntoa($address);
    return $h, $i, $socket;
}

package Control;
use Scalar::Util qw(weaken);
use Socket qw(PF_UNIX SOCK_STREAM PF_UNSPEC);
use Errno qw(EINTR EAGAIN EWOULDBLOCK ECONNRESET);
use POSIX qw(_exit);

my %commands = (
    help	=> \&help,
    status	=> \&status,
);

{
    my %controls;
    my $ids = Ids->new;

    sub _delete_all {
        %controls = ();
    }

    sub new {
        my ($class, $line, $term_in, $term_out) = @_;

        $line || die "Assertion: No line";
        $term_in  = \*STDIN  if !defined $term_in;
        $term_out = \*STDOUT if !defined $term_out;
        # STDIN and/or STDOUT can be $null if the program was called with closed
        # STDIN and/or STDOUT
        die "Input is NULL" if fileno($term_in)  == fileno($null);
        die "Ouput is NULL" if fileno($term_out) == fileno($null);

        socketpair(my $left, my $right, PF_UNIX, SOCK_STREAM, PF_UNSPEC) ||
            die "Could not create socketpair: $^E";
        defined(my $pid = fork()) || die "Could not fork: $^E";
        if ($pid == 0) {
            # Child
            eval {
                close($left) || die "Could not close socketpair: $^E";
                $right->blocking(0);
                my $timeout = $line->{settings}{TIMEOUT};
                $line = undef;
                ::delete_all();
                $SIG{CHLD} = "DEFAULT";
                $term_in ->blocking(0) if fileno($term_in ) == fileno(STDIN );
                $term_out->blocking(0) if fileno($term_out) == fileno(STDOUT);
                Controller->run($term_in, $term_out, $right, $timeout);
            };
            select STDERR;
            $| = 1;
            print $@ || "Assertion: Control ended without error\n";
            _exit(1);
        }
        # Parent
        close($right) || die "Could not close socketpair: $^E";
        $left->blocking(0);
        # Caller will close STDIN
        fileno($term_in) == fileno(STDIN) ||
            close($term_in) || die "Could not close control input: $^E";
        # Caller is free to keep using STDOUT
        fileno($term_out) == fileno(STDOUT) ||
            close($term_out) || die "Could not close control output: $^E";
        my $id = $ids->id_alloc;
        my $control = $controls{$id} = bless {
            id		=> $id,
            line	=> $line,
            pid		=> $pid,
            parent	=> $$,
            socket	=> $left,
            in		=> "",
            out		=> "",
            reader	=> undef,
            writer	=> undef,
            timeout	=> undef,
        }, $class;
        weaken($control->{line});

        # Control does not keep the event loop alive
        $control->{reader} = $left->add_read0($control, \&reader);
        return $control;
    }

    sub reader {
        my ($control) = @_;

        my $rc = $control->{socket}->sysread(my $buffer, $BLOCK_SIZE);
        if (!defined $rc) {
            return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK;
            $! == ECONNRESET ||
                die "Could not read from control[$control->{id}]: $^E";
            $rc = 0;
        }
        if ($rc == 0) {
            # EOF
            ::info("Control EOF") if $debug;
            $control->wait;
            $ids->id_free($control->{id});
            delete $controls{$control->{id}};
            ::delete_all();
            return;
        }
        ::info("Received %d bytes from Controller[%d]: %s",
               length($buffer), $control->{id}, ::display($buffer)) if $debug;

        die "Cannot have Control input during output" if $control->{out} ne "";
        $control->{in} .= $buffer;
        my $len = ord $control->{in};
        next if $len < length $control->{in};
        die sprintf("Assertion: Overlong control message %d > %d", $len, length $control->{in}) if
            $len > length $control->{in};
        my @args = unpack("x(w/a*)*", $control->{in});
        ::info("Control %d: %s", $control->{id}, "@args") if $debug;
        $control->{in} = "";
        my $command = shift @args || die "Assertion: No command";
        my $fun = $commands{$command} ||
            die "Assertion: Unknown command '$command'";
        $control->{out} = "xxxx";
        $fun->($control, @args);
    }
}

sub flush : method {
    my ($control) = @_;

    "xxxx" eq substr($control->{out}, 0, 4, pack "N", length $control->{out}) ||
        die "Unexpected Control state";
    $control->{writer}  = $control->{socket}->add_write($control, \&writer);
    $control->{timeout} = Timer::timer($control->{line}{settings}{TIMEOUT}, $control, \&timeout);
}

sub timeout {
    my ($control) = @_;

    die "Timeout writing to Controller";
}

sub writer {
    my ($control) = @_;

    my $rc = $control->{socket}->syswrite($control->{out}, $BLOCK_SIZE);
    if (!defined $rc) {
        return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK;
        die "Could not write to Controller: $^E"
    }
    die "Zero write. Is this even possible ?" if $rc == 0;
    ::info("Wrote %d bytes to Controller[%d] (%d left): %s",
           $rc, $control->{id}, length($control->{out}) - $rc,
           ::display(substr($control->{out}, 0, $rc))) if $debug;

    substr($control->{out}, 0, $rc, "");
    if ($control->{out} eq "") {
        $control->{writer}  = undef;
        $control->{timeout} = undef;
        return;
    }
    $control->{timeout} = Timer::timer($control->{line}{settings}{TIMEOUT}, $control, \&timeout);
}

# We should be able to combine this with Pinger wait()
sub wait : method {
    return if defined $SIG{CHLD} && $SIG{CHLD} eq "IGNORE";
    my ($control) = @_;

    my $pid = $control->{pid};
    return if $control->{parent} != $$ || !$pid;
    $control->{pid} = undef;
    my $p = waitpid($pid, 0);
    if ($p != $pid) {
        die "Could not wait for pid '$pid'" if $p < 0;
        die "Assertion: Invalid pid result" if $p != $pid;
    }
    die "Unexpected exitcode $? from Control (pid $pid)" if $?;
}

sub help {
    my ($control) = @_;

    $control->{out} .= <<"EOF"
help	Show this help
status  Show connections status
EOF
        ;
    $control->flush;
}

sub status {
    my ($control) = @_;

    my $line = $control->{line};
    local $Data::Dumper::Varname = "VAR";
    my $settings = ::Dumper($line->{settings});
    $settings =~ s/\$VAR1 = //g || die "Assertion: No VAR1";
    $settings =~ s/\s+\z//;
    $settings =~ s/\n/\n    /g;
    $control->{out} .= <<"EOF"
Local:
  LineProtocol0[$line->{id}]
    Settings: $settings
EOF
        ;
    $control->flush;
}

package Controller;
use FindBin qw($Script);
use Errno qw(EINTR EAGAIN EWOULDBLOCK ECONNRESET);
use POSIX qw(_exit);

sub run {
    my ($class, $term_in, $term_out, $socket, $timeout) = @_;

    $debug = $verbose = 0;

    my $controller = bless {
        term		=> Term::ReadLine->new($Script, $term_in, $term_out) ||
        die("Could not create Term::ReadLine"),
        TIMEOUT		=> $timeout,
        term_in		=> $term_in,
        term_out	=> $term_out,
        in_term		=> "",
        out_term	=> "",
        reader_term	=> undef,
        socket		=> $socket,
        in		=> "",
        out		=> "",
        reader		=> undef,
    }, $class;
    if ($debug) {
        my $backend = $controller->{term}->ReadLine;
        my $backend_version = $backend->VERSION;
        $backend_version = "unknown" if !defined $backend_version;
        ::info("ReadLine backend: $backend $backend_version")
    }
    $controller->{term}->event_loop(\&Events::_mainloop);
    $controller->{reader_term} = $term_in->add_read($controller, \&Events::_unloop);
    $controller->{reader} = $socket->add_read0($controller, \&reader);

    # my $history_file = "$home/.history_$Script";
    # $controller->{term}->read_history($history_file);
    eval { $controller->_run };
    my $err = $@;
    # $controller->{term}->write_history($history_file);
    $controller->{term}->rl_deprep_terminal();
    if ($err) {
        _exit(0) if $err eq "\n";
        die $err;
    }
}

sub _run {
    my ($controller) = @_;

    my $prompt = "$Script>";
    # mainloop();
    while (1) {
        defined(my $line = $controller->{term}->readline($prompt)) || die "\n";
        # Paranoia
        utf8::downgrade($line);

        my ($command, @args) = split " ", $line or redo;
        redo if $command =~ m{^#|^//|^--};
        my $match = $commands{lc $command};
        if (!$match) {
            $controller->write_term("Unknown command '$command'\n");
            next;
        }
        $controller->{out} = pack("x(w/a*)*", lc $command, @args);
        if (length $controller->{out} > 0xff) {
            $controller->write_term("Command too long\n");
            next;
        }
        $controller->{writer} = $controller->{socket}->add_write($controller, \&writer);
        $controller->{timeout} = Timer::timer($controller->{TIMEOUT},
                                              $controller, \&timeout);
        substr($controller->{out}, 0, 1, pack("C", length $controller->{out}));
        # If the $controller->{timeout} assignment comes just before the
        # } continue { the value is somewhow kept alive
    } continue {
        $controller->{reader_term} = undef;
        Events::_mainloop();
        $controller->{reader_term} = $controller->{term_in}->add_read($controller, \&Events::_unloop);
    }
}

sub write_term {
    my $controller = shift;

    my $was_empty = $controller->{out_term} eq "";
    $controller->{out_term} .= join("", @_);
    if ($controller->{out_term} ne "" && $was_empty) {
        $controller->{writer_term} = $controller->{term_out}->add_write($controller, \&writer_term);
        $controller->{timeout_term} = Timer::timer($controller->{TIMEOUT},
                                                   $controller, \&timeout_term);
    }
}

sub writer_term {
    my ($controller) = @_;

    my $rc = $controller->{term_out}->syswrite($controller->{out_term}, $BLOCK_SIZE);
    if (!defined $rc) {
        return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK;
        die "Could not write to Terminal: $^E"
    }
    die "Zero write. Is this even possible ?" if $rc == 0;
    ::info("Wrote %d bytes to Terminal (%d left): %s",
           $rc, length($controller->{out_term}) - $rc,
           ::display(substr($controller->{out_term}, 0, $rc))) if $debug;

    substr($controller->{out_term}, 0, $rc, "");
    if ($controller->{out_term} eq "") {
        $controller->{writer_term}  = undef;
        $controller->{timeout_term} = undef;
        return;
    }
    $controller->{timeout_term} = Timer::timer($controller->{TIMEOUT},
                                               $controller, \&timeout_term);
}

sub reader {
    my ($controller) = @_;

    my $rc = $controller->{socket}->sysread(my $buffer, $BLOCK_SIZE);
    if (!defined $rc) {
        return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK;
        $! == ECONNRESET ||
            die "Could not read from control[$controller->{id}]: $^E";
        $rc = 0;
    }
    if ($rc == 0) {
        # EOF
        ::info("Controller EOF") if $debug;
        die "\n";
    }
    die "Cannot have Controller input during output" if $controller->{out} ne "";
    ::info("Received %d bytes from Control: %s",
           length($buffer), ::display($buffer)) if $debug;
    $controller->{in} .= $buffer;
    if (length $controller->{in} < 4) {
        $controller->{timeout} =
            Timer::timer($controller->{TIMEOUT}, $controller, \&timeout);
        return;
    }
    my $length = unpack("N", $controller->{in}) ||
        die "Assertion: Zero length not supported";
    if ($length < length $controller->{in}) {
        $controller->{timeout} =
            Timer::timer($controller->{TIMEOUT}, $controller, \&timeout);
        return;
    }
    $length == length $controller->{in} ||
        die sprintf("Assertion: Overlong Controller message %d > %d",
                    $length, length $controller->{in});
    substr($controller->{in}, 0, 4, "");
    $controller->write_term($controller->{in});

    $controller->{in} = "";
    $controller->{timeout} = undef;
    # Return to background reading
    $controller->{reader}  = undef;
    $controller->{reader}  =
        $controller->{socket}->add_read0($controller, \&reader);
}

sub writer {
    my ($controller) = @_;

    my $rc = $controller->{socket}->syswrite($controller->{out}, $BLOCK_SIZE);
    if (!defined $rc) {
        return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK;
        $! == ECONNRESET || die "Could not write to Control: $^E";
        $rc = 0;
    }
    die "Zero write. Is this even possible ?" if $rc == 0;
    ::info("Wrote %d bytes to Control (%d left): %s",
           $rc, length($controller->{out}) - $rc,
           ::display(substr($controller->{out}, 0, $rc))) if $debug;

    substr($controller->{out}, 0, $rc, "");
    if ($controller->{out} eq "") {
        $controller->{writer}  = undef;
        $controller->{timeout} = undef;
        # Now the answer from Control becomes mandatory
        # Maybe we should also have a timeout
        $controller->{reader} = undef;
        $controller->{reader} =
            $controller->{socket}->add_read($controller, \&reader);
        $controller->{timeout} =
            Timer::timer($controller->{TIMEOUT}, $controller, \&timeout);
        return;
    }
    $controller->{timeout} =
        Timer::timer($controller->{TIMEOUT}, $controller, \&timeout);
}

sub timeout_term {
    my ($controller) = @_;

    die "Timeout writing to Terminal";
}

sub timeout {
    my ($controller) = @_;

    die "Timeout communicating with Control";
}

package Listener;
use Socket qw(unpack_sockaddr_in inet_ntoa);
use Errno qw(EINTR EAGAIN EWOULDBLOCK);

{
    my %listeners;
    my $listen_ids = Ids->new;

    sub _delete_all {
        %listeners = ();
    }

    sub new {
        my ($class, $host, $port, $loops) = @_;

        $loops = -1 if !defined $loops;
        return if $loops == 0;
        my ($h, $p, $socket) = LineProtocol->socket_tcp($host, $port, 1);
        ::info("Listening on $h:$p") if $port eq "0";
        my $listen = bless {
            id => $listen_ids->id_alloc,
            socket => $socket,
        }, $class;
        $listen->{reader} = $socket->add_read($listen, \&acceptable);
        return $listeners{$listen->{id}} = $listen;
    }

    sub delete : method {
        delete $listeners{shift->{id}};
    }

    sub DESTROY {
        $listen_ids->id_free(shift->{id});
    }
}

sub acceptable {
    my ($listener) = @_;

    my $from = accept(my $accepted, $listener->{socket});
    if (!$from) {
        return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK;
        die "Accept failed: $^E";
    }
    $listener->delete if --$loops == 0;
    my $line = ::server($accepted, $accepted);
    if ($debug || $verbose) {
        my ($port, $addr) = unpack_sockaddr_in($from);
        my $host = inet_ntoa($addr);
        ::info("Accepted TCP connection from %s:%d. Starting Line %d (loops=%d)", $host, $port, $line->{id}, $loops);
    }
}

package main;
# use Scalar::Util qw(weaken);

sub _info {
    local ($!, $^E);
    my $role = ucfirst(shift);
    if (!@_) {
        my (undef, $filename, $line) = caller(1);
        @_ = ("$filename $line");
    }
    my $format = shift;
    $format =~ s/\n?\z/\n/;
    if (!@_) {
        @_ = ($format);
        $format = "%s";
    }
    my $time = Timer->realtime;
    my $itime = int($time);
    my ($sec, $min, $hour, $day, $mon, $year) = localtime($itime);
    my $gtime = timegm($sec, $min, $hour, $day, $mon, $year);
    my $offset = ($gtime - $itime) / 60;
    my $sign = "+";
    if ($offset < 0) {
        $sign = "-";
        $offset = -$offset;
    }
    my $hoffset = $offset / 60;
    my $moffset = $offset % 60;
    printf(STDERR "%04d-%02d-%02d %02d:%02d:%06.3f %s%02d%02d %s: $format",
           $year+1900, $mon+1, $day, $hour, $min, $time-$itime+$sec,
           $sign, $hoffset, $moffset,
           $role, @_);
}

sub info {
    _info($role, @_);
}

sub peer_info {
    _info($role_peer, @_);
}

sub callers {
    my (@lines, $line, $i);
    # Skip the entry for callers itself, so start $i at 1
    push @lines, $line while (undef, undef, $line) = caller(++$i);
    return join(" ", @lines);
}

sub caller_info {
    my $format = shift;
    if (@_) {
        info("$format [%s]", @_, callers());
    } else {
        my $callers = callers();
        $callers =~ s{%}{%%}g;
        info("$format [$callers]");
    }
}

my %display = (
    "\r"	=> '\r',
    "\n"	=> '\n',
    "\t"	=> '\t',
    "\0"	=> '\0',
    "\\"	=> '\\',
    );
sub display {
    my ($data) = @_;

    my $long = length $data > 30;
    $data = substr($data, 0, 37) if $long;
    # $data =~ s{([^\x20-\x7e])}{sprintf('\x%02x', ord $1)}eg;
    my $hex = unpack("H*", $data);
    $data =~ s{([^\x20-\x7e])}{$display{$1} || "."}eg;
    $data .= " ($hex)";
    $data .= " ..." if $long;
    return $data;
}

sub delete_all {
    LineProtocol->_delete_all;
    Listener->_delete_all;
    Control->_delete_all;
    $global_timeout = undef;
    die "Assertion: Still have events" if $nr_events;
}

sub global_timeout {
    ::info("Global timeout");
    delete_all();
    $exit = 1;
    # The cleanup of the globals above should be enough to fall off mainloop
    # exit $exit;
}

sub client {
    my ($socket_in, $socket_out, $udp_locals, $udp_remotes) = @_;

    my $line;
    eval {
        $line = LineProtocol->new($socket_in, $socket_out);

        for my $udp (@$udp_locals) {
            my ($from_port, $separator, $to_port) =
                $udp =~ m{^([^%=]+)([%=])([^%=]+)\z} or
                die "Invalid udp_local '$udp'";
            my $from_host = $from_port =~ s{(.*):}{}s ? $1 :
                $default_local_bind;
            $from_host = "0.0.0.0" if $from_host eq "" || $from_host eq "*";
            my $to_host   = $to_port   =~ s{(.*):}{}s ? $1 :
                $default_local_bind;
            my $l = $separator eq "%" ? $line : $lines{1};
            my $fou = Fou::UDP->new($to_host, $to_port);
            my $listener = Listener::UDP->new($l, $from_host, $from_port, $fou);
        }

        for my $name (sort keys %{$line->{settings}}) {
            if ($name eq "EPOCH") {
                $line->set_peer($name => $BASE_TIME);
            } elsif ($name eq "MSGHDR") {
                $line->set_peer($name => $msghdr_error || Socket::MsgHdr->VERSION);
            } elsif ($name eq "READLINE") {
                $line->set_peer($name => $readline_error || Term::ReadLine->VERSION);
            } else {
                $line->set_peer($name => $line->{settings}{$name});
            }
        }

        for my $udp (@$udp_remotes) {
            $udp =~ m{^[^%=]+[%=][^%=]+\z} or die "Invalid udp remote '$udp'";
            $line->write($UDP_REMOTE, $udp);
        }

        $line->write($START);
    };
    die "\u$role: $@" if $@;
    return $line;
}

sub server {
    my ($socket_in, $socket_out) = @_;

    my $line;
    eval {
        $line = LineProtocol->new($socket_in, $socket_out);

        $line->set_peer(EPOCH	 => $BASE_TIME);
        $line->set_peer(MSGHDR	 => $msghdr_error || Socket::MsgHdr->VERSION);
        $line->set_peer(READLINE => $readline_error || Term::ReadLine->VERSION);
    };
    die "\u$role: $@" if $@;
    return $line;
}

GetOptions("server:s"		=> \my $server,
           "client=s"		=> \my $client,
           "N|loops=o"		=> \$loops,
           "T=o"		=> \$global_timeout,
           "n!"			=> \my $no_control,
           "server_lib=s"	=> \my @server_lib,
           "ssh=s"		=> \$ssh,
           "M|master"		=> \my $ssh_master,
           "perl=s"		=> \my $remote_perl,
           "server_verbose!"	=> \my $server_verbose,
           "client_verbose!"	=> \my $client_verbose,
           "verbose!"		=> \$verbose,
           "server_debug!"	=> \my $server_debug,
           "client_debug!"	=> \my $client_debug,
           "debug!"		=> \$debug,
           "keepalive=f"	=> \$keepalive,
           "timeout=f"		=> \$timeout,
           "stuff!"		=> \my $stuff,
           "udp_local|l=s"	=> \my @udp_local,
           "udp_remoter=s"	=> \my @udp_remote,
           "udp_max=o"		=> \$udp_max,
           "ping_max=o"		=> \$ping_max,
           "version!"		=> \my $version,
           "U|unsafe!"		=> \my $unsafe,
           "h|help!"		=> \my $help) ||
    die "Could not parse your command line. Try $Script -h\n";

if ($version) {
    print<<"EOF";
udp_proxy $VERSION (Net::Sssssh) $VERSION
EOF
    exit 0;
}

if ($help) {
    require Config;
    $ENV{PATH} .= ":" unless $ENV{PATH} eq "";
    $ENV{PATH} = "$ENV{PATH}$Config::Config{'installscript'}";
    exec("perldoc", "-F", $unsafe ? "-U" : (), $0) || exit 1;
    # make parser happy
    %Config::Config = ();
}

die "timeout $timeout must be positive\n" if $timeout <= 0;
$settings_global{TIMEOUT} = $timeout;
die "keepalive $keepalive must be positive\n" if $keepalive <= 0;
$settings_global{KEEPALIVE} = $keepalive;
die "udp_max must be positive" if $udp_max < 1;
$settings_global{UDP_MAX} = $udp_max;
die "ping_max must be positive" if $ping_max < 1;
$settings_global{PING_MAX} = $ping_max;
die "global timeout must not be negative" if
    defined $global_timeout && $global_timeout < 0;

# We can create the fallback line now that %settings_global has been filled
LineProtocol0->new;

$role = "server" if defined $server;
$role_peer = $role eq "server" ? "client" : "server";

if ($role eq "server") {
    # From here on we are the server

    die "Cannot be both server and client\n" if defined $client;
    die "Cannot have stuff in server mode\n" if $stuff;

    my ($socket_in, $socket_out);
    if (defined $server) {
        # Manual start
        my $host = $server =~ s{(.*):}{}s ? $1 : $default_local_bind;
        $server = "0" if $server eq "";
        Listener->new($host, $server, $loops);
        if (!$no_control) {
            Control->new($lines{1});
            $| = 1;
        }
        open(STDIN, "<&", $null) || die "Could not dup to STDIN: $^E";
    } else {
        # Make sure that if we fork/exec things they won't get access to
        # our communication channel
        open($socket_in,  "<&STDIN")  || die "Could not dup STDIN: $^E";
        open(STDIN, "<&", $null) || die "Could not dup to STDIN: $^E";
        open($socket_out, ">&STDOUT") || die "Could not dup STDOUT: $^E";
        open(STDIN, ">&", $null) || die "Could not dup to STDOUT: $^E";
        server($socket_in, $socket_out);
    }
} else {
    # From here on we are the client

    $verbose        = $debug        if $debug        && !defined $verbose;
    $client_verbose = $client_debug if $client_debug && !defined $client_verbose;
    $server_verbose = $server_debug if $server_debug && !defined $server_verbose;

    $server_debug   = $client_debug   = 1 if $debug;
    $server_verbose = $client_verbose = 1 if $verbose;

    if (defined $client) {
        die "Cannot have arguments in client mode" if @ARGV;
        die "Cannot have stuff in client mode" if $stuff;

        my $host = $client =~ s{(.*):}{}s ? $1 : "127.0.0.1";
        my $socket = LineProtocol->socket_tcp($host, $client);
        client($socket, $socket, \@udp_local, \@udp_remote);
    } else {
        @ARGV || die "Missing remote host argument, Try $Script -h\n";
        $stuff = 1 if !defined $stuff;
        if ($stuff) {
            @ARGV == 1 || die "Spurious arguments\n";
        }

        pipe(my $rd0, my $wr0) || die "Could not pipe: $^E";
        pipe(my $rd1, my $wr1) || die "Could not pipe: $^E";
        defined(my $pid = fork()) || die "could not fork: $^E";

        if ($pid) {
            # Parent
            # This side does the ssh connection so that ^C goes to ssh
            eval {
                close $wr0;
                close $rd1;
                open(STDIN,  "<&", $rd0) || die "Could not dup STDIN: $^E";
                close $rd0;
                open(STDOUT, ">&", $wr1) || die "Could not dup STDOUT: $^E";
                close $wr1;

                $SIG{CHLD} = "DEFAULT";
                if ($stuff) {
                    # delete @ENV{qw(LANGUAGE LC_ALL LANG)};
                    my $remote_host = shift;
                    if ($remote_host eq "") {
                        $remote_perl = $^X if !defined $remote_perl;
                        exec($remote_perl) ||
                            die "Could not exec $remote_perl: $^E";
                    } else {
                        $remote_perl = "/usr/bin/perl" if !defined $remote_perl;
                        exec($ssh, $ssh_master ? "-M" : (), "-e", "none", $remote_host, $remote_perl) ||
                            die "Could not exec $ssh: $^E";
                    }
                } else {
                    push @ARGV, "$Bin/$Script" if @ARGV == 1;
                    exec($ssh, $ssh_master ? "-M" : (), "-e", "none", @ARGV) ||
                        die "Could not exec $ssh: $^E";
                }
            };
            die $@ || "No error";
        }

        # Child
        close $rd0;
        close $wr1;
        $wr0->autoflush(1);

        if ($stuff) {
            my $self = "$Bin/$Script";
            # Maybe we could get the same info through DATA (if we didn't close)
            open(my $fh, "<", $self) || die "Could not open $self: $^E";
            my $content = qq(#line 1 "$Bin/$Script"\n);
            $content .= do { local $/; <$fh> };
            $content =~ s/\n__END__\n.*/\n/s || die "Could not find __END__";
            # Remove full line comments, but not #line statements.
            # Leave the \n so line numbers in error messages keep working
            $content =~ s/^[^\S\n]*#(?![^\S\n]*line\s).*//mg;
            # Drop leading spaces. Saves about 20%
            # (less of course if ssh does compression, which it does by default)
            $content =~ s/^[^\S\n]+//mg;

            # Change a few variables in the server code
            my %replace =
                (verbose	=> $server_verbose,
                 debug		=> $server_debug,
                 role		=> "server",
                 # This is needed because $SET sets the remote timeout for $line
                 # but Fou::UDP is not a child of $line and uses the
                 # global settings
                 timeout	=> $timeout,
                 ping_max	=> $ping_max,
                 global_timeout	=> $global_timeout,
             );
            while (my ($name, $value) = each %replace) {
                local $Data::Dumper::Indent  = 0;
                local $Data::Dumper::Purity  = 1;
                local $Data::Dumper::Varname = $name;
                $value = Dumper($value);
                $value =~ s/\$\Q$name\E1\b/\$$name/g ||
                    die "Assertion: No VAR1";
                # info("Value=<$value>") if $verbose;
                $content =~ s{^([^\S\n]*(?:my|our)\s*)\$\Q$name\E\s*=[^;\n]*;[^\S\n]*\n}{$1$value\n}m || die "Could not set $name";
            }

            print($wr0 $PRE_STUFFER) || die "Write error:$^E";
            for my $server_lib (map split(/:/), @server_lib) {
                print($wr0 qq(use lib "$server_lib";\n)) || die "Write error:$^E";
            }
            # print($wr0 qq(\$Script="\$Script"\n)) || die "Write error:$^E";
            print($wr0 $content) || die "Write error:$^E";
            print($wr0 $POST_STUFFER) || die "Write error:$^E";
            my $line = "";
            while (length($line) < length($STUFFED)) {
                alarm(60);
                my $rc = sysread($rd1, $line, length($STUFFED)-length $line, length $line);
                if (!defined $rc) {
                    next if $! == EINTR;
                    die "Read error: $^E";
                }
                die "Unexpected EOF" if $rc == 0;
            }
            alarm(0);
            $line eq $STUFFED || die "Bad server confirm $line";
        }
        client($rd1, $wr0, \@udp_local, \@udp_remote);
    }
    if (!$no_control) {
        Control->new($lines{1});
        $| = 1;
    }
    open(STDIN, "<&", $null) || die "Could not dup to STDIN: $^E";
}

if (defined $global_timeout) {
    my $obj = bless {
        global_timeout	=> $global_timeout,
    };
    $obj->{timeout} = Timer::timer0($global_timeout, $obj, \&global_timeout);
    alarm($global_timeout+3);
    $global_timeout = $obj;
}

eval { Events->mainloop() };
delete_all();
die "\u$role DIED: $@" if $@;
# die "Assertion: \u$role fell off the mainloop";
exit $exit;

__END__
Implementation notes:
