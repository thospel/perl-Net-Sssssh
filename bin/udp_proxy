#!/usr/bin/perl -w
my $null;
BEGIN {
    # This must come before any modules, even use strict/warnings
    # (to avoid these modules keeping open early file handles for __DATA__)
    $^F == 2 || die "Assertion: Invalid CLO_EXEC range";
    open($null, "+<", "/dev/null") || die "Could not open '/dev/null': $^E";
    die "Assertion: Should at least have the source code open at fileno 0" if
        fileno($null) == 0;
    if (fileno($null) == 1) {
        # Perl will automatically subsume fd 1 into STDOUT
        open($null = undef, "+>&STDOUT") || die "Could not dup STDOUT: $^E";
    }
    if (fileno($null) == 2) {
        # Perl will automatically subsume fd 2 into STDERR
        open($null = undef, "+>&STDERR") || die "Could not dup STDERR: $^E";
    }
    fileno($null) > 2 || die "Assertion: Invalid NULL handle";
    # So now we are absolutely sure $null has CLO_EXEC
}
# Now take over STDIN in case we had no STDIN and perl opened it as source code
# We should have a DATA filehandle because this file has an __END__ section
# (but for unclear reasons it does not when stuffing --Ton)
if (defined fileno(DATA)) {
    fileno(DATA) != fileno(STDIN) ||
        open(STDIN, "<&", $null) || die "Could not dup to STDIN: $^E";
    close(DATA);
}

use strict;
use warnings;

# modprobe fou
# ip link add name fou1 type ipip remote 127.0.0.1 local 127.0.0.1 ttl 225 encap fou encap-sport auto encap-dport 1236
# ip link set fou1 up
# ip addr add 10.253.4.1/24 dev fou1
# # If you add "dev fou1" to the add port it seems to stop working
# # If you remove the "local 127.0.0.1" it keeps working
# ip fou add port 1237 ipproto 4 local 127.0.0.1

# Redirect packets to port 1234 into the fou1 tunnel:
# iptables -t mangle -N FWMARK2
# # iptables -t mangle -A FWMARK2 -j LOG --log-prefix 'iptables-mark2: ' --log-level info
# iptables -t mangle -A FWMARK2 -j MARK --set-mark 17
# iptables -t mangle -A OUTPUT -p udp --dport 1234 -j FWMARK2
# # Also catch ping requests
# # iptables -t mangle -A OUTPUT -p icmp --icmp-type 8 -j FWMARK2
# ip rule add fwmark 17 lookup 101
# ip route add default via 10.253.4.1 table 101

# Avoid other stuff sneaking into the tunnel
# (not sure how, but when using deluge (torrent): external traffic not on the marked port gets into the tunnel. Deluge for some reason sometimes uses the tunnel IP as its source address)
# ---- Targeted (124 is uid of deluge -----
# iptables -A OUTPUT -o ppp0 -m owner --uid-owner 124 -j DROP
# iptables -A OUTPUT -s 10.253.0.8 -m owner --uid-owner 124 -j ACCEPT
# iptables -A OUTPUT -s 10.253.1.8 -m owner --uid-owner 124 -j ACCEPT
# iptables -A OUTPUT -s 127.0.0.0/8 -m owner --uid-owner 124 -j ACCEPT
# iptables -A OUTPUT -m owner --uid-owner 124 -j DROP
# OSPF (bird)
# iptables -A OUTPUT -p 89 -s 10.253.4.1 -j DROP
# SSDP. Who is doing this ?
# iptables -A OUTPUT -p udp -s 10.253.4.1 -d 239.255.255.250 -j DROP
# ---- Brute force -----
# iptables -t mangle -A INPUT -d 10.253.4.1 -j DROP
# iptables -t mangle -A OUTPUT -s 10.253.4.1 -j DROP

# sysctl -w net.ipv4.conf.all.rp_filter=0
# sysctl -w net.ipv4.conf.fou1.rp_filter=0

# ip fou del port 1237 ipproto 4 local 127.0.0.1
# ip link del name fou1

# Ping forwarding needs permission to open a IPPROTO_ICMP sockets on the
# forwarded host.
# E.g. On linux:
#   Query current permissions:
#      sysctl net.ipv4.ping_group_range
#   Allow group 1014:
#      sysctl net.ipv4.ping_group_range='1014 1014'

our $VERSION = "1.000";

use FindBin qw($Bin $Script);
use Getopt::Long 2.24 qw(:config bundling require_order);
use Carp;
use Sys::Hostname;
use Errno qw(EINTR ENOENT);
use Time::Local qw(timegm);
use Socket qw(inet_aton);

use Data::Dumper;
$Data::Dumper::Indent   = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Useqq	= 1;

($Bin, $Script) = __FILE__ =~ m{^(.*)/(.+)\z} or
    die "Could not parse ", __FILE__ if $Script eq "-" && __FILE__ ne "-";

$SIG{PIPE} = "IGNORE";
$SIG{CHLD} = "IGNORE";

delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};
$ENV{PATH}="/usr/bin:/usr/sbin:/bin:/sbin";

my $MULTICAST_BEGIN = inet_aton("224.0.0.0") || die "Assertion: Bad address";
# multicast range *excludes* this END address
my $MULTICAST_END   = inet_aton("240.0.0.0") || die "Assertion: Bad address";

my $IP_VERSION = 4;
defined(my $PROTO_ICMP = getprotobyname("icmp")) || die "Unknown protocol ICMP";
defined(my $PROTO_UDP  = getprotobyname("udp"))  || die "Unknown protocol UDP";
defined(my $PROTO_TCP  = getprotobyname("tcp"))  || die "Unknown protocol TCP";
my $IHL = 5;
my $ICMP_HEADER = 8;
my $UDP_HEADER  = 8;
my $DF = 2;
my $TTL = 64;
my $ICMP_ECHO_REQUEST = 8;
my $ICMP_ECHO_REPLY = 0;

my $ssh = "/usr/bin/ssh";
my $verbose = undef;
my $global_timeout = undef;
my $timeout = 120;
my $keepalive = 300;
my $udp_max = 10;
my $ping_max = 10;
my $default_bind  = "127.0.0.1";
my $exit = 0;

# How long a server UDP socket lingers without traffic
# How long an errored TCP connection tries to push lingering output
my $SOCKS_TIMEOUT = 120;
# How much we can typically fit into our communication channel
my $LINE_BLOCK_SIZE = int(2**14);
my $BLOCK_SIZE = int(2**16);
my $UDP_SIZE = int(2**16);
my $LISTEN_BACKLOG = 128;

my @PING =
    $^O eq "solaris" ? (["ping", "-s"], ["64", "1"]) :
    (["ping", "-c", "1"], []);

my %settings_global = (
    EPOCH	=> undef,
    MSGHDR	=> undef,
    TIMEOUT	=> undef,
    KEEPALIVE	=> undef,
    UDP_MAX	=> undef,
    PING_MAX	=> undef,
    # ACK_LIMIT should be greater than KEEPALIVE/ACK packet
    # (Code will increase it if not, but you will still send way too many ACKs)
    ACK_LIMIT	=> int(1e6),
    # For debugging:
    # ACK_LIMIT	=> 0,
);
my @setting_ids = sort keys %settings_global;
my %setting_ids;
$setting_ids{$setting_ids[$_]} = $_ for 0..$#setting_ids;

my $SECRET = pack("NNNN", $$ ^ rand 2**32, $^T ^ rand 2**32, rand 2**32, rand 2**32);

my $STUFFED = "GoNow";

my $PROTOCOL	= 1;
# Line protocol commands
my $START	= "1";
my $SET		= "S";	# sets a server variable
my $FOU_REMOTE	= "r";
my $PING	= "P";
my $RESPONSE_PING= "p";
my $RESPONSE_UDP= "d";
my $DATA_UDP	= "D";
my $DATA_TCP_LR	= "T";	# Local to Remote DATA
my $DATA_TCP_RL	= "t";	# Remote to Local DATA
my $DATA_EOF_LR	= "E";	# Local to Remote EOF
my $DATA_EOF_RL	= "e";	# Remote to Local EOF
my $DATA_FIN_LR	= "F";	# Local to Remote FINISH (will never more about this id)
my $DATA_FIN_RL	= "f";	# Remote to Local FINISH (will never more about this id)
my $KEEP	= "K";	# Keepalive/ACK packet
my $CONNECT	= "C";

my $ERROR_ECONNREFUSED	= "Connection refused";
my $ERROR_ENETUNREACH	= "Network is unreachable";
my $ERROR_ETIMEDOUT	= "Timed out";
my $ERROR_ERESOLV	= "Could not resolve host";

my $msghdr_error;
BEGIN {
    # Can't use "require" later on since (old) Socket::MsgHdr has INIT blocks
    $msghdr_error = eval(sprintf(qq(#line %d "%s"\nuse Socket::MsgHdr qw(pack_cmsghdr unpack_cmsghdr sendmsg recvmsg); 1), __LINE__, __FILE__)) ? "" :
        $@ || "Unknown error loading Socket::MsgHdr\n";
    $msghdr_error =~ s/^BEGIN failed.*\n\z//m;
    $msghdr_error =~ s/\s+\z//;

}
END {
    # Carp.pm can stash objects in @DB::args causing them not to get freed
    @DB::args = ();
}

my $FREE_BSD = $^O eq "freebsd";
# IPPROTO_IP exists in Socket, but not in really old ones
my $IPPROTO_IP = 0;
my ($IP_RECVTTL, $IP_TTL, $IP_PKTINFO, $ICMP_FILTER, $SOL_RAW);
if (!$msghdr_error) {
    if (0 && $FREE_BSD) {
        # FreeBSD uses IP_RECVDSTADDR
        $IP_PKTINFO	=  7;
        $IP_RECVTTL	= 65;
        $IP_TTL		=  4;
    } elsif ($^O eq "linux") {
        $IP_PKTINFO	=  8;
        $IP_RECVTTL	= 12;
        $IP_TTL		=  2;
        $ICMP_FILTER	=  1;
        $SOL_RAW	=255;
    } else {
        $msghdr_error = "Socket::MsgHdr constants for OS $^O not implemented (yet)\n";
    }
}

my $msghdr = $msghdr_error ? undef : Socket::MsgHdr->new();
my $loops;

my $role = "client";
my $role_peer;

# Determine some system settings
my $hostname = hostname();
my $me;
if ($^O eq "MSWin32") {
    require Win32;
    $me = Win32::LoginName();
} else {
    if (my $user = $ENV{LOGNAME}) {
        if (defined(my $uid = getpwnam($user))) {
            $me = $user if $> == $uid;
        }
    }
    $me ||= getpwuid $>;
}
die "Can't determine who I am" if !$me;

die "Bad file '", __FILE__, "'" if __FILE__ =~ /["\n\0]/;
# Client stuffer
my $POST_STUFFER = sprintf(qq(#line %d "%s"\n%s),
                           __LINE__, __FILE__, '
BEGIN {
    eval {
        open($SAVED_STDIN, "<&", \*STDIN);
        open(STDIN, "<", "/dev/null") || die "NULL: $!";
        1;
    } or do {
        print STDERR $@ || "Unknown error\n";
        exit 255;
    };
}
');
my $PRE_STUFFER = sprintf(qq(#line %d "%s"\n%s),
                           __LINE__, __FILE__, '
BEGIN { $^W = 1 }

my $SAVED_STDIN;
open(STDIN, "<&", $SAVED_STDIN) || die "Could not dup STDIN: $^E";
close($SAVED_STDIN) || die "Could not close SAVED_STDIN: $^E";
$| = 1;
print "' . $STUFFED . '";
');

my $nr_events = 0;
{
    package Events;
    # A small event core
    use Carp;
    use Errno qw(EINTR);
    use Scalar::Util qw(weaken);

    my $read_mask  = "";
    my $write_mask = "";
    my $error_mask = "";
    my @refs = qw(read write error);
    my %refs = (
        read	=> \my %read_refs,
        write	=> \my %write_refs,
        error	=> \my %error_refs,
    );

    # All placeholder subs are the same sub
    use constant NOP => sub {};

    sub Events::Read::DESTROY {
        defined(my $fd = ${shift()}) || die "No filedescriptor";
        ::caller_info("delete_read $fd") if $verbose > 1;
        # This strange assign after delete is to update the reference the for in
        # sub mainloop may still have in such a way that element 0 keeps existing
        # (otherwise a confess during the callback will access freed memory)
        # We could set either the object (index 0) or the callback (index 1)
        # But the object is already weak and the callback may be a closure
        delete($read_refs{$fd})->[1] = NOP;
        if (%read_refs) {
            vec($read_mask, $fd, 1) = 0;
            $read_mask =~ s/\x00+\z//;
        } else {
            $read_mask = "";
        }
        --$nr_events;
    }

    sub Events::Read0::DESTROY {
        defined(my $fd = ${shift()}) || die "No filedescriptor";
        ::caller_info("delete_read0 $fd") if $verbose > 1;
        # This strange assign after delete is to update the reference the for in
        # sub mainloop may still have in such a way that element 0 keeps existing
        # (otherwise a confess during the callback will access freed memory)
        # We could set either the object (index 0) or the callback (index 1)
        # But the object is already weak and the callback may be a closure
        delete($read_refs{$fd})->[1] = NOP;
        if (%read_refs) {
            vec($read_mask, $fd, 1) = 0;
            $read_mask =~ s/\x00+\z//;
        } else {
            $read_mask = "";
        }
    }

    sub Events::Write::DESTROY {
        defined(my $fd = ${shift()}) || die "No filedescriptor";
        ::caller_info("delete_write $fd") if $verbose > 1;
        # This strange assign after delete is to update the reference the for in
        # sub mainloop may still have in such a way that element 0 keeps existing
        # (otherwise a confess during the callback will access freed memory)
        # We could set either the object (index 0) or the callback (index 1)
        # But the object is already weak and the callback may be a closure
        delete($write_refs{$fd})->[1] = NOP;
        if (%write_refs) {
            vec($write_mask, $fd, 1) = 0;
            $write_mask =~ s/\x00+\z//;
        } else {
            $write_mask = "";
        }
        --$nr_events;
    }

    sub Events::Write0::DESTROY {
        defined(my $fd = ${shift()}) || die "No filedescriptor";
        ::caller_info("delete_write0 $fd") if $verbose > 1;
        # This strange assign after delete is to update the reference the for in
        # sub mainloop may still have in such a way that element 0 keeps existing
        # (otherwise a confess during the callback will access freed memory)
        # We could set either the object (index 0) or the callback (index 1)
        # But the object is already weak and the callback may be a closure
        delete($write_refs{$fd})->[1] = NOP;
        if (%write_refs) {
            vec($write_mask, $fd, 1) = 0;
            $write_mask =~ s/\x00+\z//;
        } else {
            $write_mask = "";
        }
    }

    sub Events::Error::DESTROY {
        defined(my $fd = ${shift()}) || die "No filedescriptor";
        ::caller_info("delete_error $fd") if $verbose > 1;
        # This strange assign after delete is to update the reference the for in
        # sub mainloop may still have in such a way that element 0 keeps existing
        # (otherwise a confess during the callback will access freed memory)
        # We could set either the object (index 0) or the callback (index 1)
        # But the object is already weak and the callback may be a closure
        delete($error_refs{$fd})->[1] = NOP;
        if (%error_refs) {
            vec($error_mask, $fd, 1) = 0;
            $error_mask =~ s/\x00+\z//;
        } else {
            $error_mask = "";
        }
        --$nr_events;
    }

    sub Events::Error0::DESTROY {
        defined(my $fd = ${shift()}) || die "No filedescriptor";
        ::caller_info("delete_error0 $fd") if $verbose > 1;
        # This strange assign after delete is to update the reference the for in
        # sub mainloop may still have in such a way that element 0 keeps existing
        # (otherwise a confess during the callback will access freed memory)
        # We could set either the object (index 0) or the callback (index 1)
        # But the object is already weak and the callback may be a closure
        delete($error_refs{$fd})->[1] = NOP;
        if (%error_refs) {
            vec($error_mask, $fd, 1) = 0;
            $error_mask =~ s/\x00+\z//;
        } else {
            $error_mask = "";
        }
    }

    sub die_no_handle {
        ::caller_info("DIE: Assertion: Not a filehandle") if $verbose > 1;
        die sprintf("Assertion: Not a filehandle [%s]\n", ::callers());
    }

    sub add_read {
        defined(my $fd = fileno(shift)) || die_no_handle();
        ::caller_info("add_read $fd") if $verbose > 1;
        croak "Descriptor $fd already selected for read" if $read_refs{$fd};
        vec($read_mask, $fd, 1) = 1;
        weaken(($read_refs{$fd} = [shift, shift])->[0]);
        ++$nr_events;
        return bless \$fd, "Events::Read";
    }

    sub add_read0 {
        defined(my $fd = fileno(shift)) || die_no_handle();
        ::caller_info("add_read0 $fd") if $verbose > 1;
        croak "Descriptor $fd already selected for read" if $read_refs{$fd};
        vec($read_mask, $fd, 1) = 1;
        weaken(($read_refs{$fd} = [shift, shift])->[0]);
        return bless \$fd, "Events::Read0";
    }

    sub add_write {
        defined(my $fd = fileno(shift)) || die_no_handle();
        ::caller_info("add_write $fd") if $verbose > 1;
        croak "Descriptor $fd already selected for write" if $write_refs{$fd};
        vec($write_mask, $fd, 1) = 1;
        weaken(($write_refs{$fd} = [shift, shift])->[0]);
        ++$nr_events;
        return bless \$fd, "Events::Write";
    }

    sub add_write0 {
        defined(my $fd = fileno(shift)) || die_no_handle();
        ::caller_info("add_write0 $fd") if $verbose > 1;
        croak "Descriptor $fd already selected for write" if $write_refs{$fd};
        vec($write_mask, $fd, 1) = 1;
        weaken(($write_refs{$fd} = [shift, shift])->[0]);
        return bless \$fd, "Events::Write0";
    }

    sub add_error {
        defined(my $fd = fileno(shift)) || die_no_handle();
        ::caller_info("add_error $fd") if $verbose > 1;
        croak "Descriptor $fd already selected for error" if $error_refs{$fd};
        vec($error_mask, $fd, 1) = 1;
        weaken(($error_refs{$fd} = [shift, shift])->[0]);
        ++$nr_events;
        return bless \$fd, "Events::Error";
    }

    sub add_error0 {
        defined(my $fd = fileno(shift)) || die_no_handle();
        ::caller_info("add_error0 $fd") if $verbose > 1;
        croak "Descriptor $fd already selected for error" if $error_refs{$fd};
        vec($error_mask, $fd, 1) = 1;
        weaken(($error_refs{$fd} = [shift, shift])->[0]);
        return bless \$fd, "Events::Error0";
    }

    sub __unloop {
        no warnings "exiting";
        last MAINLOOP;
    }

    my $unloop;
    sub _unloop {
        return if $unloop;
        $unloop = bless {};
        $unloop->{timer} = Timer::immediate(
            $unloop,
            sub {
                $unloop = undef;
                no warnings "exiting";
                last MAINLOOP;
            });
    }

    sub events_fd {
        my $events = shift;
        for my $name (@refs) {
            my $refs = $refs{$name};
            push @$events, map {
                $refs->{$_} ?
                    sprintf("%-5s%s %2d -> %s",
                            ucfirst $name,
                            ref $refs->{$_} =~ /0\z/ ? " (dead)" : "",
                            $_,
                            defined $refs->{$_}[0] ? ref $refs->{$_}[0] : "undef") : ()
                } sort { $a <=> $b } keys %$refs;
        }
    }

    sub _events {
        my @events;
        events_fd(\@events);
        Timer::events_immediate(\@events);
        Timer::events_timer(\@events);
        return \@events;
    }
    sub events {
        return join("", map "$_\n", @{_events()});
    }

    sub mainloop {
        # ::info("WARNING (can safely be ignored): $msghdr_error") if
        #    $msghdr_error && $verbose;
        ::info("Entering mainloop $$ (nr_events=$nr_events)") if $verbose;
        _mainloop();
        ::info("Exiting mainloop $$ (nr_events=$nr_events)") if $verbose;
    }

    sub _mainloop {
        my ($r, $w, $e);
        # my $name;
      MAINLOOP:
        while ($nr_events) {
            if ((select($r = $read_mask,
                        $w = $write_mask,
                        $e = $error_mask,
                        Timer::timers_collect()) || next) > 0) {
                # The copy to @tmp is because the stack doesn't keep values
                # alive, so any deletes on xxx_refs during the loop can make
                # the value go poof. The copy temporarily increases the
                # refcount so the value doesn't go away. That is also why the
                # delete_xxx functions modify the value before delete
                # $name = $_->[1], $_->[0]->$name for my @tmp=(
                $_->[1]->($_->[0] || next) for my @tmp=(
                    # $$_ and $$_->[0]->(@{$$_->[1]}[1..$#{$$_->[1]}]) for
                    @read_refs{ grep vec($r, $_, 1), keys %read_refs},
                    @write_refs{grep vec($w, $_, 1), keys %write_refs},
                    @error_refs{grep vec($e, $_, 1), keys %error_refs});
            } elsif ($! == EINTR) {
                redo;
            } else {
                die "Select failed: $^E";
            }
        } continue {
            Timer::timers_run();
        }
    }

    #no warnings "once";
    #*IO::Handle::add_read	= \&add_read;
    #*IO::Handle::add_read0	= \&add_read0;
    #*IO::Handle::add_write	= \&add_write;
    #*IO::Handle::add_write0	= \&add_write0;
    #*IO::Handle::add_error	= \&add_error;
    #*IO::Handle::add_error0	= \&add_error0;
}

package Signals;
use Scalar::Util qw(weaken);

sub DESTROY {
    my ($signals) = @_;

    # This makes sure Signal::DESTROY uses the efficient code path
    $_ &&= 0 for values %{$signals->{count}};
    @{$signals->{signalled}} = ();
    %{$signals->{handlers}} = ();

    # The user can be holding on to some Signal objects so their DESTROY
    # doesn't get called and so some $SIG entries can survive. Kill them.
    for my $sig_name (sort keys %{$signals->{old}}) {
        ::caller_info("Restore signal $sig_name") if $verbose > 1;
        $SIG{$sig_name} = $signals->{old}{$sig_name};
    }
    %{$signals->{old}} = ();
}

{
    my $signals;

    sub init {
        my ($class) = @_;

        return $signals if $signals;

        my %signals = (
            signalled 	=> [],
            handlers	=> {},
            count	=> {},
            old		=> {},
        );
        pipe($signals{rd}, $signals{wr}) ||
            die "Could not create signal pipe: $^E";
        $signals{rd}->blocking(0);
        # Leave the write side blocking
        $signals{reader} = Events::add_read0($signals{rd}, \%signals, \&dealer);
        return $signals = bless \%signals, $class;
    }

    sub _cleanup_all {
        weaken(my $probe = $signals);
        $signals = undef;
        die "Assertion: Somebody is holding a reference to signals" if $probe;
    }

    sub signal_handler {
        my ($sig_name) = @_;

        $signals || die "Assertion: signal $sig_name without Signals object";
        $signals->{count}{$sig_name} ||
            die "Assertion: signal $sig_name without handlers";
        my $from = @{$signals->{signalled}} or
            syswrite($signals->{wr}, "x") ||
            die "Could not write to signal pipe: $^E";
        push @{$signals->{signalled}}, @{$signals->{handlers}{$sig_name}};
        for my $i ($from .. $#{$signals->{signalled}}) {
            weaken($signals->{signalled}[$i]);
        }
    }
}

package Signal;
use Errno qw(EINTR EAGAIN EWOULDBLOCK);
use Scalar::Util qw(weaken);

# Signal indices
use constant {
    SIGNALS	=> 0,
    NAME	=> 1,
    OBJ		=> 2,
    CODE	=> 3,
};

# Hard to classify this one. It belongs to both Signals and Signal really
sub Signals::dealer {
    my ($signals) = @_;

    while (@{$signals->{signalled}}) {
        my $handler = shift @{$signals->{signalled}} || next;
        # No need to check $handler->[SIGNALS] since we KNOW we have $signals
        defined $handler->[OBJ] || next;
        $handler->[CODE]->($handler->[OBJ], $handler->[NAME]);
    }

    # Avoid endless EINTR/read
    for my $i (1..100) {
        my $rc = sysread($signals->{rd}, my $buffer, $BLOCK_SIZE) && next;
        die "Assertion: EOF from signal pipe" if defined $rc;
        next if $! == EINTR;
        $! == EAGAIN || $! == EWOULDBLOCK ||
            die "error reading drom signal pipe: $^E";
        return;
    }
    die "Assertion: Seemingly endless read from signal pipe";
}

sub DESTROY {
    my ($handler) = @_;

    my $sig_name = $handler->[NAME];
    ::caller_info("delete_signal $sig_name") if $verbose > 1;

    my $signals = $handler->[SIGNALS] || return;

    if ($signals->{count}{$sig_name} > 1) {
        # This makes managing lots of handlers for the same signal
        # O(n^2). We could go for a doubly linked list of handlers or
        # some other datastructure if this ever becomes relevant
        my $handlers = $signals->{handlers}{$sig_name};
        my $to = 0;
        for my $i (0..$#$handlers) {
            next if !$handlers->[$i] || !defined $handlers->[$i][OBJ] || $handlers->[$i] == $handler;
            weaken($handlers->[$to] = $handlers->[$i]) if $i != $to;
            ++$to;
        }
        $#$handlers = $to-1;
        $to < $signals->{count}{$sig_name} ||
            die "Assertion: Could not find DESTROYed signal handler";
        return if $signals->{count}{$sig_name} = $to;
    }
    @{$signals->{handlers}{$sig_name}} = ();
    if (exists $signals->{old}{$sig_name}) {
        ::info("Restore signal $sig_name (deleted all signal callbacks)") if $verbose > 1;
        $SIG{$sig_name} = delete $signals->{old}{$sig_name};
    }
}

sub add0 {
    my $sig_name = shift;

    ::caller_info("add_signal $sig_name") if $verbose > 1;

    # We store $signals because if $signals gets cleaned up and restored
    # before Signal DESTROY we don't want it to impact the wrong object
    my $signals = Signals->init;
    my $handler = bless [$signals, $sig_name, shift, shift], "Signal";
    weaken($handler->[OBJ]);
    weaken($handler->[SIGNALS]);
    if (1 == ++$signals->{count}{$sig_name}) {
        ::caller_info("Take over_signal $sig_name") if $verbose > 1;
        $signals->{old}{$sig_name} = $SIG{$sig_name};
        $SIG{$sig_name} = \&Signals::signal_handler;
    }
    weaken($signals->{handlers}{$sig_name}[@{$signals->{handlers}{$sig_name}}] = $handler);
    return $handler;
}

my $CLOCK_TYPE_NAME;
{
    package Timer;
    # A small timer core
    use Scalar::Util qw(weaken refaddr);
    use Carp;
    use Time::HiRes qw(clock_gettime CLOCK_REALTIME CLOCK_MONOTONIC);

    # Timer indices
    use constant {
        INDEX	=> 0,
        TIME	=> 1,
        OBJ	=> 2,	# Must come after TIME
        CODE	=> 3,
        KEEPDEAD=> 4,
        CALLERS	=> 5,
    };

    my @timers = (undef);
    # @expired must be persistent so no timers get lost if a callback dies
    my @expired;
    # Simular for @expired. @immediate contains timeout 0 timers that we don't
    # even bother to put in @timers
    my @immediate;

    my $CLOCK_TYPE;
    $CLOCK_TYPE_NAME =
        eval { $CLOCK_TYPE = CLOCK_MONOTONIC; "MONOTONIC" } ||
    eval { $CLOCK_TYPE = CLOCK_REALTIME;  "REAL" } ||
    die "Time::HiRes doesn't even have CLOCK_REALTIME";

    sub realtime {
        return clock_gettime(CLOCK_REALTIME);
    }

    sub clocktime : method {
        return clock_gettime($CLOCK_TYPE);
    }

    # Timers are kept in a simple binary heap @timers
    sub timer {
        if ($verbose > 1) {
            my $v = $verbose;
            $verbose = 0;
            my $timer = timer(@_);
            $verbose = $v;
            my $callers = ::callers();
            $timer->[CALLERS] = $callers;
            ::info("add Timer(%s) %08x [%s]", $_[0], refaddr($timer), $callers);
            return $timer;
        }
        my $time = shift() + clocktime();
        my $i = @timers;
        while ($i > 1 && $time < $timers[$i >> 1][TIME]) {
            weaken($timers[$i] = $timers[$i >> 1]);
            $i = ($timers[$i][INDEX] = $i) >> 1;
        }
        my $timer = bless [$i, $time, shift, shift, 0];
        weaken($timer->[OBJ]);
        weaken($timers[$i] = $timer);
        ++$nr_events;
        return $timer;
    }

    sub timer0 {
        if ($verbose > 1) {
            my $v = $verbose;
            $verbose = 0;
            my $timer = timer0(@_);
            $verbose = $v;
            my $callers = ::callers();
            $timer->[CALLERS] = $callers;
            ::info("add0 Timer(%s) %08x [%s]", $_[0], refaddr($timer), $callers);
            return $timer;
        }
        my $time = shift() + clocktime();
        my $i = @timers;
        while ($i > 1 && $time < $timers[$i >> 1][TIME]) {
            weaken($timers[$i] = $timers[$i >> 1]);
            $i = ($timers[$i][INDEX] = $i) >> 1;
        }
        my $timer = bless [$i, $time, shift, shift, 1];
        weaken($timer->[OBJ]);
        weaken($timers[$i] = $timer);
        return $timer;
    }

    sub immediate {
        # If we ever expose the TIME element we should put clocktime() there
        my $timer = bless [0, 0, shift, shift, 0];
        weaken($timer->[OBJ]);
        weaken($immediate[@immediate] = $timer);
        if ($verbose > 1) {
            my $callers = ::callers();
            $timer->[CALLERS] = $callers;
            ::info("add Immediate Timer(0) %08x [%s]", refaddr($timer), $callers);
        }
        ++$nr_events;
        return $timer;
    }

    sub DESTROY {
        my ($timer) = @_;

        my $i = $timer->[INDEX];
        if ($verbose > 1 && defined $i) {
            if ($timer->[CALLERS]) {
                my $callers = ::callers();
                ::info("delete Timer %08x [%s], added at [%s]", refaddr($timer), $callers, $timer->[CALLERS]);
            } else {
                ::caller_info("delete Timer %08x", refaddr($timer));
            }
        }
        if (!$i) {
            croak "Not a timer reference" unless defined($i);
            # Could be a timer sitting on the expired queue in run_now
            # This slicing will only be useful if not called by perl internals
            if (@$timer > TIME) {
                --$nr_events unless $timer->[KEEPDEAD];
                $#$timer = TIME;
            }
            return;
        }
        --$nr_events unless $timer->[KEEPDEAD];
        $timer->[INDEX] = 0;
        # Last element or beyond...
        if ($i >= $#timers) {
            croak "Not a timer reference" if $i > $#timers;
            pop @timers;
            return;
        }
        my $time = $timers[-1][TIME];
        if ($i > 1 && $time < $timers[$i >> 1][TIME]) {
            # percolate to root
            do {
                weaken($timers[$i] = $timers[$i >> 1]);
                $i = ($timers[$i][INDEX] = $i) >> 1;
            } while ($i > 1 && $time < $timers[$i >> 1][TIME]);
        } else {
            # percolate to leafs
            my $n = @timers-2;
            my $l = $i * 2;
            while ($l < $n) {
                if ($timers[$l][TIME] < $time) {
                    if ($timers[$l+1][TIME] < $timers[$l][TIME]) {
                        weaken($timers[$i] = $timers[$l+1]);
                        $timers[$i][INDEX] = $i;
                        $i = $l+1;
                    } else {
                        weaken($timers[$i] = $timers[$l]);
                        $timers[$i][INDEX] = $i;
                        $i = $l;
                    }
                } elsif ($timers[$l+1][TIME] < $time) {
                    weaken($timers[$i] = $timers[$l+1]);
                    $timers[$i][INDEX] = $i;
                    $i = $l+1;
                } else {
                    last;
                }
                $l = $i * 2;
            }
            if ($l == $n && $timers[$l][TIME] < $time) {
                weaken($timers[$i] = $timers[$l]);
                $timers[$i][INDEX] = $i;
                $i = $l;
            }
        }
        weaken($timers[$i] = pop @timers);
        $timers[$i][INDEX] = $i;
    }

    sub timers_collect {
        if (@immediate) {
            my $from = @expired;
            push @expired, @immediate;
            weaken($expired[$_]) for $from .. $#expired;
            @immediate = ();
        }
        return @expired ? 0 : undef if @timers <= 1;
        my $now = clocktime();
        return @expired ? 0 : $timers[1][TIME] - $now if $timers[1][TIME] > $now;

        # We will expire at least 1 timer
        # @timers > 2 makes sure that if we pop @timers we don't remove $timers[1]
        while (@timers > 2) {
            $timers[1][INDEX] = 0;
            weaken($expired[@expired] = $timers[1]);

            my $time = $timers[-1][TIME];
            my $n = @timers-2;
            my $i = 1;
            my $l = 2;
            while ($l < $n) {
                if ($timers[$l][TIME] < $time) {
                    if ($timers[$l+1][TIME] < $timers[$l][TIME]) {
                        weaken($timers[$i] = $timers[$l+1]);
                        $timers[$i][INDEX] = $i;
                        $i = $l+1;
                    } else {
                        weaken($timers[$i] = $timers[$l]);
                        $timers[$i][INDEX] = $i;
                        $i = $l;
                    }
                } elsif ($timers[$l+1][0] < $time) {
                    weaken($timers[$i] = $timers[$l+1]);
                    $timers[$i][INDEX] = $i;
                    $i = $l+1;
                } else {
                    last;
                }
                $l = $i * 2;
            }
            if ($l == $n && $timers[$l][TIME] < $time) {
                weaken($timers[$i] = $timers[$l]);
                $timers[$i][INDEX] = $i;
                $i = $l;
            }
            weaken($timers[$i] = pop @timers);
            $timers[$i][INDEX] = $i;
            return 0 if $timers[1][TIME] > $now;
        }
        if (@timers == 2) {
            $timers[1][INDEX] = 0;
            weaken($expired[@expired] = pop @timers);
        }

        return 0;
    }

    sub timers_run {
        @expired || return;
        my $timer;

        # Using while instead of for in case a callback dies
        ($timer = shift @expired and
         $timer->[KEEPDEAD]++ || $nr_events-- and
         $timer->[OBJ] and
         $timer->[CODE]->($timer->[OBJ])) while @expired;
    }

    sub events_immediate {
        my $events = shift;
        for my $timer (@immediate) {
            push @$events, sprintf("Immediate%s -> %s (id=%08x)",
                    $timer->[KEEPDEAD] ?  " (dead)" : "",
                    defined $timer->[OBJ] ? ref $timer->[OBJ] : "undef",
                    refaddr($timer)) if $timer;
        }
    }

    sub events_timer {
        my $events = shift;
        my $now = clocktime();
        push @$events, map {
            sprintf("Timer%s %2d -> %s (id=%08x timeout=%.3f)",
                    $_->[KEEPDEAD] ?  " (dead)" : "",
                    $_->[INDEX],
                    defined $_->[OBJ] ? ref $_->[OBJ] : "undef",
                    refaddr($_),
                    $_->[TIME]-$now,
                )
        } sort { $a->[TIME] <=> $b->[TIME] } grep defined, @timers;
    }
}

package Ids;
# Allocate and free unique numbers

# First id that will be given out
use constant INIT_ID => 1;

sub new {
    my $ids = bless {}, shift;
    $ids->id_init;
    return $ids;
}

sub id_init {
    my ($ids) = @_;

    $ids->{free_ids} = [];
    $ids->{free_id}  = INIT_ID() - 1;
}

sub id_alloc {
    my ($ids) = @_;

    return shift @{$ids->{free_ids}} || ++$ids->{free_id};
}

sub id_free {
    my ($ids, $id) = @_;

    push @{$ids->{free_ids}}, $id;
    # Decrease free_ids some if we are lucky
    while (@{$ids->{free_ids}}) {
        if ($ids->{free_ids}[-1] == $ids->{free_id}) {
            --$ids->{free_id};
            pop @{$ids->{free_ids}};
        } elsif ($ids->{free_ids}[0] == $ids->{free_id}) {
            --$ids->{free_id};
            shift @{$ids->{free_ids}};
        } else {
            last;
        }
    }
}

sub count {
    my ($ids) = @_;

    return $ids->{free_id} - @{$ids->{free_ids}} + (1-INIT_ID);
}

package ConnUtils;
use Socket
    qw(AF_INET PF_INET SOCK_DGRAM SOCK_STREAM SO_REUSEADDR IPPROTO_TCP
       TCP_NODELAY SOL_SOCKET
       inet_aton inet_ntoa pack_sockaddr_in unpack_sockaddr_in);
use Errno qw(EADDRINUSE EPROTONOSUPPORT EACCES);
use Carp qw(croak);

# IPv6 could use [fe80::240:63ff:fede:3c19]:1234 as notation (like RFC 3986)
my %parse_regex = (
    tcp4	=> "(?:([^:]*):|^)([^:]*)",
    udp4	=> "(?:([^:]*):|^)([^:]*)",
);

my %from_defaults = (
    tcp4	=> "0.0.0.0:0",
    udp4	=> "0.0.0.0:0",
);

sub build_parser {
    my ($mode, $types, $matches) = @_;

    my @regex;
    $types = "TCP4" if !defined $types || $types eq "";
    for my $type (split /\|/, $types) {
        my $regex = $parse_regex{lc $type} || die "Unknown $mode type '$type'";
        $regex =~ s/\((?!\?)/(?:/g;
        push @regex, "($regex)";
        push @$matches, [$mode, lc $type];
    }
    # print STDERR "REGEX: <@regex>\n";
    return join("|", @regex);
}

sub resolve {
    my ($class, $address, $context) = @_;

    $address->{type} eq "udp4" || $address->{type} eq "tcp4" || next;

    $address->{h} = $address->{host};
    $address->{p} = $address->{port};

    $address->{addr} = inet_aton($address->{host}) ||
        die "Could not resolve $context '$address->{host}'\n";
    $address->{port} = $address->{port} =~
        # There is no port 0 in /etc/services so we can use ||
        /^0\z|^[1-9][0-9]*\z/ ? int($address->{port}) :
        $address->{type} =~ /^udp/ ? getservbyname($address->{port}, "udp") ||
        die("$context: Unknown UDP service '$address->{port}'\n") :
        $address->{type} =~ /^tcp/ ? getservbyname($address->{port}, "tcp") ||
        die("$context: Unknown TCP service '$address->{port}'\n") :
        die("Assertion: $context: Unknown type '$address->{type}'");
    $address->{host} = inet_ntoa($address->{addr});
    $address->{display} = "$address->{host}:$address->{port}";
    $address->{packed} = pack_sockaddr_in($address->{port}, $address->{addr});
}

sub parse_address {
    my ($class, $str, $context, %options) = @_;

    my $resolve = delete $options{resolve};
    my (@matches, @modes);
    my $regex = "";
    for my $mode (qw(from to)) {
        defined(my $types = delete $options{$mode}) || next;
        my $r = build_parser($mode, $types, \@matches);
        $regex = $regex eq "" ? $r : "(?:$regex:)?$r";
        push @modes, $mode;
    }
    die "Unknown option " . join(", ", map "'$_'", sort keys %options) if %options;
    my @matched = $str =~ /^$regex\z/ or
        die "Could not parse $context '$str'\n";
    my %matches;
    for my $i (0..$#matched) {
        defined(my $matched = $matched[$i]) || next;
        my ($mode, $type) =
            @{$matches[$i] || die "Assertion: Impossible match"};
        my @parts = $matched =~ $parse_regex{$type};
        if ($type eq "udp4" || $type eq "tcp4") {
            if (!defined $parts[0]) {
                $parts[0] = $default_bind;
            } elsif ($parts[0] eq "") {
                $parts[0] = $mode eq "from" ? "0.0.0.0" : "127.0.0.1";
            } elsif ($parts[0] eq "*") {
                # die "Cannot connect to the $context '*'" if $mode eq "to";
                $parts[0] = "0.0.0.0";
            }
            if (!defined $parts[1] || $parts[1] eq "") {
                # die "Missing $context port" if $mode eq "to";
                $parts[1] = "0";
            }
            $matches{$mode} = {
                type	=> $type,
                family	=> AF_INET,
                host	=> $parts[0],
                port	=> $parts[1],
                user	=> $matched,
                display	=> "$parts[0]:$parts[1]",
            };
            $class->resolve($matches{$mode}, $context) if $resolve;
        } else {
            die "Assertion: Type '$type' not implemented";
        }
    }
    my @result = @matches{@modes} or die "Assertion: No modes";
    if (@result == 2 && !defined $result[0]) {
        # Both from and to but no from part given
        my $type = $result[1]{type};
        my $from = $from_defaults{$type} ||
            die "$context: No default from for type '$type'";
        $result[0] = parse_address($from, $context, from => $type, resolve => $resolve);
    }
    return @result if wantarray;
    croak "Cannot return multiple results in a scalar" if @result != 1;
    return $result[0];
}

sub address_from_packed {
    my ($class, $packed, $type) = @_;

    my ($port, $addr) = unpack_sockaddr_in($packed);
    my $host = inet_ntoa($addr);
    return {
        type	=> $type,
        family	=> AF_INET,
        packed	=> $packed,
        addr	=> $addr,
        host	=> $host,
        port	=> $port,
        display	=> "$host:$port",
    };
}

sub socket_udp_connected {
    my ($class, $host, $port) = @_;

    $port = $port =~ /^0\z|^[1-9][0-9]*\z/ ? int($port) :
        getservbyname($port, "udp") || die "Unknown UDP service '$port'";
    my $addr = inet_aton($host) || die "Could not resolve '$host'";
    socket(my $socket, PF_INET, SOCK_DGRAM, $PROTO_UDP) ||
        die "Could not create UDP socket: $^E";
    my $remote = pack_sockaddr_in($port, $addr);
    connect($socket, $remote) || die "Could not connect socket: $^E";
    $socket->blocking(0);

    wantarray || return $socket;

    my $sockaddr = getpeername($socket) ||
        die "Assertion: Could not getpeername: $^E";
    my ($p, $address) = unpack_sockaddr_in($sockaddr);
    my $h = inet_ntoa($address);
    return $h, $p, $socket;
}

sub socket_udp {
    my ($class, $host, $port, $probe) = @_;

    $port = $port =~ /^0\z|^[1-9][0-9]*\z/ ? int($port) :
        getservbyname($port, "udp") || die "Unknown UDP service '$port'";
    my $addr = inet_aton($host) || die "Could not resolve '$host'";
    socket(my $socket, PF_INET, SOCK_DGRAM, $PROTO_UDP) ||
        die "Could not create UDP socket: $^E";
    my $local = pack_sockaddr_in($port, $addr);
    if ($probe) {
        return 1 if bind($socket, $local);
        $! == EADDRINUSE || die "Could not bind socket: $^E";
        return 0;
    }
    bind($socket, $local) || die "Could not bind socket: $^E";
    $socket->blocking(0);
    wantarray || return $socket;

    my $sockaddr = getsockname($socket) ||
        die "Assertion: Could not getsockname: $^E";
    my ($p, $address) = unpack_sockaddr_in($sockaddr);
    my $h = inet_ntoa($address);
    return $h, $p, $socket;
}

sub socket_tcp {
    my ($class, $host, $port, $listen) = @_;

    $port ||= "0";
    $port = $port =~ /^0\z|^[1-9][0-9]*\z/ ? int($port) :
        getservbyname($port, "tcp") || die "Unknown TCP service '$port'";
    $host = "0.0.0.0" if !defined $host || $host eq "";
    my $addr = inet_aton($host) || die "Could not resolve '$host'";
    socket(my $socket, PF_INET, SOCK_STREAM, $PROTO_TCP) ||
        die "Could not create TCP socket: $^E";
    my $local = pack_sockaddr_in($port, $addr);
    if ($listen) {
        setsockopt($socket, SOL_SOCKET, SO_REUSEADDR, 1) ||
            die "Assertion: Could not setsockopt(SOL_SOCKET, SO_REUSEADDR): $^E";
        bind($socket, $local) || die "Could not bind socket: $^E";
        listen($socket, $LISTEN_BACKLOG) || die "Could not listen: $^E";
    } elsif (defined $listen) {
        bind($socket, $local) || die "Could not bind socket: $^E";
    } else {
        # This is a blocking connect
        connect($socket, $local) || die "Could not connect to $host:$port: $^E";
        setsockopt($socket, IPPROTO_TCP, TCP_NODELAY,1) ||
            die "Couldn't disable Nagle's algorithm: $^E";
    }
    $socket->blocking(0);
    wantarray || return $socket;

    my $sockaddr = getsockname($socket) ||
        die "Assertion: Could not getsockname: $^E";
    my ($p, $address) = unpack_sockaddr_in($sockaddr);
    my $h = inet_ntoa($address);
    return $h, $p, $socket;
}

sub socket_icmp {
    my ($class, $host, $id) = @_;

    $host = "0.0.0.0" if !defined $host;
    $id = 0 if !defined $id;

    $id =~ /^0\z|^[1-9][0-9]*\z/  || die "Invalid id '$id'";
    my $addr = inet_aton($host) || die "Could not resolve '$host'";
    socket(my $socket, PF_INET, SOCK_DGRAM, $PROTO_ICMP) || do {
        return if $! == EPROTONOSUPPORT || $! == EACCES;
        die "Could not create ICMP socket: $^E";
    };
    my $local = pack_sockaddr_in($id, $addr);
    bind($socket, $local) || die "Could not bind socket: $^E";
    $socket->blocking(0);
    wantarray || return $socket;

    my $sockaddr = getsockname($socket) ||
        die "Assertion: Could not getsockname: $^E";
    my ($i, $address) = unpack_sockaddr_in($sockaddr);
    my $h = inet_ntoa($address);
    return $h, $i, $socket;
}

package Object;
use Scalar::Util qw(weaken);
use Carp qw(croak);

sub new {
    my $class  = shift;
    my $parent = shift || croak "No parent";

    @_ % 2 == 0 || croak "Odd number of arguments";

    $parent->bug("Attempt to add '$class' child to cleaned Object") if $parent->{finished};
    my $object= bless {
        @_,
        deleted	=> 0,
        cleaned	=> 0,
        parent	=> $parent,
    }, $class;
    weaken($object->{parent});
    if (defined $object->{id}) {
        # Caller managed IDs
        die "Assertion: Inconsistent id usage" if $parent->{ids}{$class};
        die "Assertion: ", ref $object, "[$object->{id}] already exists" if
            $parent->{children}{$class}[$object->{id}];
    } else {
        # Local managed IDs
        $object->{id} = ($parent->{ids}{$class} ||= Ids->new)->id_alloc;
    }
    $object->{id_full} = $parent->{id_full} ? "$parent->{id_full}:$object->{id}": "$object->{id}";
    $parent->{children}{$class}[$object->{id}] = $object;

    $object->info("CREATE") if $verbose > 2;

    return $object;
}

# Remove the obect from the Object tree. This usually will lead to
# the Object being destroyed but it can linger if anyone has a reference
# So you can't depend on this call doing an implicit finish()
sub delete : method {
    my $object = shift;

    if ($object->{deleted}) {
        die "Double delete on '@_'" if $object->{deleted} > 0;
        die "Recursive delete on '@_' [", ::callers(), "]";
    }
    $object->{deleted} = -1;
    $object->finish(@_) unless $object->{finished};
    $object->_delete(@_);
    $object->{deleted} = 1;
}

sub _delete {
    my $object = shift;

    my $ids = $object->{parent}{ids}{ref $object};
    $ids->id_free($object->{id}) if $ids;
    delete $object->{parent}{children}{ref $object}[$object->{id}];
}

# Neuter the obect. From here on it shouldn't do anything anymore
# It will however remain in the object tree. This is typically used
# to wait for remote finish of its mutual partner which in turn is
# important to make sure the id isn't reused until all messages stop
sub finish {
    my $object = shift;

    if ($object->{finished}) {
        $object->bug("Double finish on '@_'") if $object->{finished} > 0;
        $object->bug("Recursive finish on '@_'");
    }
    $object->{finished} = -1;
    if (my $children = $object->{children}) {
        for my $class (sort keys %$children) {
            $_ && $_->delete(@_) for @{$children->{$class}};
        }
        %$children = ();
    }
    $object->_finish(@_);
    $object->{finished} = 1;
}

sub _finish {
    delete shift->{timeout};
}

sub die : method {
    my ($object, $msg) = @_;

    $object->info("DIE: $msg") if $verbose > 1;
    $object->delete($msg) unless $object->{deleted};
    die sprintf("%s: %s [%s]\n", $object->name, $msg, ::callers());
}

sub dump : method {
    my ($object) = @_;
    local $object->{parent};
    print STDERR ::Dumper($object);
}

sub bug {
    my ($object, $msg) = @_;

    $object->die("Assertion: $msg");
}

sub error {
    my $object = shift;
    $object->die(@_);
}

sub id {
    return shift->{id};
}

sub id_full {
    return shift->{id_full};
}

sub name {
    my ($object) = @_;

    return sprintf("%s[%s]", ref $object, $object->{id_full});
}

sub child {
    my ($object, $class, $id) = @_;
    return $object->{children}{$class}[$id];
}

sub info {
    my $object = shift;
    my $format = shift;
    if (!@_) {
        @_ = ($format);
        $format = "%s";
    }
    unshift @_, "%s: " . $format, $object->name;
    goto &::info;
}

sub caller_info {
    my $object = shift;
    my $format = shift;
    if (@_) {
        @_ = ("%s: $format [%s]", $object->name, @_, ::callers());
    } else {
        @_ = ("%s: %s [%s]", $object->name, $format, ::callers());
    }
    goto &::info;
}

sub immediate {
    my ($object, $code) = @_;
    $object->{timeout} = Timer::immediate($object, $code);
}

sub count_children {
    my ($object, $class) = @_;

    local $object->{parent};
    return $object->{ids}{$class}->count if $object->{ids} && $object->{ids}{$class};
    $object->{children} && $object->{children}{$class} || return 0;
    return scalar grep defined, @{$object->{children}{$class}};
}

sub status_all {
    my ($object, $control, $indent) = @_;

    $object->status($control, $indent);
    $indent .= "  ";
    for my $class (sort keys %{$object->{children} || {}}) {
        my @objects = grep defined, @{$object->{children}{$class}} or next;
        $control->{out} .= sprintf("%s%s: %s\n",
                                   $indent, $class, scalar @objects);
        $_->status($control, $indent) for @objects;
    }
}

sub status {
}

package Root;
use vars qw(@ISA);
@ISA = qw(Object);

use Carp qw(croak);

my $BASE_TIME  = Timer->realtime();
my $BASE_CLOCK = Timer->clocktime();
my $root = 0;

sub new {
    my $class = shift;

    @_ % 2 == 0 || croak "Odd number of arguments";

    my $root = bless {
        @_,
        id		=> 0,
        id_full		=> "0",
        settings	=> { %settings_global },
        timeout		=> undef,
        signals		=> {},
    }, $class;
    $root->info("CREATE") if $verbose > 2;
    return $root;
}

sub status {
    my ($root, $control, $indent) = @_;

    #local $Data::Dumper::Varname = "VAR";
    #my $settings = ::Dumper($line->{settings});
    #$settings =~ s/\$VAR1 = //g || die "Assertion: No VAR1";
    #$settings =~ s/\s+\z//;
    my $name = $root->name;
    my $settings = ::string_from_value($root->{settings});
    $settings =~ s/\n/\n$indent  /g;

    $control->{out} .= <<"EOF"
$indent$name
$indent  Settings: $settings
EOF
        ;
}

sub _finish {
    my $root = shift;

    delete $root->{signals};
    $root->SUPER::_finish(@_);
}

sub signal_add0 {
    my ($root, $sig_name, $code) = @_;

    $root->die("Already have signal '$sig_name'") if $root->{signals}{$sig_name};
    $root->{signals}{$sig_name} = Signal::add0($sig_name, $root, $code);
}

sub global_timeout {
    ::info("Global timeout") if $verbose;
    ::_cleanup_all();
    # The cleanup of the globals above should be enough to fall off mainloop
    # $exit = 1;
    # exit $exit;
}

sub timeout {
    my ($root, $timeout) = @_;

    $root->{timeout} = Timer::timer0($timeout, $root, \&global_timeout);
    alarm($timeout+3);
}

sub client {
    my ($root, $socket_in, $socket_out, $connections, $client_only) = @_;

    my $line;
    eval {
        $line = LineProtocol->new(
            $root, $socket_in, $socket_out,
            client_only	=> $client_only,
        );

        for my $tcp (@{$connections->{tcp_local}}) {
            my ($from, $to) = ConnUtils->parse_address($tcp, "TCP local", from => "TCP4", to => "TCP4");
            ConnUtils->resolve($from, "TCP local");
            Listener::TCP::Local->new_suspended($line, $from, -1, remote => $to);
        }
        for my $udp (@{$connections->{fou_local}}) {
            my ($from, $to) =
                $udp =~ m{^([^%]+)%([^%]+)\z} or
                die "Invalid fou_local '$udp'";
            $from = ConnUtils->parse_address($from, "FOU local", from => "UDP4");
            $to   = ConnUtils->parse_address($to  , "FOU local", to   => "UDP4", resolve => 1);
            my $fou = Fou::UDP->new($to);
            Receiver::Fou->new_suspended($line, $from->{host}, $from->{port}, $fou);
        }

        for my $name (sort keys %{$line->{settings}}) {
            if ($name eq "EPOCH") {
                $line->set_peer($name => $BASE_TIME);
            } elsif ($name eq "MSGHDR") {
                $line->set_peer($name => $msghdr_error || Socket::MsgHdr->VERSION);
            } else {
                $line->set_peer($name => $line->{settings}{$name});
            }
        }

        for my $udp (@{$connections->{fou_remote}}) {
            my ($from, $to) =
                $udp =~ m{^([^%]+)%([^%]+)\z} or
                die "Invalid fou_remote '$udp'";
            # Pure syntax check, resolving will be done remotely
            ConnUtils->parse_address($from, "FOU remote", from => "UDP4");
            ConnUtils->parse_address($to  , "FOU remote", to   => "UDP4");
            $line->write($FOU_REMOTE, $udp);
        }
        $line->write($START);
    };
    die "\u$role: $@" if $@;
    return $line;
}

sub server {
    my ($root, $socket_in, $socket_out) = @_;

    my $line;
    eval {
        $line = LineProtocol->new($root, $socket_in, $socket_out);

        $line->set_peer(EPOCH	 => $BASE_TIME);
        $line->set_peer(MSGHDR	 => $msghdr_error || Socket::MsgHdr->VERSION);
    };
    die "\u$role: $@" if $@;
    return $line;
}

package Connection;
use vars qw(@ISA);
@ISA = qw(Object);

# We could put a "new" method here setting finished_local and finished_remote
# to undef, but not all Streams are actually associated with another object
# at the other end of a LineProtocol (e.g. Pinger and Control aren't)

# If socket_in and socket_out are genuinly different it is the
# responsibity of the caller to shutdown() the write and read sides
# (if needed. pipes don't need it for example)
sub new {
    my $class = shift;
    return $class->SUPER::new(
        shift,
        socket_in	=> shift,
        socket_out	=> shift,
        reader		=> undef,
        writer		=> undef,
        timeout		=> undef,
        in		=> "",
        out		=> "",
        @_,
    );
}

sub _delete {
    my $connection = shift;
    $connection->SUPER::_delete(@_);
    ::cleanup_all() if $connection->{exit};
}

sub _finish {
    my $connection = shift;

    delete @$connection{qw(in out reader writer socket_in socket_out)};
    $connection->SUPER::_finish(@_);
}

sub write_end {
    my $connection = shift;

    $connection->info("Finished writing. Will now delete($connection->{reason})");
    $connection->delete($connection->{reason} || "Unknown reason");
}

sub _delete_on_flushed {
    my $connection = shift;

    $connection->{reason} = "@_";
    if ($connection->{out} eq "") {
        $connection->write_end;
    } else {
        $connection->{on_written} = $connection->can("write_end") ||
            $connection->bug("Cannot write_end");
    }
}

sub delete_on_flushed {
    my $connection = shift;

    delete @$connection{qw(socket_in reader)};
    # In case we are called during a naive loop on $connection->{in} we want
    # to automatically drop out
    $connection->{in} = "" if defined $connection->{in};
    $connection->_delete_on_flushed(@_);
}

# Remote tells us it is finished
sub finished_remote {
    my ($connection, $reason) = @_;

    $connection->die("Already finished remote") if $connection->{finished_remote};
    $reason ||= "Unknown reason";
    $connection->info("Finished remote: $reason") if $verbose > 1;
    $connection->{finished_remote} = $reason = "Remote: $reason";
    if ($connection->{finished}) {
        $connection->delete($reason);
    } else {
        $connection->finish_local($reason);
    }
}

# Tell remote to finish. This probably involves sending a message to the remote,
# which will be different for each type of Object, so no implementation here
sub finish_remote {
    shift->bug("finish_remote not implemented (yet)");
}

# Start cleaning up locally
sub finished_local {
    my ($connection, $reason) = @_;

    $connection->info("Finished local: $reason") if $verbose;
    $connection->die("Already finished local") if $connection->{finished};
    if ($connection->{finished_remote}) {
        $connection->delete($reason);
    } else {
        $connection->finish_remote($reason);
        $connection->finish($reason);
    }
}

# Tell local to finish. This probably involves flushing the output queue,
# which will be different for each type of Object, so no implementation here
sub finish_local {
    shift->bug("finish_local not implemented (yet)");
}

package _Stream;
use vars qw(@ISA);
@ISA = qw(Connection);

use Errno qw(EINTR EAGAIN EWOULDBLOCK ECONNRESET);

# Leave the option open to redirect conn_reset() to eof()
# If you do don't forget to deactivate events (reader, writer, timeout etc)
sub conn_reset {
    my $stream = shift;

    $stream->error(@_);
}

sub eof : method {
    my $stream = shift;

    $stream->info("@_") if $verbose > 1;
    $stream->delete(@_);
}

sub reader {
    my ($stream) = @_;

    my $rc = sysread($stream->{socket_in}, my $buffer, $BLOCK_SIZE);
    if (!$rc) {
        if (defined $rc) {
            # EOF
            $stream->{reader} = undef;
            $stream->eof("EOF");
        } else {
            return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK;
            $stream->error("Could not sysread: $^E") if $! != ECONNRESET;
            $stream->conn_reset("Connection reset by peer");
        }
        return;
    }
    $stream->info("Received: %s", ::display($buffer)) if $verbose > 1;
    $stream->{in} .= $buffer;
    $stream->on_read($rc);
}

sub timeout {
    shift->error("Write timeout");
}

sub write : method {
    my $stream = shift;

    my $was_empty = $stream->{out} eq "";
    $stream->{out} .= join("", @_);
    $was_empty && $stream->{out} ne "" || return;
    $stream->writing();
}

sub writer {
    my ($stream) = @_;

    my $rc = syswrite($stream->{socket_out}, $stream->{out}, $BLOCK_SIZE);
    if (!$rc) {
        $stream->die("Zero write. Is this even possible ?") if defined $rc;
        return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK;
        $stream->error("Could not syswrite: $^E");
        return;
    }

    $stream->info("Wrote: %s (%d left)",
                  ::display(substr($stream->{out}, 0, $rc)),
                  length($stream->{out}) - $rc) if $verbose > 1;

    substr($stream->{out}, 0, $rc, "");
    if ($stream->{out} eq "") {
        $stream->{writer}  = undef;
        $stream->{timeout} = undef;
        $stream->{on_written}->($stream, $stream->{reason}) if $stream->{on_written};
        return;
    }
    $stream->writing();
}

package Stream;
use vars qw(@ISA);
@ISA = qw(_Stream);

sub new {
    my $class = shift;
    my $stream = $class->SUPER::new(@_);
    $stream->{reader} = Events::add_read($stream->{socket_in}, $stream, \&_Stream::reader) if $stream->{socket_in};
    return $stream;
}

sub writing {
    my ($stream) = @_;

    # This assumes parent == LineProtocol (or Root). Doesn't generalize
    $stream->{writer} ||= Events::add_write($stream->{socket_out}, $stream, \&_Stream::writer);
    $stream->{timeout} = Timer::timer($stream->{parent}{settings}{TIMEOUT}, $stream, \&_Stream::timeout);
}

package Stream0;
use vars qw(@ISA);
@ISA = qw(_Stream);

sub new {
    my $class = shift;
    my $stream = $class->SUPER::new(@_);
    $stream->{reader} = Events::add_read0($stream->{socket_in}, $stream, \&_Stream::reader) if $stream->{socket_in};
    return $stream;
}

sub writing {
    my ($stream) = @_;

    # This assumes parent == LineProtocol (or Root). Doesn't generalize
    $stream->{writer} ||= Events::add_write0($stream->{socket_out}, $stream, \&_Stream::writer);
    $stream->{timeout} = Timer::timer($stream->{parent}{settings}{TIMEOUT}, $stream, \&_Stream::timeout);
}

package Connect;
use vars qw(@ISA);
@ISA = qw(Stream);

use Errno qw(EINPROGRESS EWOULDBLOCK);
use Socket qw(SOL_SOCKET SO_ERROR);

sub new {
    my $class  = shift;
    my $parent = shift;
    my $from   = shift;
    my $to     = shift;

    my $socket = ConnUtils->socket_tcp($from->{host}, $from->{port}, 0);
    # pass undef for socket_in. This avoid reader being started by Stream
    my $connect = $class->SUPER::new(
        $parent, undef, $socket,
        peer	=> $to,
        local	=> undef,
        @_,
    );
    if (connect($socket, $to->{packed})) {
        # Immediate connect
        $connect->{timeout} = Timer::immediate($connect, \&on_connect);
    } elsif ($! == EINPROGRESS || $! == EWOULDBLOCK) {
        $connect->info("Connecting to '$to->{user}' [$to->{display}]") if $verbose > 1;
        $connect->{writer} = Events::add_write0($connect->{socket_out}, $connect, \&connected);
        $connect->{timeout} = Timer::timer($connect->{parent}{settings}{TIMEOUT}, $connect, \&connection_timeout);
    } else {
        $connect->error("Could not connect to '$to->{user}' [$to->{display}]: $^E");
    }
    return $connect;
}

sub connection_timeout {
    my ($connect) = @_;

    $connect->error("Timeout connecting to '$connect->{peer}{user}' [$connect->{peer}{display}]");
}

sub connected {
    my ($connect) = @_;

    $connect->{writer} = undef;
    # on_connect will set timeout to undef
    # $connect->{timeout} = undef;

    my $packed = getsockopt($connect->{socket_out}, SOL_SOCKET, SO_ERROR) ||
        $connect->bug("Could not getsockopt(SOL_SOCKET, SO_ERROR): $^E");
    my $err = $! = unpack("I", $packed);
    if ($err) {
        $connect->error("Could not connect to '$connect->{peer}{user}' [$connect->{peer}{display}]: $!");
        return;
    }
    $connect->on_connect();
}

sub on_connect {
    my ($connect) = @_;

    $connect->{timeout} = undef;

    my $sockaddr = getsockname($connect->{socket_out}) ||
        die "Assertion: Could not getsockname: $^E";
    $connect->{local} = ConnUtils->address_from_packed($sockaddr, "tcp4");
    $connect->info("Connected from '$connect->{local}{display}' to '$connect->{peer}{user}' [$connect->{peer}{display}]: $!") if $verbose;

    $connect->{socket_in} = $connect->{socket_out};
    $connect->{reader} = Events::add_read($connect->{socket_in}, $connect, \&_Stream::reader);
    $connect->writing if $connect->{out} ne "";
}

package _UDP;
use vars qw(@ISA);
@ISA = qw(Connection);

use Errno qw(EINTR EAGAIN EWOULDBLOCK EMSGSIZE);
use Socket qw(pack_sockaddr_in unpack_sockaddr_in inet_ntoa
              MSG_TRUNC MSG_CTRUNC);

sub new_suspended {
    my $class = shift;

    my $udp = $class->SUPER::new(
        shift, shift, shift,
        out => [],
        @_,
    );
    return $udp;
}

sub new {
    my $class = shift;
    my $udp = $class->new_suspended(@_);
    $udp->resume_read if $udp->{socket_in};
    return $udp;
}

sub reader {
    my ($udp) = @_;

    my ($sockaddr, $bufref, $ttl);
    if ($msghdr) {
        $msghdr->{name} = "\0" x 256;
        $msghdr->{buf}  = "\0" x $UDP_SIZE;
        $msghdr->{control} = "\0" x 256;
        $msghdr->{flags} = 0;
        if (defined ::recvmsg($udp->{socket_in}, $msghdr)) {
            # I suspect Socket::MsgHdr has a bug so that flags is never set
            $udp->die("Yikes! Buffer was truncated") if
                        $msghdr->flags & MSG_TRUNC;
            $udp->die("Yikes! Ancillary data was truncated") if
                $msghdr->flags & MSG_CTRUNC;
            $bufref = \$msghdr->{buf};
            $sockaddr = $msghdr->{name};
            my ($level, $type, $data) =
                ::unpack_cmsghdr($msghdr->{control}) or
                $udp->bug("No ancillary data from socket");
            $level == $IPPROTO_IP ||
                $udp->bug("Unexpected level in ancillary data");
            $type == $IP_TTL ||
                $udp->bug("Unexpected type in ancillary data");
            $ttl = unpack("I", $data);
        }
    } else {
        $sockaddr = recv($udp->{socket_in}, my $buffer, $UDP_SIZE, 0);
        $bufref = \$bufref;
        $ttl = $TTL;
    }
    if (!defined $sockaddr) {
        return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK;
        $udp->error("Could not receive: $^E");
        return;
    }
    # No special handling for length 0.
    # It's perfectly fine to send and receve empty UDP packets
    my ($port, $addr) = unpack_sockaddr_in($sockaddr);
    $udp->info("Received from %s:%d%s: %s",
               inet_ntoa($addr), $port, $msghdr ? " (TTL $ttl)" : "",
               ::display($$bufref)) if $verbose > 1;
    $udp->on_read($addr, $port, $ttl, $bufref);
}

sub timeout {
    shift->error("Send timeout");
}

sub writing {
    my ($udp) = @_;

    # This assumes parent == LineProtocol (or Root). Doesn't generalize
    $udp->{writer} ||= Events::add_write($udp->{socket_out}, $udp, \&writer);
    $udp->{timeout} = Timer::timer($udp->{parent}{settings}{TIMEOUT}, $udp, \&timeout);
}

sub write : method {
    # @_ = ($udp, $port, $addr, $data, $ttl) if no $udp->{to}
    # @_ = ($udp, $data, $ttl)               if    $udp->[to}
    my $udp = shift;

    return if 1 != push @{$udp->{out}}, $msghdr ?
        bless {
            name => $udp->{to} || pack_sockaddr_in(shift, shift),
            buf  => shift,
            control => ::pack_cmsghdr(
                $IPPROTO_IP,
                $IP_TTL,
                pack("I", shift || die "Assertion: TTL 0")),
            flags => 0,
        }, "Socket::MsgHdr" :
        [$udp->{to} || pack_sockaddr_in(shift, shift), shift];
    $udp->writing;
}

sub writer {
    my ($udp) = @_;

    my $data = $udp->{out}[0];
    if ($msghdr) {
        my $rc = ::sendmsg($udp->{socket_out}, $data);
        if (!defined $rc) {
            return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK;
            if ($! == EMSGSIZE) {
                $udp->info("Cannot send oversized packet. Dropped") if $verbose > 1;
                goto DROP;
            }
            $udp->error("Could not send: $^E");
            return;
        }
        if ($verbose > 1) {
            my ($port, $addr) = unpack_sockaddr_in($data->{name});
            $udp->info("Wrote data (TTL %d) to %s:%d (%d left): %s",
                       unpack("I",(::unpack_cmsghdr($udp->{out}[0]->{control}))[2]),
                       inet_ntoa($addr), $port, length($data->{buf}) - $rc,
                       ::display(substr($data->{buf}, 0, $rc)));
        }
        $rc == length($data->{buf}) ||
            $udp->bug("Incomplete send ($rc of " . length($data->{buf}) . ")");
    } else {
        my $rc = send($udp->{socket_out}, $data->[1], 0, $data->[0]);
        if (!defined $rc) {
            return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK;
            if ($! == EMSGSIZE) {
                $udp->info("Cannot send oversized packet. Dropped") if $verbose > 1;
                goto DROP;
            }
            $udp->error("Could not send: $^E");
            return;
        }
        if ($verbose > 1) {
            my ($port, $addr) = unpack_sockaddr_in($data->[0]);
            $udp->info("Wrote to %s:%d: %s (%d left)",
                       inet_ntoa($addr), $port,
                       ::display(substr($data->[1], 0, $rc)),
                       length($data->[1]) - $rc);
        }
        $rc == length($data->[1]) ||
            $udp->bug("Incomplete send ($rc of " . length($data->[1]) . ")");
    }

  DROP:
    shift @{$udp->{out}};
    if (@{$udp->{out}}) {
        $udp->writing;
    } else {
        $udp->{writer}  = undef;
        $udp->{timeout} = undef;
    }
}

package UDP;
use vars qw(@ISA);
@ISA = qw(_UDP);

sub new_suspended {
    my $class = shift;

    my $udp = $class->SUPER::new_suspended(@_);
    if ($udp->{socket_in}) {
        !$msghdr ||
            setsockopt($udp->{socket_in}, $IPPROTO_IP, $IP_RECVTTL, 1) ||
            $udp->die("setsockopt(IPPROTO_IP, IP_RECVTTL): $^E");
    }
    return $udp;
}

sub resume_read {
    my $udp = shift;

    $udp->info("resume_read") if $verbose > 1;
    $udp->{reader} && $udp->die("Read not suspended");
    $udp->{reader} = Events::add_read($udp->{socket_in}, $udp, \&_UDP::reader);
}

package Pinger;
use vars qw(@ISA);
# We maybe should introduce a StreamReader for only the read part of Stream
@ISA = qw(Stream);

use Scalar::Util qw(weaken);
use Socket qw(inet_aton);
use POSIX qw(_exit);

{
    my @queued;
    sub queue {
        my ($class, $icmp) = @_;

        # $icmp->info("Queue on Pinger, set pending=1");
        die "Assertion: Already pending" if $icmp->{pending};
        weaken($queued[@queued] = $icmp);
        $icmp->{pending} = 1;
    }

    sub activate_ping {
        # ::caller_info("Pinger::activate_ping, queued=%d, ping_max=%d", scalar @queued, $ping_max);
        while (@queued && $ping_max > 0) {
            my $icmp = shift @queued || next;
            $icmp->unqueue_ping();
        }
    }
}

sub new {
    my ($class, $icmp, $host, $data) = @_;

    $ping_max > 0 || die "Assertion: Ping max $ping_max > 0";

    pipe(my $rd0, my $wr0) || die "Could not open pipe: $^E";
    pipe(my $rd1, my $wr1) || die "Could not open pipe: $^E";

    defined(my $pid = fork()) || die "Could not fork: $^E";
    if ($pid == 0) {
        # Child
        select($wr1);
        $| = 1;
        eval {
            close($rd0) || die "Could not close pipe: $^E";
            close($rd1) || die "Could not close pipe: $^E";
            open(STDIN,  "<&", $null) || die "Could not dup to STDIN: $^E";
            open(STDOUT, ">&", $wr0)  || die "Could not dup to STDOUT: $^E";
            close($wr0) || die "Could not close pipe: $^E";
            # open(STDERR, ">&STDOUT")  || die "Could not dup to STDERR: $^E";
            $SIG{CHLD} = "DEFAULT";
            no warnings "exec";
            exec(@{$PING[0]}, $host, @{$PING[1]}) ||
                die "Could not exec $PING[0][0]: $^E";
        };
        print $@ || "Assertion: Pinger ended without error\n";
        _exit(1);
    }

    # Parent
    close($wr0) || die "Could not close pipe: $^E";
    close($wr1) || die "Could not close pipe: $^E";
    $rd0->blocking(0);
    $rd1->blocking(0);

    # if (!defined $icmp || ref $icmp ne "Sender::ICMP") {
    #    ::caller_info("BAD ICMP");
    #    die "Boem";
    #}
    #if (!defined $icmp->{parent} || ref $icmp->{parent} ne "LineProtocol") {
    #    ::caller_info("Bad LineProtocol");
    #    die "Boem";
    #}
    my $pinger = $class->SUPER::new(
        $icmp, $rd1, undef,
        waitable	=> undef,
        handle		=> $rd0,
        pid		=> $pid,
        parent_pid	=> $$,
        host		=> $host,
        data		=> $data);

    $pinger->info("waiting to spawn ping '%s'",
                  $pinger->{host}) if $verbose > 1;
    # $pinger->info("Created");

    return $pinger;
}

sub wait : method {
    return if defined $SIG{CHLD} && $SIG{CHLD} eq "IGNORE";
    my ($pinger) = @_;

    my $pid = $pinger->{pid};
    return if $pinger->{parent_pid} != $$ || !$pid;
    $pinger->{pid} = undef;
    my $p = waitpid($pid, 0);
    if ($p != $pid) {
        die "Could not wait for pid '$pid'" if $p < 0;
        die "Assertion: Invalid pid result" if $p != $pid;
    }
    die "Unexpected exitcode $? from ping $pinger->{host} (pid $pid)" if $?;
}

sub eof : method {
    my $pinger = shift;

    if ($pinger->{handle}) {
        # Read from the probe pipe
        $pinger->{socket_in} = delete $pinger->{handle};
        if ($pinger->{in} ne "") {
            $pinger->wait;
            $pinger->die($pinger->{in});
        }
        $pinger->{reader} = Events::add_read($pinger->{socket_in}, $pinger, \&_Stream::reader);
        $pinger->info("Spawned. Switch to reading ping result") if $verbose > 1;
        return;
    }

    $pinger->{waitable} = 1;
    my $icmp = $pinger->{parent};
    if (my ($ip, $ttl, $time) =
        $pinger->{in} =~ /from (\d+\.\d+\.\d+\.\d+).* icmp_[sr]eq.* ttl=(\d+).* time=(\S+ (?:ms|usec))/) {
        $pinger->info("Response from '%s' ttl=%d, time=%s",
                      $ip, $ttl, $time) if $verbose > 1;
        $ip eq $pinger->{host} ||
            $pinger->bug("Inconsistent: pinged '$pinger->{host}', got aswer from '$ip'");
        $icmp->{parent}->write($RESPONSE_PING, pack("wa4C", $icmp->{id}, inet_aton($pinger->{host}), $ttl-1), $pinger->{data}) if $ttl > 1;
    } elsif ($verbose > 1) {
        if ($pinger->{in} eq "") {
            $pinger->info("No response from '%s'",
                          $pinger->{host}) if $verbose > 1;
        } else {
            $pinger->info("No result in response from '%s': %s",
                          $pinger->{host}, ::display($pinger->{in})) if $verbose > 1;
        }
    }
    $pinger->delete("Ping result");
}

sub _finish {
    my $pinger = shift;

    $pinger->wait if $pinger->{waitable};
    $pinger->SUPER::_finish(@_);

    # $pinger->caller_info("delete");
    my $icmp = $pinger->{parent};
    # Avoid new pings being started during finish in fork children
    $icmp->{pid} == $$ || return;
    my $line = $icmp->{parent};

    --$line->{nr_pingers};
    ++$ping_max;
    Pinger->activate_ping;
    $line->activate_ping;
}

sub on_read {
    # Process neiher the probe pipe nor the result pipe during read
    # We could check for insanely long output here
}

package Sender::ICMP;
use vars qw(@ISA);
@ISA = qw(UDP);

use Socket qw(inet_ntoa);

sub new_suspended {
    my ($class, $line, $id) = @_;

    # Notice this can return nothing if we can't open an UDP icmp socket
    # (either not supported on OS or user not in allowed grooup)
    my ($host, $icmp_id, $socket) = ConnUtils->socket_icmp("0.0.0.0", 0);
    !$msghdr || !$socket || setsockopt($socket, $IPPROTO_IP, $IP_RECVTTL, 1) ||
        die "setsockopt(IPPROTO_IP, IP_RECVTTL): $^E";
    # ICMP_FILTER always gets me ENOPROTOOPT
    # However when /bin/ping does it (when sysctl group NOT set) it works???
    # !$socket || setsockopt($socket, $SOL_RAW, $ICMP_FILTER, 0xffffffff ^ 1<<$ICMP_ECHO_REPLY) ||
    #    die "setsockopt(SOL_RAW, ICMP_FILTER): $^E" if defined $ICMP_FILTER;

    my $icmp = $class->SUPER::new_suspended(
        $line, $socket, $socket,
        id		=> $id,
        pid		=> $$,
        local_host	=> $host,
        icmp_id		=> $icmp_id,
        pending		=> 0);

    if ($verbose > 1) {
        if ($socket) {
            $icmp->info("New ICMP socket '%s:%d'", $host, $icmp_id);
        } else {
            $icmp->info("Using external ping");
        }
    }

    return $icmp;
}

sub on_read {
    my ($icmp, $addr, $port, $ttl, $bufref) = @_;

    # 16 bytes MD5, 4 bytes rand, 4 bytes src, 2 bytes id, 2 bytes seqno
    # and at least 1 fou_id byte
    length $$bufref >= $ICMP_HEADER + (16+4+4+2+2+1) || return;
    $$bufref .= "\0";
    my $sum = unpack("%32n*", $$bufref);
    my ($type, $code, $icmp_chksum, $icmp_id, $seqno) =
        unpack("wwn3", substr($$bufref, 0, $ICMP_HEADER, ""));
    chop $$bufref;
    if (1 || $icmp_chksum) {
        while ($sum > 0xffff) {
            my $carry = $sum >> 16;
            $sum &= 0xffff;
            $sum += $carry;
        }
        $sum == 0xffff || return;
    }
    $type == $ICMP_ECHO_REPLY || return;
    $code == 0 || return;

    $icmp->info("ICMP ECHO Payload (Type %d, Code %d, Id %d, Seqno %d) from %s: %s",
                $type, $code, $icmp_id, $seqno, inet_ntoa($addr),
                ::display($$bufref)) if $verbose > 1;
    $icmp->{parent}->write($RESPONSE_PING, pack("wa4C", $icmp->{id}, $addr, $ttl-1), $$bufref) if $ttl > 1;
}

sub write : method {
    # @_ = ($icmp, $dst, $seqno, $data, $ttl)
    my $icmp = shift;

    if (!$icmp->{socket_out}) {
        $icmp->info("Queue external ping %s", inet_ntoa($_[0])) if $verbose;
        # We could retry acquiring an ICMP socket here
        push @{$icmp->{out}}, [shift, shift, shift];
        $icmp->activate_ping;
        return;
    }

    my $dst = shift;
    $icmp->info("Need to send ICMP ECHO (Type %d, Code 0, Id %d, Seqno %d, TTL %d) to %s: %s",
                $ICMP_ECHO_REQUEST, $icmp->{icmp_id}, @_[0,2], inet_ntoa($dst),
                ::display($_[1])) if $verbose > 1;

    my $data = pack("Cx3n2a*x", $ICMP_ECHO_REQUEST, $icmp->{icmp_id},
                    shift, shift);
    my $sum = unpack("%32n*", $data);
    chop $data;
    while ($sum > 0xffff) {
        my $carry = $sum >> 16;
        $sum &= 0xffff;
        $sum += $carry;
    }
    substr($data, 2, 2, pack("n", 0xffff - $sum));
    $icmp->SUPER::write(0, $dst, $data, shift);
}

sub activate_ping {
    my ($icmp) = @_;

    # $icmp->caller_info("Try to activate ping size out=%d, ping_max=%d, pending=%d", scalar @{$icmp->{out}}, $ping_max, $icmp->{pending});
    return if $icmp->{pending};

    while (@{$icmp->{out}}) {
        if ($ping_max <= 0) {
            Pinger->queue($icmp);
            return;
        }

        my $line = $icmp->{parent};
        if ($line->{nr_pingers} >= $line->{settings}{PING_MAX}) {
            $line->queue_ping($icmp);
            return;
        }

        Pinger->new($icmp,
                    inet_ntoa($icmp->{out}[0][0]),
                    shift(@{$icmp->{out}})->[2]);
        ++$line->{nr_pingers};
        --$ping_max;
    }
}

sub unqueue_ping {
    my ($icmp) = @_;

    # $icmp->caller_info("Unqueue, set pending=0");
    $icmp->{pending} || die "Assertion: Not pending";
    $icmp->{pending} = 0;
    $icmp->activate_ping;
}

package Sender::UDP;
# Send out packets at the remote side (and wait for replies)
use vars qw(@ISA);
@ISA = qw(UDP);

sub new_suspended {
    my ($class, $line, $id) = @_;

    my ($host, $port, $socket) = ConnUtils->socket_udp("0.0.0.0", 0);

    my $sender = $class->SUPER::new_suspended(
        $line, $socket, $socket,
        id		=> $id,
        local_host	=> $host,
        local_port	=> $port);

    $sender->info("Local address '%s:%d'", $host, $port) if $verbose > 1;
    return $sender;
}

sub on_read {
    my $sender = shift;
    # Now: @_ = ($from_addr, $from_port, $ttl, $dataref)
    $sender->{parent}->write($RESPONSE_UDP, pack("wa4nC", $sender->{id}, shift, shift, shift()-1), ${shift()}) if $_[2] > 1;
}

package Receiver::Fou;
# Wait for packets at the local (client) side
use vars qw(@ISA);
@ISA = qw(UDP);

use Socket qw(inet_ntoa);
use Digest::MD5 qw(md5);

sub new_suspended {
    my ($class, $line, $host, $port, $fou) = @_;

    my ($h, $p, $socket) = ConnUtils->socket_udp($host, $port);

    my $listener = $class->SUPER::new_suspended(
        $line, $socket, undef,
        local_host	=> $h,
        local_port	=> $p,
        fou_id		=> $fou->id);

    $listener->info("Listening on  '%s:%d'", $h, $p) if $verbose > 1;
    return $listener;
}

sub on_read {
    # @_ = ($listener, $from_addr, $from_port, $ttl, $dataref)
    my ($listener, undef, undef, undef, $bufref) = @_;

    my ($ihl, $ecn, $length, $id, $fragment, $ttl, $proto, $chksum, $nsrc, $ndst) = unpack("CCnnnCCna4a4", $$bufref);
    if ($verbose > 2) {
        $listener->info(
            "TEMP: IHL=%d, ECN=%d, LEN=%d, ID=%d, FRAGMENT=%#04X, TTL=%d, PROTO=%d, CHK=%#04X, SRC=%s, DST=%s\n",
            $ihl, $ecn, $length, $id, $fragment, $ttl, $proto, $chksum,
            inet_ntoa($nsrc), inet_ntoa($ndst));
    }

    # Don't handle spammy multicast stuff (in my case mostly OSPF)
    return if $MULTICAST_BEGIN le $ndst && $ndst lt $MULTICAST_END;

    my $version = $ihl >> 4;
    $ihl &= 0xf;
    my $flags = $fragment >> 13;
    $fragment &= 0x1fff;
    # only TCP4
    $version == $IP_VERSION || return;
    # Sanity check on buffer
    length($$bufref) == $length || return;
    # We don't handle IP options (yet)
    $ihl == $IHL || return;
    # Too many hops
    $ttl > 1 || return;
    # Don't handle fragments (fragment offset)
    return if $fragment;
    # Don't handle fragments (MF flag set)
    return if $flags & 0x1;

    $ihl *= 4;
    my $header = substr($$bufref, 0, $ihl, "");
    $length -= $ihl;

    # No buffer padding needed since length($header) is even
    my $sum = unpack("%32n*", $header);
    while ($sum > 0xffff) {
        my $carry = $sum >> 16;
        $sum &= 0xffff;
        $sum += $carry;
    }
    $sum == 0xffff || return;

    my $src = inet_ntoa($nsrc);
    my $dst = inet_ntoa($ndst);

    # print "Sender $peer:$peer_port, Receiver $local [$msg_dst]\n";

    my $dscp = $ecn >> 3;
    $ecn &= 0x7;
    # print "HEADER: DSCP=$dscp, ECN=$ecn, ID=$id, FLAGS=$flags, FRAGMENT=$fragment, TTL=$ttl, CHKSUM=$chksum, SRC=$src, DST=$dst\n";

    if ($proto == $PROTO_UDP) {
        # Only UDP

        # Must have space for UDP header
        return if $length < $UDP_HEADER;

        my $pseudo10 = pack("a4a4xC", $nsrc, $ndst, $proto);
        # Pad buffer with \0 so a last single byte still gets processed as "n"
        $sum = unpack("%32n*", $$bufref . "\x0") + unpack("%32n*", $pseudo10) + $length;
        my ($sprt, $dprt, $udp_len, $udp_chksum) = unpack("nnnn", substr($$bufref, 0, $UDP_HEADER, ""));
        $udp_len == $length || die "Inconsistent UDP length (inner UDP payload length: $udp_len, Inner IP packet length - inner UDP header length $ihl = $length)";
        $length -= $UDP_HEADER;

        if ($udp_chksum) {
            while ($sum > 0xffff) {
                my $carry = $sum >> 16;
                $sum &= 0xffff;
                $sum += $carry;
            }
            $sum == 0xffff || return;
        }

        $listener->info("FOU decoded UDP bytes (TTL %d) on $role UDP socket(%s:%d -> %s:%d): %s",
                        $ttl, $src, $sprt, $dst, $dprt,
                        ::display($$bufref)) if $verbose > 1;

        my $line = $listener->{parent};
        # On the remote side we will be able to distinguish packets coming back
        # from ($dst, $dport) so we can share a single Sender::UDP for a given
        # ($src,$port)
        my $map_src = $line->{map_udp}{"$dst:$dprt"} ||= [
            0,                 # Next seq counter
            {
            },                 # Map "src:port" to map
            [undef],           # Map id to map (the undef makes id start at 1)
            # $ndst,	# Packed destination address
            # $dprt,	# Destination Port
        ];
        my $fou_id = $listener->{fou_id};
        my $key = "$src:$sprt:$fou_id";
        my $map = $map_src->[1]{$key} ||= {
            key		=> $key,
            port	=> $sprt,
            host	=> $src,
            addr	=> $nsrc,
            fou_id	=> $fou_id,
        };
        $map->{seq} = $map_src->[0]++;
        # We should be able to handle many billions of packets before this overflows
        die "Too many packets to $dst:$dprt" if $map->{seq} == $map_src->[0];
        $id = $map->{id};
        if (!defined $id) {
            my $settings = $listener->{parent}{settings};
            # A source we haven't saeen befre or we have forgotten
            if (values %{$map_src->[1]} > $settings->{UDP_MAX}) {
                my @old = sort {$a->{seq} <=> $b->{seq}} values %{$map_src->[1]};
                # Ignore the map we just added (it will have the highest packet number)
                pop @old;
                for my $old (@old) {
                    # Try to allocate the socket. If we can that means the
                    # ($src,$port) combination is not in local use anymore and we
                    # can completely drop it
                    # Notice if we receive FOU packets from a remote host we also
                    # won't be able to bind(), so this works out OK. There is a
                    # problem if we share IP addresses with the sender of the FOU
                    # packets though. So we probably need an option to turn this
                    # off and have another strategy to free up entries
                    # (e.g. a timeout)
                    # print STDERR "Probe $old->{host}, $old->{port}\n";
                    if (ConnUtils->socket_udp($old->{host}, $old->{port}, 1)) {
                        $listener->info("Releasing map '$key' (socket not in use any more)") if $verbose > 1;
                        $id = $old->{id};
                        last;
                    }
                }
                defined $id || die "Assertion: no Free id's";
                # $id //= $old[0]{id} // die "Assertion: no Free id's";
                my $remove = $map_src->[2][$id];
                delete $map_src->[1]{$remove->{key}} == $remove ||
                    die "Assertion: Removing unexpected entry";
            } else {
                $id = @{$map_src->[2]};
            }
            $map->{id} = $id;
            $map_src->[2][$id] = $map;
        }
        # print STDERR ::Dumper($id, $line->{map_udp});
        $line->write($DATA_UDP, pack("wa4nC", $id, $ndst, $dprt, $ttl-1), $$bufref);
    } elsif ($proto == $PROTO_ICMP) {
        # Must have ToS 0
        $dscp == 0 && $ecn == 0 || return;
        # Must have space for ICMP header
        return if $length < $ICMP_HEADER;

        # Pad buffer with \0 so a last single byte still gets processed as "n"
        $sum = unpack("%32n*", $$bufref . "\x0");
        my ($type, $code, $icmp_chksum, $id, $seqno) =
            unpack("WWn3", substr($$bufref, 0, $ICMP_HEADER, ""));
        $length -= $ICMP_HEADER;

        # For mow we only support ICMP ECHO REQUEST
        $code == 0 || return;
        my $extra = "";
        if ($type == $ICMP_ECHO_REQUEST) {
            # Resulting packet must fit
            $extra = pack("a16Na4nnw", $SECRET, rand int 2**32, $nsrc, $id, $seqno, $listener->{fou_id});
            return if $length + $ICMP_HEADER + $IHL * 4 + length($extra) >> 16;
        } else {
            return;
        }

        if (1 || $icmp_chksum) {
            while ($sum > 0xffff) {
                my $carry = $sum >> 16;
                $sum &= 0xffff;
                $sum += $carry;
            }
            $sum == 0xffff || return;
        }

        $listener->info("FOU decoded ICMP bytes (TTL %d) on $role UDP socket(%s -> %s): type %d, code %d, id %d, seqno %d, data=%s",
                        $ttl, $src, $dst,
                        $type, $code, $id, $seqno,
                        ::display($$bufref)) if $verbose > 1;

        my $line = $listener->{parent};
        # We leak $src here. We could do some unique remote port mapping instead
        substr($$bufref, 0, 0, $extra);
        substr($$bufref, 0, 16, md5($$bufref));
        my $remote_seqno = ++$line->{seqno_echo};
        $line->{seqno_echo} = $remote_seqno = 1 if $remote_seqno >> 16;
        $line->write($PING, pack("wa4nC", 1, $ndst, $remote_seqno, $ttl-1), $$bufref);
    }
}

package Fou::UDP;
# Send out proxied packets at the local (client) side usinga FOU tunnel
use vars qw(@ISA);
@ISA = qw(_UDP);

use Scalar::Util qw(weaken);
use Socket qw(inet_aton inet_ntoa pack_sockaddr_in);

# Called with a resolved address (see parse_address)
sub new {
    my ($class, $address_to) = @_;

    my $lookup_id = "$address_to->{host}:$address_to->{port}";
    my $fou = $root->{lookups}{$class}{$lookup_id};
    return $fou if $fou;

    # For now listen on any with a random port. Make this an option
    my ($h, $p, $socket) = ConnUtils->socket_udp("0.0.0.0", 0);

    $fou = $class->SUPER::new(
        $root, undef, $socket,
        lookup_id	=> $lookup_id,
        to		=> $address_to->{packed},
        host		=> $address_to->{host},
        port		=> $address_to->{port},
        host_local	=> $h,
        port_local	=> $p);
    weaken($root->{lookups}{$class}{$lookup_id} = $fou);
    return $fou;
}

sub _finish {
    my $fou = shift;

    delete $fou->{parent}{lookups}{ref $fou}{$fou->{lookup_id}};
    $fou->SUPER::_finish(@_);
}

package Listener::TCP::Local;
use vars qw(@ISA);
@ISA = qw(Listener);

package TCP::Local;
use vars qw(@ISA);
@ISA = qw(Stream);

sub new {
    my ($class, $line, $socket_in, $socket_out, $listener, $local, $peer) = @_;

    my %remote = %{$listener->{remote}};
    $remote{port} ||= $local->{port};
    $remote{host} = $local->{host} if $remote{host} eq "0.0.0.0";
    $remote{display} = "$remote{host}:$remote{port}";
    my $tcp_local = $class->SUPER::new(
        $line, $socket_in, $socket_out,
        local	=> $local,
        peer	=> $peer,
        remote	=> \%remote,
    );
    $tcp_local->info("Start forwarding from %s to %s (remote connect may still fail though)", $peer->{display}, $remote{display}) if $verbose > 1;
    $line->write($CONNECT, pack("ww/a*a*",
                                $tcp_local->{id},
                                @remote{qw(type display)}));
    return $tcp_local;
}

sub on_read {
    my ($local) = @_;

    $local->info("Sending data: %s", ::display($local->{in})) if $verbose > 1;
    $local->{parent}->write($DATA_TCP_LR, pack("w", $local->{id}), $local->{in});
    $local->{in} = "";
}

sub eof : method {
    my $local = shift;

    if ($local->{socket_out}) {
        $local->info("@_: Shutdown read, stop writing to remote") if $verbose > 1;
        shutdown($local->{socket_in}, 0) ||
            $local->die("Could not shutdown read: $^E");
        delete $local->{socket_in};
        # Tell the other side that we won't send any more data
        $local->{parent}->write($DATA_EOF_LR, pack("w", $local->{id}));
    } else {
        # We already stopped writing. We are now completely useless
        $local->info("@_") if $verbose > 1;
        $local->finished_local(@_);
    }
}

sub remote_eof {
    my ($local) = @_;

    $local->info("Remote EOF") if $verbose > 1;

    $local->{reason} = "@_";
    if ($local->{out} eq "") {
        $local->write_end;
    } else {
        $local->{on_written} = \&write_end;
    }
}

sub write_end {
    my ($local) = @_;

    if ($local->{socket_in}) {
        $local->info("Shutdown write, keep reading");
        shutdown($local->{socket_out}, 1) ||
            $local->die("Could not shutdown write: $^E");
        delete $local->{socket_out};
        # Keep reading
    } else {
        # We already stopped reading. We are now completely useless
        $local->finished_local($local->{reason});
    }
}

sub finish_remote {
    my ($local, $reason) = @_;

    $local->info("Tell remote to finish after local $reason") if $verbose > 1;
    $local->{parent}->write($DATA_FIN_LR, pack("w", $local->{id}), $reason);
}

sub finish_local {
    my $local = shift;

    $local->{reason} = "@_";
    $local->{reader} = undef if delete $local->{socket_in};

    if ($local->{out} eq "") {
        $local->local_end;
    } else {
        $local->{on_written} = \&local_end;
    }
}

sub local_end {
    my ($local) = @_;
    $local->finished_local($local->{reason});
}

sub error {
    my $local = shift;
    $local->finished_local(@_);
}

package TCP::Remote;
use vars qw(@ISA);
@ISA = qw(Connect);

sub on_read {
    my ($remote) = @_;

    $remote->info("Sending data: %s", ::display($remote->{in})) if $verbose > 1;
    $remote->{parent}->write($DATA_TCP_RL, pack("w", $remote->{id}), $remote->{in});
    $remote->{in} = "";
}

sub eof : method {
    my $remote = shift;

    $remote->info("@_") if $verbose > 1;
    if ($remote->{socket_out}) {
        $remote->info("@_: Shutdown read, stop writing to remote") if $verbose > 1;
        shutdown($remote->{socket_in}, 0) ||
            $remote->die("Could not shutdown read: $^E");
        delete $remote->{socket_in};
        # Tell the other side that we won't send any more data
        $remote->{parent}->write($DATA_EOF_RL, pack("w", $remote->{id}));
    } else {
        # We already stopped writing. We are now completely useless
        $remote->{parent}->write($DATA_FIN_RL, pack("w", $remote->{id}), "Connection closed");
    }
}

sub remote_eof {
    my ($remote) = @_;

    $remote->info("Remote EOF") if $verbose > 1;

    if ($remote->{out} eq "") {
        $remote->write_end;
    } else {
        $remote->{on_written} = \&write_end;
    }
}

sub write_end {
    my ($remote) = @_;

    if ($remote->{socket_in}) {
        # this implies we are connected and did not yet get EOF
        $remote->info("Shutdown write, keep reading");
        shutdown($remote->{socket_out}, 1) ||
            $remote->die("Could not shutdown write: $^E");
        delete $remote->{socket_out};
        # Keep reading
    } else {
        # !$remote->{local} implies we are connecting. Abort
        delete @$remote{qw(socket_out timeout writer)} if !$remote->{local};
        # We already stopped reading. We are now completely useless
        $remote->finished_local($remote->{reason});
    }
}

sub finish_remote {
    my ($local, $reason) = @_;

    $local->info("Tell remote to finish after local $reason") if $verbose > 1;
    $local->{parent}->write($DATA_FIN_RL, pack("w", $local->{id}), $reason);
}

sub finish_local {
    my $remote = shift;

    $remote->{reason} = "@_";
    $remote->{reader} = undef if delete $remote->{socket_in};

    if ($remote->{out} eq "" || !$remote->{local}) {
        $remote->local_end;
    } else {
        $remote->{on_written} = \&local_end;
    }
}

sub local_end {
    my ($remote) = @_;
    $remote->finished_local($remote->{reason});
}

sub error {
    my $remote = shift;
    $remote->finished_local(@_);
}

package LineProtocol;
# Handle traffic between client and server
use vars qw(@ISA);
@ISA = qw(Stream);

use FindBin qw($Script);
use Errno qw(EINTR EAGAIN EWOULDBLOCK);
use Socket qw(inet_ntoa);
use Scalar::Util qw(weaken);
use Carp qw(croak);
use Digest::MD5 qw(md5);

use constant {
    ACK_MASK	=> 0xffffffff,
};

my %process_name = (
    $SET		=> "SET",
    $START		=> "START",
    $KEEP		=> "KEEP",
    $FOU_REMOTE		=> "FOU_REMOTE",
    $DATA_UDP		=> "DATA_UDP",
    $PING		=> "PING",
    $RESPONSE_UDP	=> "RESPONSE_UDP",
    $RESPONSE_PING	=> "RESPONSE_PING",
    $CONNECT		=> "CONNECT",
    $DATA_TCP_LR	=> "TCP_LOCAL_TO_REMOTE",
    $DATA_TCP_RL	=> "TCP_REMOTE_TO_LOCAL",
    $DATA_EOF_LR	=> "EOF_LOCAL_TO_REMOTE",
    $DATA_EOF_RL	=> "EOF_REMOTE_TO_LOCAL",
    $DATA_FIN_LR	=> "FINISH_LOCAL_TO_REMOTE",
    $DATA_FIN_RL	=> "FINISH_REMOTE_TO_LOCAL",
);

my %process = %process_name;
$_ = __PACKAGE__->can("process_$_") || die "Unknown sub 'process_$_'" for
    values %process;

sub new {
    my $class		= shift;
    my $parent		= shift;
    my $socket_in	= shift;
    my $socket_out	= shift;

    return $class->SUPER::new(
        $parent, $socket_in, $socket_out,
        settings	=> { %{$parent->{settings}} },
        started		=> undef, # Normal operations started
        utime_offset	=> 0,	# Estimated round trip time in microsecond
        keepalive	=> undef,
        map_udp		=> {},
        seqno_echo	=> 0,
        unacked		=> 0,
        in_acked	=> 0,
        out_sent	=> 0,
        out_base	=> 0,
        nr_pingers	=> 0,
        queue_ping	=> [],
        @_);
}

sub on_read {
    my ($line, $rc) = @_;

    $line->{unacked} += $rc;
    $line->keepalive() if $line->{unacked} >= $line->{settings}{ACK_LIMIT};

    while ($line->{in} =~ /^([\x80-\xff]{0,2}[\x00-\x7f].)/s) {
        my ($length, $command) = unpack("wa", $line->{in});
        last if length($line->{in}) < $length;
        my $message = substr($line->{in}, 0, $length, "");
        substr($message, 0, length $1, "");
        $line->info("Processing %s: %s",
                    $process_name{$command} || "Unknown command $command",
                    ::display($message)) if $verbose > 1;
        my $fun = $process{$command} ||
            die "No handler for proto '$command'";
        $fun->($line, $message, $command);
    }
}

sub writing {
    my ($line) = @_;

    $line->{writer} ||= Events::add_write($line->{socket_out}, $line, \&writer);
    $line->{timeout} = Timer::timer($line->{settings}{TIMEOUT},
                                    $line, \&_Stream::timeout);
}

sub write : method {
    my $line = shift;
    my $command = shift;

    my $length = 2;
    $length += length for @_;
    ++$length if $length >= 128;
    ++$length if $length >= 128*128;
    # Don't accept more than 3 BER bytes (~ 2**21 byte message)
    croak "Message too long" if $length >= 128*128*128;

    $line->{out} .= pack("wa", $length, $command);
    $line->{out} .= $_ for @_;
    # $line->info("Constructed %s: %s", $command, unpack("H*", substr($line->{out}, -$length)));

    if ($line->{out_sent} + $length == length $line->{out}) {
        $line->{keepalive} = undef;
        $line->writing;
    }
    return $length;
}

sub writer {
    my ($line) = @_;

    while (1) {
        my $rc = syswrite($line->{socket_out}, $line->{out}, $BLOCK_SIZE, $line->{out_sent});
        if (!$rc) {
            $line->die("Zero write. Is this even possible ?") if defined $rc;
            if ($! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK) {
                $line->{timeout} ||= Timer::timer($line->{settings}{TIMEOUT},
                                                  $line, \&timeout);
            } else {
                $line->error("Could not write to $role_peer: $^E");
            }
            return;
        }
        $line->info("Wrote to %s: %s (%d left)",
                    $role_peer,
                    ::display(substr($line->{out}, $line->{out_sent}, $rc)),
                    length($line->{out})-$line->{out_sent}-$rc) if $verbose > 1;

        $line->{timeout} = undef;
        $line->{out_sent} += $rc;
        if (length $line->{out} == $line->{out_sent}) {
            $line->{writer} = undef;
            $line->{keepalive} = Timer::timer($line->{settings}{KEEPALIVE},
                                              $line, \&keepalive);
            return;
        }
    }
}

sub ready {
    my ($line, $msg, $peer_msg) = @_;

    if ($verbose) {
        ::peer_info($peer_msg) if $line->{client_only};
        if ($verbose > 1) {
            $line->info($msg);
        } else {
            ::info($msg);
        }
        # Add extra line to make this stand out
        print STDERR "\n";
    }
    $line->activate_read;
}

sub activate_read {
    my $line = shift;

    my $children = $line->{children} || return;
    for my $class (sort keys %$children) {
        $class =~ /^(?:Listener|Receiver)::/ || next;
        $_ && $_->resume_read for @{$children->{$class}};
    }
}

sub keepalive {
    my ($line) = @_;

    $line->info("Sending KEEPALIVE/ACK %d (new base %d)",
                $line->{unacked},
                $line->{in_acked} + $line->{unacked} & ACK_MASK) if $verbose > 1;
    die "Assertion: Unacked $line->{unacked} is out of range" if
        $line->{unacked} > 0xffffffff;
    my $msg = sprintf("%.0f\0%0.f\0%s",
                      (Timer->realtime() - $BASE_TIME)*1e6,
                      $line->{utime_offset}, pack("V", $line->{unacked}));
    $msg =~ s/\0+\z//;
    my $length = $line->write($KEEP, $msg);
    if ($length >= $line->{settings}{ACK_LIMIT}) {
        $line->{settings}{ACK_LIMIT} = ++$length;
        $line->info("Increasing ACK_LIMIT to $length") if $verbose;
    }
    $line->{in_acked} = $line->{in_acked} + $line->{unacked} & ACK_MASK;
    $line->{unacked} = 0;
}

sub queue_ping {
    my ($line, $icmp) = @_;

    # $icmp->info("Queue on %s, set pending=2", $line->name);
    die "Assertion: Already pending" if $icmp->{pending};
    weaken($line->{queue_ping}[@{$line->{queue_ping}}] = $icmp);
    $icmp->{pending} = 2;
}

sub activate_ping {
    my ($line) = @_;

    # $line->info("Activate ping, queued=%d, nr_pingers=%d",
    #            scalar @{$line->{queue_ping}}, $line->{nr_pingers});
    while (@{$line->{queue_ping}} && $line->{nr_pingers} < $line->{settings}{PING_MAX}) {
        my $icmp = shift @{$line->{queue_ping}} || next;
        $icmp->unqueue_ping();
    }
}

sub status {
    my ($line, $control, $indent) = @_;

    #local $Data::Dumper::Varname = "VAR";
    #my $settings = ::Dumper($line->{settings});
    #$settings =~ s/\$VAR1 = //g || die "Assertion: No VAR1";
    #$settings =~ s/\s+\z//;
    my $name = $line->name;
    my $settings = ::string_from_value($line->{settings});
    $settings =~ s/\n/\n$indent  /g;

    $control->{out} .= <<"EOF"
$indent$name
$indent  Settings: $settings
EOF
        ;
}

sub process_SET {
    my $line  = shift;

    my $i = unpack("C", substr($_[0], 0, 1, ""));
    my $name = $setting_ids[$i] || die "Unknown variable $i";
    # At the moment all values are numbers
    $line->{settings}{$name} = $_[0] =~ /^0\z|^[1-9][0-9]*\z/ ? $_[0]+0 : $_[0];
    $line->info("Set %s=%s", $name, $_[0]) if $verbose > 1;
}

sub process_START {
    my $line  = shift;

    defined $line->{settings}{EPOCH} || die "Lost early epoch message";

    $line->{started} = 1;

    my $msg = "$Script $role $me\@$hostname ready (clock $CLOCK_TYPE_NAME, pid $$)";

    $line->write($START, $msg) if $role eq "server";
    $line->ready($msg, shift);
}

sub process_KEEP {
    my $line  = shift;

    # Transit time is of course meaningless if the clocks aren't
    # synchronized very well. offset tries to compensate for that

    # add 5 \0 in case they were trimmed (1 for the last Z and 4 for V)
    my ($utime, $uoffset, $acked) = unpack("Z*Z*V", shift() . "\0" x 5);

    die "Assertion: Impossible ACK" if $acked > $line->{out_sent};
    substr($line->{out}, 0, $acked, "");
    $line->{out_sent} -= $acked;
    $line->{out_base} = $line->{out_base} + $acked & ACK_MASK;

    # uoffset has     peertime - mytime + transit_time (me -> peer)
    # This calculates mytime - peertime + transit_time (peer -> me)
    $line->{utime_offset} = (Timer->realtime() - $line->{settings}{EPOCH})*1e6 -$utime || 1;
    $line->info("Received ACK=%d (base=%d, sent=%d), Keepalive transit=%.3f ms" .
                ($uoffset ? ", roundtrip=%.3f ms, offset=%.0f ms" : ""),
                $acked, $line->{out_base}, $line->{out_sent},
                $line->{utime_offset}/1e3,
                $uoffset ? (
                    ($line->{utime_offset}+$uoffset)/1e3,
                    ($line->{utime_offset}-$uoffset)/2e3) : ()) if $verbose > 1;
}

sub process_FOU_REMOTE {
    my ($line, $udp) = @_;

    my ($from, $to) =
        $udp =~ m{^([^%]+)%([^%]+)\z} or
        die "Invalid fou_remote '$udp'";
    $from = ConnUtils->parse_address($from, "FOU remote", from => "UDP4");
    $to   = ConnUtils->parse_address($to  , "FOU remote", to   => "UDP4", resolve => 1);

    my $fou = Fou::UDP->new($to);
    my $listener = Receiver::Fou->new($line, $from->{host}, $from->{port}, $fou);
}

sub process_DATA_UDP {
    my $line = shift;
    my ($id, $dst, $port, $ttl, $data) = unpack("wa4nCa*", shift);
    $id || die "Assertion: Sender socket id $id == 0";
    $id <= $line->{settings}{UDP_MAX} ||
        die "Assertion: Sender socket id $id > $line->{settings}{UDP_MAX}";
    $line->info("Need to send UDP data (TTL %d) from socket %d to %s:%d: %s",
                $ttl, $id, inet_ntoa($dst), $port, ::display($data)) if $verbose > 1;
    my $sender = $line->child("Sender::UDP", $id) ||
        Sender::UDP->new($line, $id);
    $sender->write($port, $dst, $data, $ttl);
}

sub process_RESPONSE_UDP {
    my $line = shift;

    my ($id, $nsrc, $sprt, $ttl, $data) = unpack("wa4nCa*", shift);
    $id || die "Assertion: Sender socket id $id == 0";
    $id <= $line->{settings}{UDP_MAX} ||
        die "Assertion: Sender socket id $id > $line->{settings}{UDP_MAX}";
    my $src = inet_ntoa($nsrc);
    $line->info("\u$role_peer received UDP data on socket %d from %s:%d: %s",
                $id, $src, $sprt, ::display($data)) if $verbose > 1;
    my $map_src = $line->{map_udp}{"$src:$sprt"};
    if (!$map_src) {
        $line->info("No map for $src:$sprt. Dropping packet");
        return;
    }
    my $map = $map_src->[2][$id] || die "Assertion: No Sender socket[$id]";
    $map->{seq} = $map_src->[0]++;
    die "Too many packets from $src:$sprt" if $map->{seq} == $map_src->[0];
    my $fou = $root->child("Fou::UDP", $map->{fou_id}) ||
        die "Assertion: No Fou::UDP with id '$map->{fou_id}'";
    my $ndst = $map->{addr};
    my $dprt = $map->{port};

    # Build FOU IP packet

    # Packet ID is meaningless for atomic packets (RFC 6864)
    my $packet_id = int rand 2**16;
    my $flags = $DF;

    my $length = length($data);
    my $new_length = $length + $IHL * 4 + $UDP_HEADER;
    # Currently we don't handle overly large FOU packets
    if ($new_length >= 2**16) {
        $line->info("Cannot build oversized FOU packet. Dropped") if $verbose > 1;
        return;
    }

    my $header = pack("CCnnnCCx2a4a4",
                      $IP_VERSION << 4 | $IHL,
                      0,
                      $new_length,
                      $packet_id,
                      $DF << 13 | 0,
                      $ttl,
                      $PROTO_UDP,
                      $nsrc,
                      $ndst,
                  );
    my $sum = unpack("%32n*", $header);
    while ($sum > 0xffff) {
        my $carry = $sum >> 16;
        $sum &= 0xffff;
        $sum += $carry;
    }
    substr($header, 10, 2, pack("n", 0xffff - $sum));

    my $pseudo10 = pack("a4a4xC", $nsrc, $ndst, $PROTO_UDP);
    my $udp_header = pack("nnn", $sprt, $dprt, $length + $UDP_HEADER);
    # Temporarily add a 0 byte so we can do even padding
    $data .= "\0";

    $sum = unpack("%32n*", $pseudo10) + unpack("%32n*", $udp_header) + unpack("%32n*", $data) + $length + $UDP_HEADER;

    while ($sum > 0xffff) {
        my $carry = $sum >> 16;
        $sum &= 0xffff;
        $sum += $carry;
    }
    chop $data;
    my $buffer = $header . $udp_header . pack("n", 0xffff - $sum || 0xffff) . $data;

    if (0) {
        my $buf = $buffer;
        # For FOU packet construction debug
        my ($ihl, $ecn, $length, $packet_id, $fragment, $ttl, $proto, $chksum, $src, $dst) = unpack("CCnnnCCna4a4", $buf);
        my $version = $ihl >> 4;
        $ihl &= 0xf;
        my $flags = $fragment >> 13;
        $fragment &= 0x1fff;
        # only TCP4
        $version == $IP_VERSION || die "Wrong version $version";
        # Only UDP
        $proto == $PROTO_UDP || die "Wrong proto $proto";
        # Sanity check on buffer
        length($buf) == $length ||
            die "Wrong length ", length($buf);
        # We don't handle IP options (yet)
        $ihl == $IHL || die "Wrong ihl $ihl";
        # Too many hops
        $ttl || die "Bad TTL $ttl";
        # Don't handle fragments (fragment offset)
        die "Unexpected fragment $fragment" if $fragment;
        # Don't handle fragments (MF flag set)
        die "Bad flags $flags" if $flags & 0x1;

        my $pseudo10 = pack("a4a4xC", $src, $dst, $proto);

        $ihl *= 4;
        my $header = substr($buf, 0, $ihl, "");
        $length -= $ihl;

        # No buffer padding needed since length($header) is even
        my $sum = unpack("%32n*", $header);
        while ($sum > 0xffff) {
            my $carry = $sum >> 16;
            $sum &= 0xffff;
            $sum += $carry;
        }
        $sum == 0xffff || die "Bad IP checksum $sum";

        $src = inet_ntoa($src);
        $dst = inet_ntoa($dst);

        my $dscp = $ecn >> 3;
        $ecn &= 0x7;
        $line->info("HEADER: DSCP=$dscp, ECN=$ecn, ID=$packet_id, FLAGS=$flags, FRAGMENT=$fragment, TTL=$ttl, CHKSUM=$chksum, SUM=$sum, SRC=$src, DST=$dst");

        # Must have space for UDP header
        die "Bad UDP length $length" if $length < $UDP_HEADER;

        # Pad buffer 0 so a last single byte still gets processed as "n"
        $sum = unpack("%32n*", $buf . "\x0") + unpack("%32n*", $pseudo10) + $length;
        my ($sprt, $dprt, $udp_len, $udp_chksum) = unpack("nnnn", substr($buf, 0, $UDP_HEADER, ""));
        $udp_len == $length || die "Inconsistent UDP length";
        $length -= $UDP_HEADER;

        if ($udp_chksum) {
            while ($sum > 0xffff) {
                my $carry = $sum >> 16;
                $sum &= 0xffff;
                $sum += $carry;
            }
            $sum == 0xffff || die "Bad UDP chksum $sum";
        }

        ::info("SPRT=$sprt, DPRT=$dprt, LEN=$udp_len, CHK=$udp_chksum");
    }
    $line->info("Queue UDP packet (TTL %d) for %s: %s:%d -> %s:%d",
                $ttl, $fou->name, $src, $sprt, $map->{host}, $map->{port})
        if $verbose > 1;
    $fou->write($buffer, $ttl);
}

sub process_PING {
    my $line = shift;
    my ($id, $dst, $seqno, $ttl, $data) = unpack("wa4nCa*", shift);
    # Currently we only ever use one pinger
    $id == 1 || die "Assertion: Pinger socket id $id != 1";
    # debug info is written by $pinger->write
    my $pinger = $line->child("Sender::ICMP", $id) ||
        Sender::ICMP->new($line, $id);
    $pinger->write($dst, $seqno, $data, $ttl);
}

sub process_RESPONSE_PING {
    my $line = shift;

    my ($id, $nsrc, $ttl, $buffer) = unpack("wa4Ca*", shift);
    my $md5 = substr($buffer, 0, 16, $SECRET);
    md5($buffer) eq $md5 || return;
    my ($ndst, $icmp_id, $seqno, $fou_id, $data) =
        unpack("x20a4n2wa*", $buffer);
    my $fou = $root->child("Fou::UDP", $fou_id) ||
        die "Assertion: No Fou::UDP with id '$fou_id'";

    # Build FOU IP packet
    my $ip_len = $IHL * 4;
    $buffer = pack("x${ip_len}CCx2nna*x", $ICMP_ECHO_REPLY, 0, $icmp_id, $seqno, $data);
    my $new_length = length($buffer)-1;
    substr($buffer, 0, $ip_len, "");
    my $sum = unpack("%32n*", $buffer);
    chop $buffer;
    while ($sum > 0xffff) {
        my $carry = $sum >> 16;
        $sum &= 0xffff;
        $sum += $carry;
    }
    substr($buffer, 2, 2, pack("n", 0xffff - $sum));

    # Packet ID is meaningless for atomic packets (RFC 6864)
    my $packet_id = int rand 2**16;
    my $header = pack("CCnnnCCx2a4a4",
                      $IP_VERSION << 4 | $IHL,
                      0,
                      $new_length,
                      $packet_id,
                      $DF << 13 | 0,
                      $ttl,
                      $PROTO_ICMP,
                      $nsrc,
                      $ndst,
                  );
    $sum = unpack("%32n*", $header);
    while ($sum > 0xffff) {
        my $carry = $sum >> 16;
        $sum &= 0xffff;
        $sum += $carry;
    }
    substr($header, 10, 2, pack("n", 0xffff - $sum));
    substr($buffer, 0, 0, $header);

    # $buffer = pack("x${ip_len}CCx2nna*x", $ICMP_ECHO_REPLY, 0, $icmp_id, $seqno, $data);

    $fou->info("Queue ICMP packet %s -> %s (TTL %d, Type %d, Code %d, Id %d, Seqno %s): %s",
           inet_ntoa($nsrc), inet_ntoa($ndst), $ttl,
           $ICMP_ECHO_REPLY, 0, $icmp_id, $seqno, ::display($data)) if $verbose > 1;
    $fou->write($buffer, $ttl);
}

sub process_CONNECT {
    my $line = shift;

    my ($id, $type, $target) = unpack("ww/a*a*", shift);

    my $to = ConnUtils->parse_address($target, "TCP connect",
                                      to => $type, resolve => 1);
    TCP::Remote->new($line, {}, $to, id => $id);
}

sub process_TCP_LOCAL_TO_REMOTE {
    my $line = shift;

    my ($id, $pos) = unpack("w.", $_[0]);
    substr($_[0], 0, $pos, "");
    my $tcp_remote = $line->child("TCP::Remote", $id) ||
        $line->bug("Could not find TCP::Remote[$id]");
    $tcp_remote->write(shift) unless $tcp_remote->{finished};
}

sub process_TCP_REMOTE_TO_LOCAL {
    my $line = shift;

    my ($id, $pos) = unpack("w.", $_[0]);
    substr($_[0], 0, $pos, "");
    my $tcp_local = $line->child("TCP::Local", $id) ||
        $line->bug("Could not find TCP::Local[$id]");
    $tcp_local->write(shift) unless $tcp_local->{finished};
}

sub process_EOF_LOCAL_TO_REMOTE {
    my $line = shift;

    my $id = unpack("w", shift);
    my $tcp_remote = $line->child("TCP::Remote", $id) ||
        $line->bug("Could not find TCP::Remote[$id]");
    $tcp_remote->remote_eof() unless $tcp_remote->{finished};
}

sub process_EOF_REMOTE_TO_LOCAL {
    my $line = shift;

    my $id = unpack("w", shift);
    my $tcp_local = $line->child("TCP::Local", $id) ||
        $line->bug("Could not find TCP::Local[$id]");
    $tcp_local->remote_eof() unless $tcp_local->{finished};
}

sub process_FINISH_LOCAL_TO_REMOTE {
    my $line = shift;

    my ($id, $msg) = unpack("wa*", shift);
    my $tcp_remote = $line->child("TCP::Remote", $id) ||
        $line->bug("Could not find TCP::Remote[$id]");
    $tcp_remote->finished_remote($msg);
}

sub process_FINISH_REMOTE_TO_LOCAL {
    my $line = shift;

    my ($id, $msg) = unpack("wa*", shift);
    my $tcp_local = $line->child("TCP::Local", $id) ||
        $line->bug("Could not find TCP::Local[$id]");
    $tcp_local->finished_remote($msg);
}

sub set_peer {
    my ($line, $name, $value) = @_;

    my $i = $setting_ids{$name};
    defined $i || croak "Unknown global variable '$name'";
    if (!defined $value) {
        defined($value = $line->{settings}{$name}) ||
            die "Assertion: Setting '$name' to undef";
    }
    $line->write($SET, pack("w", $i), $value);
}

package _Listener;
use vars qw(@ISA);
@ISA = qw(Object);

use Errno qw(EINTR EAGAIN EWOULDBLOCK ECONNABORTED);
use Socket qw(IPPROTO_TCP TCP_NODELAY AF_INET unpack_sockaddr_in inet_ntoa);

sub new_suspended {
    my $class = shift;
    my $parent = shift;
    my $address = shift;
    my $loops = shift;

    my ($h, $p, $socket) = ConnUtils->socket_tcp($address->{host}, $address->{port}, 1);
    my %local = (
        %$address,
        host	=> $h,
        port	=> $p,
        display	=> "$h:$p",
    );
    my $listener = $class->SUPER::new(
        $parent,
        @_,
        local	=> \%local,
        loop	=> $loops,
        socket	=> $socket,
        reader	=> undef);
    $address->{host} = $h;
    $address->{port} = $p;
    $address->{display} = "$h:$p";
    $listener->info("Listening on %s [%s]", $local{display}, $local{user}) if
        $address->{port} == 0 || $verbose > 1;
    return $listener;
}

sub new {
    my $class = shift;
    my $listener = $class->new_suspended(@_);
    $listener->resume_read;
    return $listener;
}

sub _finish {
    my $listener = shift;

    delete @$listener{qw(reader socket)};
    $listener->SUPER::_finish(@_);
}

sub acceptable {
    my ($listener) = @_;

    my $peer = accept(my $accepted, $listener->{socket});
    if (!$peer) {
        return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK || ECONNABORTED;
        die "Accept failed: $^E";
    }
    $listener->delete("Maximum connections") if --$listener->{loops} == 0;
    $accepted->blocking(0);
    setsockopt($accepted, IPPROTO_TCP, TCP_NODELAY,1) ||
        die "Couldn't disable Nagle's algorithm: $^E";
    my $packed = getsockname($accepted) ||
        die "Assertion: Could not getsockname(): $^E";
    my ($port, $addr) = unpack_sockaddr_in($packed);
    my %local = (
        %{$listener->{local}},
        addr	=> $addr,
        host	=> inet_ntoa($addr),
        port	=> $port,
    );
    $peer = ConnUtils->address_from_packed($peer, "tcp4");
    $listener->info("Connection from %s:%d", @$peer{qw(host port)}) if $verbose > 1;
    $listener->on_accept($accepted, \%local, $peer);
}

sub on_accept {
    my $listener = shift;
    my $accepted = shift;

    my ($target) = ref($listener) =~ /^Listener::(.*)\z/ or
        die "Assertion: Could not parse class of '$listener'";
    $target->new($listener->{parent}, $accepted, $accepted, $listener, @_);
}

sub suspend_read {
    my $listener = shift;

    $listener->info("suspend_read") if $verbose > 1;
    $listener->{reader} || $listener->die("Read already suspended");
    $listener->{reader} = undef;
}

package Listener;
use vars qw(@ISA);
@ISA = qw(_Listener);

sub resume_read {
    my $listener = shift;

    $listener->info("resume_read") if $verbose > 1;
    $listener->{reader} && $listener->die("Read not suspended");
    $listener->{reader} = Events::add_read($listener->{socket}, $listener, \&_Listener::acceptable);
}

package Listener0;
use vars qw(@ISA);
@ISA = qw(_Listener);

sub resume_read {
    my $listener = shift;

    $listener->info("resume_read") if $verbose > 1;
    $listener->{reader} && $listener->die("Read not suspended");
    $listener->{reader} = Events::add_read0($listener->{socket}, $listener, \&_Listener::acceptable);
}

package Listener::Control;
use vars qw(@ISA);
@ISA = qw(Listener0);

package Control;
# Communicate with a Controller process
use vars qw(@ISA);
@ISA = qw(Stream0);

my %commands = (
    help	=> \&command_help,
    status	=> \&command_status,
    set		=> \&command_set,
    finish	=> \&command_finish,
    dump	=> \&command_dump,
    events	=> \&command_events,
    pid		=> \&command_pid,
    quit	=> \&command_exit,
    exit	=> \&command_exit,
);

sub new {
    my ($class, $line, $term_in, $term_out, $listener, $local, $peer) = @_;

    $line || die "Assertion: No line";

    $term_in  = \*STDIN  if !defined $term_in;
    $term_out = \*STDOUT if !defined $term_out;
    # STDIN and/or STDOUT can be $null if the program was called with closed
    # STDIN and/or STDOUT
    die "Input is NULL" if fileno($term_in)  == fileno($null);
    die "Ouput is NULL" if fileno($term_out) == fileno($null);
    $term_in ->blocking(0) if fileno($term_in ) == fileno(STDIN);
    $term_out->blocking(0) if fileno($term_out) == fileno(STDOUT);

    return $class->SUPER::new(
        $line, $term_in, $term_out,
        local	=> $local,
        peer	=> $peer,
        exit	=> fileno($term_in ) == fileno(STDIN));
}

sub _delete {
    my $control = shift;

    $control->SUPER::_delete(@_);
    ::cleanup_all() if $control->{exit};
}

sub error {
    my $control = shift;
    $control->delete(@_);
}

sub eof : method {
    my $control = shift;

    $control->info("@_") if $verbose > 1;
    $control->delete_on_flushed(@_);
}

sub on_read {
    my ($control, $rc) = @_;

    my $len = length($control->{in});
    index($control->{in}, "\n", $len - $rc) >= 0 || return;
    while ($control->{in} =~ s/^(.*)\n//) {
        my ($command, @args) = split " ", $1 or next;
        next if $command =~ m{^#|^//|^--};
        my $fun = $commands{lc $command};
        if (!$fun) {
            $control->{out} .= "Unknown command '$command'\n";
            $control->flush;
            next;
        }
        $fun->($control, $command, @args);
    }
    $control->writing if $control->{out} ne "" && !$control->{writer};
}

sub flush {
}

sub command_help {
    my ($control) = @_;

    $control->{out} .= <<"EOF"
quit               Close connection
exit               Close connection
dump               Dump internal datastructure
events             Dump internal Events
finish             End the program
help               Show this help
pid                Show program pid
set {var=value}    Set variables
status             Show connections status
EOF
        ;
    $control->flush;
}

sub command_status {
    my ($control) = @_;

    my $msghdr = $msghdr_error || Socket::MsgHdr->VERSION;

    my $rlwrap = $ENV{udp_proxy_rlwrap} || 0;
    $control->{out} .= <<"EOF"
Local:
  Script $::Script (pid $$)
  VERSION $VERSION
  PROTOCOL $PROTOCOL
  Host $hostname
  User $me ($>)
  Socket::MsgHdr $msghdr
  rlwrap $rlwrap
  verbose=$verbose
EOF
        ;
    $root->status_all($control, "  ");
    $control->flush();
}

sub command_set {
    my $control = shift;
    shift;

    if (@_) {
        for my $arg (@_) {
            if ($arg =~ /^verbose=((?:0|[1-9]\d*))\z/ia) {
                $verbose = int $1;
            } else {
                $control->{out} .= "Invalid $arg\n";
            }
        }
    } else {
        $control->{out} .= "Missing arguments";
    }
    $control->flush();
}

sub command_exit {
    my ($control, $command) = @_;

    $control->{out} .= "OK\n";
    $control->flush();
    $control->delete_on_flushed("Command '$command'");
}

sub command_finish {
    my $control = shift;

    ::cleanup_all();
    $control->command_exit(@_);
}

sub command_dump {
    my ($control) = @_;

    $control->{out} .= ::Dumper($root);
    $control->flush();
}

sub command_events {
    my ($control) = @_;

    $control->{out} .= Events::events();
    $control->flush();
}

sub command_pid {
    my ($control) = @_;

    $control->{out} .= "$$\n";
    $control->flush();
}

package Listener::LineProtocol;
use vars qw(@ISA);
@ISA = qw(Listener);

sub on_accept {
    my ($listener, $accepted) = @_;

    $listener->{parent}->server($accepted, $accepted);
}

package main;
# use Scalar::Util qw(weaken);

sub _info {
    local ($!, $^E);
    my $role = ucfirst(shift);
    if (!@_) {
        my (undef, $filename, $line) = caller(1);
        @_ = ("$filename $line");
    }
    my $format = shift;
    $format =~ s/\n?\z/\n/;
    if (!@_) {
        @_ = ($format);
        $format = "%s";
    }
    my $time = Timer->realtime;
    my $itime = int($time);
    my ($sec, $min, $hour, $day, $mon, $year) = localtime($itime);
    my $gtime = timegm($sec, $min, $hour, $day, $mon, $year);
    my $offset = ($gtime - $itime) / 60;
    my $sign = "+";
    if ($offset < 0) {
        $sign = "-";
        $offset = -$offset;
    }
    my $hoffset = $offset / 60;
    my $moffset = $offset % 60;
    printf(STDERR "%04d-%02d-%02d %02d:%02d:%06.3f %s%02d%02d %s: $format",
           $year+1900, $mon+1, $day, $hour, $min, $time-$itime+$sec,
           $sign, $hoffset, $moffset,
           $role, @_);
}

sub info {
    _info($role, @_);
}

sub peer_info {
    _info($role_peer, @_);
}

sub callers {
    my (@lines, $line);
    # Skip the entry for callers itself, so by default start $i at 1
    my $i = shift;
    push @lines, $line while (undef, undef, $line) = caller(++$i);
    return join(" ", @lines);
}

sub caller_info {
    my $format = shift;
    if (@_) {
        info("$format [%s]", @_, callers());
    } else {
        my $callers = callers();
        $callers =~ s{%}{%%}g;
        info("$format [$callers]");
    }
}

my %display = (
    "\r"	=> '\r',
    "\n"	=> '\n',
    "\t"	=> '\t',
    "\0"	=> '\0',
    "\\"	=> '\\',
    '"'		=> '\"',
    );
sub display {
    my ($data) = @_;

    my $len = length $data;
    my $long = $len > 30;
    $data = substr($data, 0, 37) if $long;
    # $data =~ s{([^\x20-\x7e])}{sprintf('\x%02x', ord $1)}eg;
    my $hex = unpack("H*", $data);
    $data =~ s{([^\x20-\x7e])}{$display{$1} || "."}eg;
    $data = qq{"$data" ($hex)};
    $data .= " ..." if $long;
    $data .= $len == 1 ? " ($len byte)" : " ($len bytes)";
    return $data;
}

sub string_from_value {
    no warnings "once";
    # local $Data::Dumper::Varname  = "VAR";
    local $Data::Dumper::Trailingcomma = 0;
    local $Data::Dumper::Terse = 1;
    local $Data::Dumper::Quotekeys = 0;
    local $Data::Dumper::Sparseseen = 1;
    my $value = Dumper(shift);
    $value =~ s/\s+\z//;
    return $value;
}

# Try an immediate exit. No references should exist in the call chain
sub _cleanup_all {
    $root &&= 0;
    Signals->_cleanup_all;
    if ($nr_events && defined $root) {
        $root = undef;
        print STDERR "Pid=$$\n" . Events::events();
        die "Assertion: Still have $nr_events events";
    }
}

# Clean up all events and wait until the next loop in mainloop to exit
# (needed to give references in the callchain to get freed)
sub cleanup_all {
    ::caller_info("cleanup_all()") if $verbose > 1;
    $root->immediate(\&_cleanup_all) if $root;
}

sub add_control {
    my ($parent) = @_;

    my $address = ConnUtils->parse_address("127.0.0.1:0", "Control", from => "TCP4", resolve => 1);
    Listener::Control->new($parent, $address);
}

my %connection_types = (
    tcp_local		=> "L",
    tcp_remote		=> "R",
    udp_local		=> "l",
    udp_remote		=> "r",
    fou_local		=> "F",
    fou_remote		=> "f",
    control_local	=> "C",
);
my %connections;

my @ARGV_OLD = @ARGV;
GetOptions("server:s"		=> \my $server,
           "client=s"		=> \my $client,
           "N|loops=o"		=> \$loops,
           "T=o"		=> \$global_timeout,
           "n+"			=> \my $no_control,
           "server_lib=s"	=> \my @server_lib,
           "ssh=s"		=> \$ssh,
           "M|master"		=> \my $ssh_master,
           "perl=s"		=> \my $remote_perl,
           "server_verbose+"	=> \my $server_verbose,
           "client_verbose+"	=> \my $client_verbose,
           "v|verbose+"		=> \$verbose,
           "keepalive=f"	=> \$keepalive,
           "timeout=f"		=> \$timeout,
           "stuff!"		=> \my $stuff,
           (map {; "$connection_types{$_}|$_=s" => \@{$connections{$_}}} keys %connection_types),
           "udp_max=o"		=> \$udp_max,
           "ping_max=o"		=> \$ping_max,
           "version!"		=> \my $version,
           "U|unsafe!"		=> \my $unsafe,
           "h|help!"		=> \my $help) ||
    die "Could not parse your command line. Try $Script -h\n";

if ($version) {
    print<<"EOF";
udp_proxy $VERSION (Net::Sssssh) $VERSION
EOF
    exit 0;
}

if ($help) {
    require Config;
    $ENV{PATH} .= ":" unless $ENV{PATH} eq "";
    $ENV{PATH} = "$ENV{PATH}$Config::Config{'installscript'}";
    exec("perldoc", "-F", $unsafe ? "-U" : (), $0) || exit 1;
    # make parser happy
    %Config::Config = ();
}

die "timeout $timeout must be positive\n" if $timeout <= 0;
$settings_global{TIMEOUT} = $timeout;
die "keepalive $keepalive must be positive\n" if $keepalive <= 0;
$settings_global{KEEPALIVE} = $keepalive;
die "udp_max must be positive" if $udp_max < 1;
$settings_global{UDP_MAX} = $udp_max;
die "ping_max must be positive" if $ping_max < 1;
$settings_global{PING_MAX} = $ping_max;
die "global timeout must not be negative" if
    defined $global_timeout && $global_timeout < 0;

$no_control ||= 0;
$verbose ||= 0;
$client_verbose = $verbose if !defined $client_verbose;
$server_verbose = $verbose if !defined $server_verbose;

$role = "server" if defined $server;
$role_peer = $role eq "server" ? "client" : "server";

if ($role eq "server") {
    # From here on we are the server
    $verbose = $server_verbose;

    die "Cannot be both server and client\n" if defined $client;
    die "Cannot have stuff in server mode\n" if $stuff;

    if (defined $server && $server ne "-") {
        # Manual start
        if ($no_control) {
            open(STDIN, "<&", $null) || die "Could not dup to STDIN: $^E";
            $root = Root->new();
        } else {
            if (!$ENV{udp_proxy_rlwrap}) {
                die "Assertion: Already queued events" if $nr_events;
                local $ENV{udp_proxy_rlwrap} = "1";
                no warnings "exec";
                { exec("rlwrap", "-w", 100, "-S", "$Script>", "$Bin/$Script", @ARGV_OLD) };
                $! == ENOENT || die "Could not exec 'rlwrap': $^E";
                ::info("Could not exec 'rlwrap': $^E") if $verbose > 1;
            }
            $root = Root->new();
            Control->new($root);
            $| = 1;
        }
        my $address = ConnUtils->parse_address($server, "Server", from => "TCP4", resolve => 1);

        $loops = -1 if !defined $loops;
        Listener::LineProtocol->new($root, $address, $loops) if $loops;
    } else {
        $root = Root->new();
        # Make sure that if we fork/exec things they won't get access to
        # our communication channel
        open(my $socket_in,  "<&STDIN")  || die "Could not dup STDIN: $^E";
        open(STDIN, "<&", $null) || die "Could not dup to STDIN: $^E";
        open(my $socket_out, ">&STDOUT") || die "Could not dup STDOUT: $^E";
        open(STDIN, ">&", $null) || die "Could not dup to STDOUT: $^E";
        $socket_in->blocking(0);
        $socket_out->blocking(0);
        $root->server($socket_in, $socket_out);
    }
    $root->signal_add0("USR1", \&add_control) if defined $server && $no_control < 2;
} else {
    # From here on we are the client
    $verbose = $client_verbose;

    if ($no_control) {
        open(STDIN, "<&", $null) || die "Could not dup to STDIN: $^E";
        $root = Root->new();
    } else {
        if (!$ENV{udp_proxy_rlwrap}) {
            die "Assertion: Already queued events" if $nr_events;
            local $ENV{udp_proxy_rlwrap} = "1";
            no warnings "exec";
            { exec("rlwrap", "-w", 100, "-S", "$Script>", "$Bin/$Script", @ARGV_OLD) };
            $! == ENOENT || die "Could not exec 'rlwrap': $^E";
            ::info("Could not exec 'rlwrap': $^E") if $verbose > 1;
        }
        $root = Root->new();
        Control->new($root);
        $| = 1;
    }
    $root->signal_add0("USR1", \&add_control) if $no_control < 2;
    if (defined $client) {
        die "Cannot have arguments in client mode" if @ARGV;
        die "Cannot have stuff in client mode" if $stuff;

        my $host = $client =~ s{(.*):}{}s ? $1 : "127.0.0.1";
        my $socket = ConnUtils->socket_tcp($host, $client);
        $root->client($socket, $socket, \%connections, 1);
    } else {
        @ARGV || die "Missing remote host argument, Try $Script -h\n";
        $stuff = 1 if !defined $stuff;
        if ($stuff) {
            @ARGV == 1 || die "Spurious arguments\n";
        }

        pipe(my $rd0, my $wr0) || die "Could not pipe: $^E";
        pipe(my $rd1, my $wr1) || die "Could not pipe: $^E";
        defined(my $pid = fork()) || die "could not fork: $^E";

        if (!$pid) {
            # Child
            # This side does the ssh connection so that ^C goes to ssh
            eval {
                close $wr0;
                close $rd1;
                open(STDIN,  "<&", $rd0) || die "Could not dup STDIN: $^E";
                close $rd0;
                open(STDOUT, ">&", $wr1) || die "Could not dup STDOUT: $^E";
                close $wr1;

                $SIG{CHLD} = "DEFAULT";
                if ($stuff) {
                    # delete @ENV{qw(LANGUAGE LC_ALL LANG)};
                    my $remote_host = shift;
                    if ($remote_host eq "") {
                        $remote_perl = $^X if !defined $remote_perl;
                        exec($remote_perl) ||
                            die "Could not exec $remote_perl: $^E";
                    } else {
                        $remote_perl = "/usr/bin/perl" if !defined $remote_perl;
                        exec($ssh, $ssh_master ? "-M" : (), "-e", "none", $remote_host, $remote_perl) ||
                            die "Could not exec $ssh: $^E";
                    }
                } else {
                    push @ARGV, "$Bin/$Script" if @ARGV == 1;
                    exec($ssh, $ssh_master ? "-M" : (), "-e", "none", "-T", @ARGV) ||
                        die "Could not exec $ssh: $^E";
                }
            };
            die $@ || "No error";
        }

        # Parent
        close $rd0;
        close $wr1;
        $wr0->autoflush(1);
        $wr0->blocking(0);
        $rd1->blocking(0);

        if ($stuff) {
            my $self = "$Bin/$Script";
            # Maybe we could get the same info through DATA (if we didn't close)
            open(my $fh, "<", $self) || die "Could not open $self: $^E";
            my $content = qq(#line 1 "$Bin/$Script"\n);
            $content .= do { local $/; <$fh> };
            $content =~ s/\n__END__\n.*/\n/s || die "Could not find __END__";
            # Remove full line comments, but not #line statements.
            # Leave the \n so line numbers in error messages keep working
            $content =~ s/^[^\S\n]*#(?![^\S\n]*line\s).*//mg;
            # Drop leading spaces. Saves about 20%
            # (less of course if ssh does compression, which it does by default)
            $content =~ s/^[^\S\n]+//mg;

            # Change a few variables in the server code
            my %replace =
                (verbose	=> $server_verbose,
                 role		=> "server",
                 # This is needed because $SET sets the remote timeout for $line
                 # but Fou::UDP is not a child of $line and uses the
                 # global settings
                 timeout	=> $timeout,
                 ping_max	=> $ping_max,
                 global_timeout	=> $global_timeout,
             );
            while (my ($name, $value) = each %replace) {
                $value = string_from_value($value);
                # info("Value $name=<$value>") if $verbose;
                $content =~ s{^([^\S\n]*(?:my|our))\s*\$\Q$name\E\s*=[^;\n]*;[^\S\n]*\n}{$1 \$$name=$value;\n}m || die "Could not set $name";
            }

            print($wr0 $PRE_STUFFER) || die "Write error:$^E";
            for my $server_lib (map split(/:/), @server_lib) {
                print($wr0 qq(use lib "$server_lib";\n)) || die "Write error:$^E";
            }
            # print($wr0 qq(\$Script="\$Script"\n)) || die "Write error:$^E";
            print($wr0 $content) || die "Write error:$^E";
            print($wr0 $POST_STUFFER) || die "Write error:$^E";
            my $line = "";
            while (length($line) < length($STUFFED)) {
                alarm(60);
                my $rc = sysread($rd1, $line, length($STUFFED)-length $line, length $line);
                if (!defined $rc) {
                    next if $! == EINTR;
                    die "Read error: $^E";
                }
                die "Unexpected EOF" if $rc == 0;
            }
            alarm(0);
            $line eq $STUFFED || die "Bad server confirm $line";
        }
        $root->client($rd1, $wr0, \%connections, 0);
    }
}

$root->timeout($global_timeout) if defined $global_timeout;

eval {
    for my $control (@{$connections{control_local}}) {
        my $address = ConnUtils->parse_address($control, "Control", from => "TCP4", resolve => 1);
        Listener::Control->new_suspended($root, $address);
    }

    Events->mainloop();
};
_cleanup_all();
die "\u$role DIED: $@" if $@;
# die "Assertion: \u$role fell off the mainloop";
exit $exit;

__END__
Implementation notes:
