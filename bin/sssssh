#!/usr/bin/perl -w
my $null;
BEGIN {
    # This must come before any modules, even use strict/warnings
    # (to avoid these modules keeping open early file handles for __DATA__)
    $^F == 2 || die "Assertion: Invalid CLO_EXEC range";
    open($null, "+<", "/dev/null") || die "Could not open '/dev/null': $^E";
    die "Assertion: Should at least have the source code open at fileno 0" if
        fileno($null) == 0;
    if (fileno($null) == 1) {
        # Perl will automatically subsume fd 1 into STDOUT
        open($null = undef, "+>&STDOUT") || die "Could not dup STDOUT: $^E";
    }
    if (fileno($null) == 2) {
        # Perl will automatically subsume fd 2 into STDERR
        open($null = undef, "+>&STDERR") || die "Could not dup STDERR: $^E";
    }
    fileno($null) > 2 || die "Assertion: Invalid NULL handle";
    # So now we are absolutely sure $null has CLO_EXEC
}
# Now take over STDIN in case we had no STDIN and perl opened it as source code
# We should have a DATA filehandle because this file has an __END__ section
# (but for unclear reasons it does not when stuffing --Ton)
if (defined fileno(DATA)) {
    fileno(DATA) != fileno(STDIN) ||
        open(STDIN, "<&", $null) || die "Could not dup to STDIN: $^E";
    close(DATA);
}

use strict;
use warnings;

# modprobe fou
# ip link add name fou1 type ipip remote 127.0.0.1 local 127.0.0.1 ttl 225 encap fou encap-sport auto encap-dport 1236
# ip link set fou1 up
# ip addr add 10.253.4.1/24 dev fou1
# # If you add "dev fou1" to the add port it seems to stop working
# # If you remove the "local 127.0.0.1" it keeps working
# ip fou add port 1237 ipproto 4 local 127.0.0.1

# Redirect packets to port 1234 into the fou1 tunnel:
# iptables -t mangle -N FWMARK2
# # iptables -t mangle -A FWMARK2 -j LOG --log-prefix 'iptables-mark2: ' --log-level info
# iptables -t mangle -A FWMARK2 -j MARK --set-mark 17
# iptables -t mangle -A OUTPUT -p udp --dport 1234 -j FWMARK2
# # Also catch ping requests
# # iptables -t mangle -A OUTPUT -p icmp --icmp-type 8 -j FWMARK2
# ip rule add fwmark 17 lookup 101
# ip route add default via 10.253.4.1 table 101

# Avoid other stuff sneaking into the tunnel
# (not sure how, but when using deluge (torrent): external traffic not on the marked port gets into the tunnel. Deluge for some reason sometimes uses the tunnel IP as its source address)
# ---- Targeted (124 is uid of deluge -----
# iptables -A OUTPUT -o ppp0 -m owner --uid-owner 124 -j DROP
# iptables -A OUTPUT -s 10.253.0.8 -m owner --uid-owner 124 -j ACCEPT
# iptables -A OUTPUT -s 10.253.1.8 -m owner --uid-owner 124 -j ACCEPT
# iptables -A OUTPUT -s 127.0.0.0/8 -m owner --uid-owner 124 -j ACCEPT
# iptables -A OUTPUT -m owner --uid-owner 124 -j DROP
# OSPF (bird)
# iptables -A OUTPUT -p 89 -s 10.253.4.1 -j DROP
# SSDP. Who is doing this ?
# iptables -A OUTPUT -p udp -s 10.253.4.1 -d 239.255.255.250 -j DROP
# ---- Brute force -----
# iptables -t mangle -A INPUT -d 10.253.4.1 -j DROP
# iptables -t mangle -A OUTPUT -s 10.253.4.1 -j DROP

# sysctl -w net.ipv4.conf.all.rp_filter=0
# sysctl -w net.ipv4.conf.fou1.rp_filter=0

# ip fou del port 1237 ipproto 4 local 127.0.0.1
# ip link del name fou1

# Native ping forwarding needs permission to open a IPPROTO_ICMP sockets on the
# forwarded host.
# E.g. On linux:
#   Query current permissions:
#      sysctl net.ipv4.ping_group_range
#   Allow group 1014:
#      sysctl net.ipv4.ping_group_range='1014 1014'
# If this permission is not available (or not supported on the OS) the program
# falls back to running an external ping program

our $VERSION = "1.000";

use FindBin qw($Bin $Script);
use Getopt::Long 2.24 qw(:config bundling require_order);
use Carp;
use Sys::Hostname;
use Errno qw(EINTR ENOENT ETIMEDOUT);
use Time::Local qw(timegm);
use Socket qw(inet_aton);
use POSIX qw(_exit);

use Data::Dumper;
$Data::Dumper::Indent   = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Useqq	= 1;

($Bin, $Script) = __FILE__ =~ m{^(.*)/(.+)\z} or
    die "Could not parse ", __FILE__ if $Script eq "-" && __FILE__ ne "-";

$SIG{PIPE} = "IGNORE";

delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};
$ENV{PATH}="/usr/bin:/usr/sbin:/bin:/sbin";

my $MULTICAST_BEGIN = inet_aton("224.0.0.0") || die "Assertion: Bad address";
# multicast range *excludes* this END address
my $MULTICAST_END   = inet_aton("240.0.0.0") || die "Assertion: Bad address";

my $IP_VERSION = 4;
defined(my $PROTO_ICMP = getprotobyname("icmp")) || die "Unknown protocol ICMP";
defined(my $PROTO_UDP  = getprotobyname("udp"))  || die "Unknown protocol UDP";
defined(my $PROTO_TCP  = getprotobyname("tcp"))  || die "Unknown protocol TCP";
my $IHL = 5;
my $ICMP_HEADER = 8;
my $UDP_HEADER  = 8;
my $DF = 2;
my $TTL = 64;
my $ICMP_ECHO_REQUEST = 8;
my $ICMP_ECHO_REPLY = 0;

# We set the PATH environment variable, so this is safe enough
my $ssh = "ssh";
my $verbose = undef;
my $global_timeout = undef;
# Time for I/O to at least start
my $timeout = 20;
# Time we wait for a connect() to finish
my $timeout_connect = 10;
# The longest we want an idle LineProtocol wire
my $keepalive = 300;
my $udp_max = 10;
my $ping_max = 10;
my $socks_pipeline = 1;
my $resolv_file = "/etc/resolv.conf";
my $hosts_file = "/etc/hosts";

# How long a server UDP socket lingers without traffic
# How long an errored TCP connection tries to push lingering output
my $SOCKS_TIMEOUT = 120;
# How much we can typically fit into our communication channel
my $LINE_BLOCK_SIZE = int(2**14);
my $BLOCK_SIZE = int(2**16);
my $UDP_SIZE = int(2**16);
my $LISTEN_BACKLOG = 128;
my $TCP_KEEPALIVE_PROBES = 8;

my @PING =
    $^O eq "solaris" ? (["ping", "-s"], ["64", "1"]) :
    (["ping", "-c", "1"], []);

my %settings_global = (
    EPOCH	=> undef,
    MSGHDR	=> undef,
    TIMEOUT	=> undef,
    TIMEOUT_CONNECT	=> undef,
    KEEPALIVE	=> undef,
    UDP_MAX	=> undef,
    PING_MAX	=> undef,
    # ACK_LIMIT should be greater than KEEPALIVE/ACK packet
    # (Code will increase it if not, but you will still send way too many ACKs)
    ACK_LIMIT	=> int(1e6),
    # For debugging:
    # ACK_LIMIT	=> 0,
);
my @setting_ids = sort keys %settings_global;
my %setting_ids;
$setting_ids{$setting_ids[$_]} = $_ for 0..$#setting_ids;

my $SECRET = pack("NNNN", $$ ^ rand 2**32, $^T ^ rand 2**32, rand 2**32, rand 2**32);

my $STUFFED = "GoNow";

my $PROTOCOL	= 1;

# Lineprotocol commands
my $START		= "1";
my $SET			= "=";	# sets a server variable
my $KEEP		= "K";	# Keepalive/ACK packet

# Implicit about LineProtocol
my $CONNECT		= "C";	# Create a server side connecting TCP::Forward
my $CONNECT_REMOTE	= "c";	# Create a client side connecting TCP::Forward
my $LISTEN_REMOTE	= "L";	# Create a server side Listener::TCP::Remote
my $SOCKS		= "S",	# Create a remote Socks::Connect/Socks::Accept
my $SOCKS_REMOTE	= "d",	# Create a server side Listener::Socks::Local
my $FOU_REMOTE		= "r";	# Create a server side Receiver::Fou (and Fou::UDP if needed)
my $PING		= "P";	# Create a remote Sender::ICMP (if not exists)
my $RESPONSE_PING	= "p";	# Use a remote Fou::UDP to send ICMP ECHO REPLY
my $RESPONSE_UDP	= "u";	# DATA to remote (initiator)

# Implicit about TCP::Forward
my $TCP_DATA		= "T";	# DATA to remote
my $TCP_EOF		= "E";	# EOF  to remote
my $TCP_FIN		= "F";	# FINISH to remote (will never send more about this id)

# Implicit about Sender::UDP
# (UDP is handled assymetric, there is the idea of an initiator and a responder)
my $UDP_DATA		= "U";	# DATA to remote (UDP responder), create Sender::UDP if needed

# Implcit about Socks::Local (about to become TCP::Forward)
my $SOCKS_RESULT	= "s",

my $SOCKS_DATA		= "R";	# DATA to remote

my $ETIMEDOUT = $! = ETIMEDOUT;

my $msghdr_error;
BEGIN {
    # Can't use "require" later on since (old) Socket::MsgHdr has INIT blocks
    $msghdr_error = eval(sprintf(qq(#line %d "%s"\nuse Socket::MsgHdr qw(pack_cmsghdr unpack_cmsghdr sendmsg recvmsg); 1), __LINE__, __FILE__)) ? "" :
        $@ || "Unknown error loading Socket::MsgHdr\n";
    $msghdr_error =~ s/^BEGIN failed.*\n\z//m;
    $msghdr_error =~ s/\s+\z//;

}
END {
    # Carp.pm can stash objects in @DB::args causing them not to get freed
    @DB::args = ();
}

my $FREE_BSD = $^O eq "freebsd";
# IPPROTO_IP exists in Socket, but not in really old ones
my $IPPROTO_IP = 0;
my ($IP_RECVTTL, $IP_TTL, $IP_PKTINFO, $ICMP_FILTER);
if (!$msghdr_error) {
    if ($FREE_BSD) {
        # FreeBSD uses IP_RECVDSTADDR
        $IP_PKTINFO	=  7;
        $IP_RECVTTL	= 65;
        $IP_TTL		=  4;
    } elsif ($^O eq "linux") {
        $IP_PKTINFO	=  8;
        $IP_RECVTTL	= 12;
        $IP_TTL		=  2;
        $ICMP_FILTER	=  1;
    } else {
        $msghdr_error = "Socket::MsgHdr constants for OS $^O not implemented (yet)\n";
    }
}

my ($TCP_KEEPIDLE, $TCP_KEEPINTVL, $TCP_KEEPCNT, $SOL_RAW, $SO_ACCEPTFILTER);
if ($FREE_BSD) {
    # Needs at least FreeBSD 9
    $TCP_KEEPIDLE	=  256;
    $TCP_KEEPINTVL	=  512;
    $TCP_KEEPCNT	= 1024;
    $SO_ACCEPTFILTER	= 4096;
} elsif ($^O eq "linux") {
    $TCP_KEEPIDLE	=  4;
    $TCP_KEEPINTVL	=  5;
    $TCP_KEEPCNT	=  6;
    $SOL_RAW		=255;
}
# FreeBSD has SO_ACCEPTFILTER instead with different call usage
my $TCP_DEFER_ACCEPT = eval { Socket::TCP_DEFER_ACCEPT() };

my $msghdr = $msghdr_error ? undef : Socket::MsgHdr->new();
my $loops;

my $role = "client";
my $role_peer;

# Determine some system settings
my $hostname = hostname();
my $me;
if ($^O eq "MSWin32") {
    require Win32;
    $me = Win32::LoginName();
} else {
    if (my $user = $ENV{LOGNAME}) {
        if (defined(my $uid = getpwnam($user))) {
            $me = $user if $> == $uid;
        }
    }
    $me ||= getpwuid $>;
}
die "Can't determine who I am" if !$me;

die "Bad file '", __FILE__, "'" if __FILE__ =~ /["\n\0]/;
# Client stuffer
my $POST_STUFFER = sprintf(qq(#line %d "%s"\n%s),
                           __LINE__, __FILE__, '
BEGIN {
    eval {
        open($SAVED_STDIN, "<&", \*STDIN);
        open(STDIN, "<", "/dev/null") || die "NULL: $!";
        1;
    } or do {
        print STDERR $@ || "Unknown error\n";
        exit 255;
    };
}
');
my $PRE_STUFFER = sprintf(qq(#line %d "%s"\n%s),
                           __LINE__, __FILE__, '
BEGIN { $^W = 1 }

my $SAVED_STDIN;
open(STDIN, "<&", $SAVED_STDIN) || die "Could not dup STDIN: $^E";
close($SAVED_STDIN) || die "Could not close SAVED_STDIN: $^E";
$| = 1;
print "' . $STUFFED . '";
');

{
    package Events;
    # A small event core
    # for lib_extract
    # use Timer;
    use Carp;
    use Errno qw(EINTR);
    use Scalar::Util qw(weaken);

    use vars qw($nr_events);
    $nr_events = 0;

    sub nr_events {
        return $nr_events;
    }

    my $read_mask  = "";
    my $write_mask = "";
    my $error_mask = "";
    my @refs = qw(read write error);
    my %refs = (
        read	=> \my %read_refs,
        write	=> \my %write_refs,
        error	=> \my %error_refs,
    );

    # All placeholder subs are the same sub
    use constant {
        NOP	=> sub {},
        OBJ	=> 0,
        CODE	=> 1,
        FD	=> 2,
        CALLERS	=> 3,
    };

    sub die_no_handle {
        ::caller_info("DIE: Assertion: Not a filehandle") if $verbose > 1;
        die sprintf("Assertion: Not a filehandle [%s]\n", ::callers());
    }

    sub Events::Read::DESTROY {
        defined(my $fd = ${shift()}) || die "No filedescriptor";
        ::caller_info("delete_read(%d, %s)", $fd,
                      ::object_name($read_refs{$fd}->[OBJ])) if $verbose > 1;
        # This strange assign after delete is to update the reference the for in
        # sub mainloop may still have in such a way that OBJ keeps existing
        # (otherwise a confess during the callback will access freed memory)
        # We could set either the object or the callback
        # But the object is already weak and the callback may be a closure
        delete($read_refs{$fd})->[CODE] = NOP;
        if (%read_refs) {
            vec($read_mask, $fd, 1) = 0;
            $read_mask =~ s/\x00+\z//;
        } else {
            $read_mask = "";
        }
        --$nr_events;
    }

    sub Events::Read0::DESTROY {
        defined(my $fd = ${shift()}) || die "No filedescriptor";
        ::caller_info("delete_read0(%d, %s)", $fd,
                      ::object_name($read_refs{$fd}->[OBJ])) if $verbose > 1;
        # This strange assign after delete is to update the reference the for in
        # sub mainloop may still have in such a way that OBJ keeps existing
        # (otherwise a confess during the callback will access freed memory)
        # We could set either the object or the callback
        # But the object is already weak and the callback may be a closure
        delete($read_refs{$fd})->[CODE] = NOP;
        if (%read_refs) {
            vec($read_mask, $fd, 1) = 0;
            $read_mask =~ s/\x00+\z//;
        } else {
            $read_mask = "";
        }
    }

    sub Events::Write::DESTROY {
        defined(my $fd = ${shift()}) || die "No filedescriptor";
        ::caller_info("delete_write(%d, %s)", $fd,
                      ::object_name($write_refs{$fd}->[OBJ])) if $verbose > 1;
        # This strange assign after delete is to update the reference the for in
        # sub mainloop may still have in such a way that OBJ keeps existing
        # (otherwise a confess during the callback will access freed memory)
        # We could set either the object or the callback
        # But the object is already weak and the callback may be a closure
        delete($write_refs{$fd})->[CODE] = NOP;
        if (%write_refs) {
            vec($write_mask, $fd, 1) = 0;
            $write_mask =~ s/\x00+\z//;
        } else {
            $write_mask = "";
        }
        --$nr_events;
    }

    sub Events::Write0::DESTROY {
        defined(my $fd = ${shift()}) || die "No filedescriptor";
        ::caller_info("delete_write0(%d, %s)", $fd,
                      ::object_name($write_refs{$fd}->[OBJ])) if $verbose > 1;
        # This strange assign after delete is to update the reference the for in
        # sub mainloop may still have in such a way that OBJ keeps existing
        # (otherwise a confess during the callback will access freed memory)
        # We could set either the object or the callback
        # But the object is already weak and the callback may be a closure
        delete($write_refs{$fd})->[CODE] = NOP;
        if (%write_refs) {
            vec($write_mask, $fd, 1) = 0;
            $write_mask =~ s/\x00+\z//;
        } else {
            $write_mask = "";
        }
    }

    sub Events::Error::DESTROY {
        defined(my $fd = ${shift()}) || die "No filedescriptor";
        ::caller_info("delete_error(%d, %s)", $fd,
                      ::object_name($error_refs{$fd}->[OBJ])) if $verbose > 1;
        # This strange assign after delete is to update the reference the for in
        # sub mainloop may still have in such a way that OBJ keeps existing
        # (otherwise a confess during the callback will access freed memory)
        # We could set either the object or the callback
        # But the object is already weak and the callback may be a closure
        delete($error_refs{$fd})->[CODE] = NOP;
        if (%error_refs) {
            vec($error_mask, $fd, 1) = 0;
            $error_mask =~ s/\x00+\z//;
        } else {
            $error_mask = "";
        }
        --$nr_events;
    }

    sub Events::Error0::DESTROY {
        defined(my $fd = ${shift()}) || die "No filedescriptor";
        ::caller_info("delete_error0(%d, %s)", $fd,
                      ::object_name($error_refs{$fd}->[OBJ])) if $verbose > 1;
        # This strange assign after delete is to update the reference the for in
        # sub mainloop may still have in such a way that OBJ keeps existing
        # (otherwise a confess during the callback will access freed memory)
        # We could set either the object or the callback
        # But the object is already weak and the callback may be a closure
        delete($error_refs{$fd})->[CODE] = NOP;
        if (%error_refs) {
            vec($error_mask, $fd, 1) = 0;
            $error_mask =~ s/\x00+\z//;
        } else {
            $error_mask = "";
        }
    }

    sub add_info {
        my ($name, $fd, $args) = @_;

        # Extremely important!
        # Without this we would change values through @_ in the add_xxxx caller
        $#$args = CODE;

        ::info("%s(%d, %s) [%s]",
               $name,
               $args->[FD] = $fd,
               ::object_name($args->[OBJ]),
               $args->[CALLERS] = ::callers(1));
        # UNIVERSAL::isa($args->[CODE], "CODE") || croak "Assertion: CODE is not CODE";
        # !UNIVERSAL::isa($args->[OBJ], "CODE") || croak "Assertion: OBJ is CODE";
    }

    sub add_read {
        defined(my $fd = fileno(shift)) || die_no_handle();
        add_info("add_read", $fd, \@_) if $verbose > 1;
        croak "Descriptor $fd already selected for read" if $read_refs{$fd};
        vec($read_mask, $fd, 1) = 1;
        # Cannot use \@_ here. That would weaken OBJ where stored in caller
        weaken(($read_refs{$fd} = [@_])->[OBJ]);
        ++$nr_events;
        return bless \$fd, "Events::Read";
    }

    sub add_read0 {
        defined(my $fd = fileno(shift)) || die_no_handle();
        add_info("add_read0", $fd, \@_) if $verbose > 1;
        croak "Descriptor $fd already selected for read" if $read_refs{$fd};
        vec($read_mask, $fd, 1) = 1;
        # Cannot use \@_ here. That would weaken OBJ where stored in caller
        weaken(($read_refs{$fd} = [@_])->[OBJ]);
        return bless \$fd, "Events::Read0";
    }

    sub add_write {
        defined(my $fd = fileno(shift)) || die_no_handle();
        add_info("add_write", $fd, \@_) if $verbose > 1;
        croak "Descriptor $fd already selected for write" if $write_refs{$fd};
        vec($write_mask, $fd, 1) = 1;
        # Cannot use \@_ here. That would weaken OBJ where stored in caller
        weaken(($write_refs{$fd} = [@_])->[OBJ]);
        ++$nr_events;
        return bless \$fd, "Events::Write";
    }

    sub add_write0 {
        defined(my $fd = fileno(shift)) || die_no_handle();
        add_info("add_write0", $fd, \@_) if $verbose > 1;
        croak "Descriptor $fd already selected for write" if $write_refs{$fd};
        vec($write_mask, $fd, 1) = 1;
        # Cannot use \@_ here. That would weaken OBJ where stored in caller
        weaken(($write_refs{$fd} = [@_])->[OBJ]);
        return bless \$fd, "Events::Write0";
    }

    sub add_error {
        defined(my $fd = fileno(shift)) || die_no_handle();
        add_info("add_error", $fd, \@_) if $verbose > 1;
        croak "Descriptor $fd already selected for error" if $error_refs{$fd};
        vec($error_mask, $fd, 1) = 1;
        # Cannot use \@_ here. That would weaken OBJ where stored in caller
        weaken(($error_refs{$fd} = [@_])->[OBJ]);
        ++$nr_events;
        return bless \$fd, "Events::Error";
    }

    sub add_error0 {
        defined(my $fd = fileno(shift)) || die_no_handle();
        add_info("add_error0", $fd, \@_) if $verbose > 1;
        croak "Descriptor $fd already selected for error" if $error_refs{$fd};
        vec($error_mask, $fd, 1) = 1;
        # Cannot use \@_ here. That would weaken OBJ where stored in caller
        weaken(($error_refs{$fd} = [@_])->[OBJ]);
        return bless \$fd, "Events::Error0";
    }

    sub __unloop {
        no warnings "exiting";
        last MAINLOOP;
    }

    my $unloop;
    # Exportable
    sub _unloop {
        return if $unloop;
        $unloop = bless {};
        $unloop->{timer} = Timer::immediate(
            $unloop,
            sub {
                $unloop = undef;
                no warnings "exiting";
                last MAINLOOP;
            });
    }

    sub events_fd {
        my $events = shift;
        for my $name (@refs) {
            my $refs = $refs{$name};
            push @$events, map {
                $refs->{$_} ?
                    sprintf("%-5s%s %2d -> %s",
                            ucfirst $name,
                            ref $refs->{$_} =~ /0\z/ ? " (dead)" : "",
                            $_,
                            ::object_name($refs->{$_}[OBJ])) : ()
                } sort { $a <=> $b } keys %$refs;
        }
    }

    sub _events {
        my @events;
        events_fd(\@events);
        Timer::events_immediate(\@events);
        Timer::events_timer(\@events);
        return \@events;
    }

    # Exportable
    sub events {
        return join("", map "$_\n", @{_events()});
    }

    # Exportable
    sub mainloop {
        # ::info("WARNING (can safely be ignored): $msghdr_error") if
        #    $msghdr_error && $verbose;
        ::info("Entering mainloop $$ (nr_events=$nr_events)") if $verbose;
        _mainloop();
        ::info("Exiting mainloop $$ (nr_events=$nr_events)") if $verbose;
    }

    # Exportable
    sub _mainloop {
        my ($r, $w, $e);
        # my $name;
      MAINLOOP:
        while ($nr_events) {
            if ((select($r = $read_mask,
                        $w = $write_mask,
                        $e = $error_mask,
                        Timer::timers_collect()) || next) > 0) {
                Timer::maybe_update_now();
                # The copy to @tmp is because the stack doesn't keep values
                # alive, so any deletes on xxx_refs during the loop can make
                # the value go poof. The copy temporarily increases the
                # refcount so the value doesn't go away. That is also why the
                # delete_xxx functions modify the value before delete
                # $name = $_->[CODE], $_->[OBJ]->$name for my @tmp=(
                $_->[CODE]->($_->[OBJ] || next) for my @tmp=(
                    @read_refs{ grep vec($r, $_, 1), keys %read_refs},
                    @write_refs{grep vec($w, $_, 1), keys %write_refs},
                    @error_refs{grep vec($e, $_, 1), keys %error_refs});
            } elsif ($! == EINTR) {
                redo;
            } else {
                die "Select failed: $^E";
            }
        } continue {
            Timer::timers_run();
        }
    }

    # for lib_extract
    #no warnings "once";
    #*IO::Handle::add_read	= \&add_read;
    #*IO::Handle::add_read0	= \&add_read0;
    #*IO::Handle::add_write	= \&add_write;
    #*IO::Handle::add_write0	= \&add_write0;
    #*IO::Handle::add_error	= \&add_error;
    #*IO::Handle::add_error0	= \&add_error0;
}

package Signals;
use Scalar::Util qw(weaken);

sub DESTROY {
    my ($signals) = @_;

    # This makes sure Signal::DESTROY uses the efficient code path
    $_ &&= 0 for values %{$signals->{count}};
    @{$signals->{signalled}} = ();
    %{$signals->{handlers}} = ();

    # The user can be holding on to some Signal objects so their DESTROY
    # doesn't get called and so some $SIG entries can survive. Kill them.
    for my $sig_name (sort keys %{$signals->{old}}) {
        ::caller_info("Restore signal $sig_name") if $verbose > 1;
        $SIG{$sig_name} = $signals->{old}{$sig_name};
    }
    %{$signals->{old}} = ();
}

{
    my $signals;

    sub init {
        my ($class) = @_;

        return $signals if $signals;

        my %signals = (
            signalled 	=> [],
            handlers	=> {},
            count	=> {},
            old		=> {},
        );
        pipe($signals{rd}, $signals{wr}) ||
            die "Could not create signal pipe: $^E";
        $signals{rd}->blocking(0);
        # Leave the write side blocking
        $signals{reader} = Events::add_read0($signals{rd}, \%signals, \&dealer);
        return $signals = bless \%signals, $class;
    }

    sub _cleanup_all {
        weaken(my $probe = $signals);
        $signals = undef;
        die "Assertion: Somebody is holding a reference to signals" if $probe;
    }

    sub signal_handler {
        my ($sig_name) = @_;

        $signals || die "Assertion: signal $sig_name without Signals object";
        $signals->{count}{$sig_name} ||
            die "Assertion: signal $sig_name without handlers";
        my $from = @{$signals->{signalled}} or
            syswrite($signals->{wr}, "x") ||
            die "Could not write to signal pipe: $^E";
        push @{$signals->{signalled}}, @{$signals->{handlers}{$sig_name}};
        for my $i ($from .. $#{$signals->{signalled}}) {
            weaken($signals->{signalled}[$i]);
        }
    }
}

package Signal;
use Errno qw(EINTR EAGAIN EWOULDBLOCK);
use Scalar::Util qw(weaken);

# Signal indices
use constant {
    SIGNALS	=> 0,
    NAME	=> 1,
    OBJ		=> 2,
    CODE	=> 3,
};

# Hard to classify this one. It belongs to both Signals and Signal really
sub Signals::dealer {
    my ($signals) = @_;

    while (@{$signals->{signalled}}) {
        my $handler = shift @{$signals->{signalled}} || next;
        # No need to check $handler->[SIGNALS] since we KNOW we have $signals
        defined $handler->[OBJ] || next;
        $handler->[CODE]->($handler->[OBJ], $handler->[NAME]);
    }

    # Avoid endless EINTR/read
    for my $i (1..100) {
        my $rc = sysread($signals->{rd}, my $buffer, $BLOCK_SIZE) && next;
        die "Assertion: EOF from signal pipe" if defined $rc;
        next if $! == EINTR;
        $! == EAGAIN || $! == EWOULDBLOCK ||
            die "error reading drom signal pipe: $^E";
        return;
    }
    die "Assertion: Seemingly endless read from signal pipe";
}

sub DESTROY {
    my ($handler) = @_;

    my $sig_name = $handler->[NAME];
    ::caller_info("delete_signal $sig_name") if $verbose > 1;

    my $signals = $handler->[SIGNALS] || return;

    if ($signals->{count}{$sig_name} > 1) {
        # This makes managing lots of handlers for the same signal
        # O(n^2). We could go for a doubly linked list of handlers or
        # some other datastructure if this ever becomes relevant
        my $handlers = $signals->{handlers}{$sig_name};
        my $to = 0;
        for my $i (0..$#$handlers) {
            next if !$handlers->[$i] || !defined $handlers->[$i][OBJ] || $handlers->[$i] == $handler;
            weaken($handlers->[$to] = $handlers->[$i]) if $i != $to;
            ++$to;
        }
        $#$handlers = $to-1;
        $to < $signals->{count}{$sig_name} ||
            die "Assertion: Could not find DESTROYed signal handler";
        return if $signals->{count}{$sig_name} = $to;
    }
    @{$signals->{handlers}{$sig_name}} = ();
    if (exists $signals->{old}{$sig_name}) {
        ::info("Restore signal $sig_name (deleted all signal callbacks)") if $verbose > 1;
        $SIG{$sig_name} = delete $signals->{old}{$sig_name};
    }
}

sub add0 {
    my $sig_name = shift;

    ::caller_info("add_signal $sig_name") if $verbose > 1;

    # We store $signals because if $signals gets cleaned up and restored
    # before Signal DESTROY we don't want it to impact the wrong object
    my $signals = Signals->init;
    my $handler = bless [$signals, $sig_name, shift, shift], "Signal";
    weaken($handler->[OBJ]);
    weaken($handler->[SIGNALS]);
    if (1 == ++$signals->{count}{$sig_name}) {
        ::caller_info("Take over_signal $sig_name") if $verbose > 1;
        $signals->{old}{$sig_name} = $SIG{$sig_name};
        $SIG{$sig_name} = \&Signals::signal_handler;
    }
    weaken($signals->{handlers}{$sig_name}[@{$signals->{handlers}{$sig_name}}] = $handler);
    return $handler;
}

{
    package Timer;
    # A small timer core
    # for lib_extract
    # use Events;
    use Scalar::Util qw(weaken refaddr);
    use Carp;
    use Time::HiRes qw(clock_gettime CLOCK_REALTIME CLOCK_MONOTONIC);

    my ($CLOCK_TYPE, $CLOCK_TYPE_NAME);
    BEGIN {
        $CLOCK_TYPE_NAME =
            eval { $CLOCK_TYPE = CLOCK_MONOTONIC; "MONOTONIC" } ||
            eval { $CLOCK_TYPE = CLOCK_REALTIME;  "REAL" } ||
            die "Time::HiRes doesn't even have CLOCK_REALTIME";
    }

    # Timer indices
    use constant {
        CLOCK_TYPE_NAME	=> $CLOCK_TYPE_NAME,
        CLOCK_TYPE	=> $CLOCK_TYPE,
        INFINITY	=> 9**9**9,

        INDEX	=> 0,
        TIME	=> 1,
        OBJ	=> 2,	# Must come after TIME
        CODE	=> 3,
        KEEPDEAD=> 4,
        CALLERS	=> 5,
    };

    # Exportable
    sub realtime {
        return clock_gettime(CLOCK_REALTIME);
    }

    # Exportable
    sub clocktime : method {
        return clock_gettime(CLOCK_TYPE);
    }
    BEGIN {
        # If clocktime() uses realtime, still enforce time never goes backward
        if ($CLOCK_TYPE_NAME ne "MONOTONIC") {
            no warnings "redefine";
            my $last = 1e-9;
            my $offset = $last-clocktime();
            *clocktime = sub {
                my $now = clock_gettime(CLOCK_TYPE) + $offset;
                return $last = $now if $now >= $last;
                $offset += $last - $now;
                return $last;
            };
        }
    }

    my @timers = (undef);
    # We put timers that go off in @expired. Timers created with immediate()
    # we don't even bother to put in @expires, they go into @immediate.
    # Both of these must be persistent in case a callback dies
    # (in case we catch mainloop() exceptions, otherwise the program just exits)
    my (@expired, @immediate);

    # Timers are kept in a simple binary heap @timers
    # Exportable
    sub timer {
        if ($verbose > 1) {
            my $v = $verbose;
            $verbose = 0;
            my $timer = timer(@_);
            $verbose = $v;
            my $callers = ::callers();
            $timer->[CALLERS] = $callers;
            ::info("add Timer(%s, %s) %08x [%s]",
                   $_[0], ::object_name($timer->[OBJ]), refaddr($timer), $callers);
            return $timer;
        }
        my $time = shift() + clocktime();
        my $i = @timers;
        while ($i > 1 && $time < $timers[$i >> 1][TIME]) {
            weaken($timers[$i] = $timers[$i >> 1]);
            $i = ($timers[$i][INDEX] = $i) >> 1;
        }
        my $timer = bless [$i, $time, shift, shift, 0];
        weaken($timer->[OBJ]);
        weaken($timers[$i] = $timer);
        ++$Events::nr_events;
        return $timer;
    }

    # Exportable
    sub timer0 {
        if ($verbose > 1) {
            my $v = $verbose;
            $verbose = 0;
            my $timer = timer0(@_);
            $verbose = $v;
            my $callers = ::callers();
            $timer->[CALLERS] = $callers;
            ::info("add0 Timer(%s, %s) %08x [%s]",
                   $_[0], ::object_name($timer->[OBJ]), refaddr($timer), $callers);
            return $timer;
        }
        my $time = shift() + clocktime();
        my $i = @timers;
        while ($i > 1 && $time < $timers[$i >> 1][TIME]) {
            weaken($timers[$i] = $timers[$i >> 1]);
            $i = ($timers[$i][INDEX] = $i) >> 1;
        }
        my $timer = bless [$i, $time, shift, shift, 1];
        weaken($timer->[OBJ]);
        weaken($timers[$i] = $timer);
        return $timer;
    }

    # Exportable
    sub immediate {
        # If we ever expose the TIME element we should put clocktime() there
        my $timer = bless [0, 0, shift, shift, 0];
        weaken($timer->[OBJ]);
        weaken($immediate[@immediate] = $timer);
        if ($verbose > 1) {
            my $callers = ::callers();
            $timer->[CALLERS] = $callers;
            ::info("add Immediate Timer(%s) %08x [%s]",
                   ::object_name($timer->[OBJ]), refaddr($timer), $callers);
        }
        ++$Events::nr_events;
        return $timer;
    }

    sub DESTROY {
        my ($timer) = @_;

        my $i = $timer->[INDEX];
        if ($verbose > 1 && defined $i) {
            if ($timer->[CALLERS]) {
                my $callers = ::callers();
                ::info("delete Timer(%s) %08x [%s], added at [%s]",
                       ::object_name($timer->[OBJ]),
                       refaddr($timer), $callers, $timer->[CALLERS]);
            } else {
                ::caller_info("delete Timer(%s) %08x",
                              ::object_name($timer->[OBJ]), refaddr($timer));
            }
        }
        if (!$i) {
            croak "Not a timer reference" unless defined($i);
            # Could be a timer sitting on the expired queue in run_now
            # This slicing will only be useful if not called by perl internals
            if (@$timer > TIME) {
                --$Events::nr_events unless $timer->[KEEPDEAD];
                $#$timer = TIME;
            }
            return;
        }
        --$Events::nr_events unless $timer->[KEEPDEAD];
        $timer->[INDEX] = 0;
        # Last element or beyond...
        if ($i >= $#timers) {
            croak "Not a timer reference" if $i > $#timers;
            pop @timers;
            return;
        }
        my $time = $timers[-1][TIME];
        if ($i > 1 && $time < $timers[$i >> 1][TIME]) {
            # percolate to root
            do {
                weaken($timers[$i] = $timers[$i >> 1]);
                $i = ($timers[$i][INDEX] = $i) >> 1;
            } while ($i > 1 && $time < $timers[$i >> 1][TIME]);
        } else {
            # percolate to leafs
            my $n = @timers-2;
            my $l = $i * 2;
            while ($l < $n) {
                if ($timers[$l][TIME] < $time) {
                    if ($timers[$l+1][TIME] < $timers[$l][TIME]) {
                        weaken($timers[$i] = $timers[$l+1]);
                        $timers[$i][INDEX] = $i;
                        $i = $l+1;
                    } else {
                        weaken($timers[$i] = $timers[$l]);
                        $timers[$i][INDEX] = $i;
                        $i = $l;
                    }
                } elsif ($timers[$l+1][TIME] < $time) {
                    weaken($timers[$i] = $timers[$l+1]);
                    $timers[$i][INDEX] = $i;
                    $i = $l+1;
                } else {
                    last;
                }
                $l = $i * 2;
            }
            if ($l == $n && $timers[$l][TIME] < $time) {
                weaken($timers[$i] = $timers[$l]);
                $timers[$i][INDEX] = $i;
                $i = $l;
            }
        }
        weaken($timers[$i] = pop @timers);
        $timers[$i][INDEX] = $i;
    }

    my $now;
    # Exportable
    sub update_now {
        return $now = clocktime();
    }

    # Exportable
    sub maybe_update_now {
        return $now ||= clocktime();
    }

    # Exportable
    sub now {
        return $now || die "Assertion: No current time";
    }

    sub timers_collect {
        if (@immediate) {
            my $from = @expired;
            push @expired, @immediate;
            weaken($expired[$_]) for $from .. $#expired;
            @immediate = ();
        }
        if (@timers <= 1) {
            return $now = undef unless @expired;
            # Not needed on an infinitely fast computer, but we want time in
            # $now to progress even in an infinite loop of immediates or with
            # slow callbacks
            $now = clocktime();
            return 0;
        }

        $now = clocktime();
        return @expired ? 0 : $timers[1][TIME] - $now if $timers[1][TIME] > $now;

        # We will expire at least 1 timer
        # @timers > 2 makes sure that if we pop @timers we don't remove $timers[1]
        while (@timers > 2) {
            $timers[1][INDEX] = 0;
            weaken($expired[@expired] = $timers[1]);

            my $time = $timers[-1][TIME];
            my $n = @timers-2;
            my $i = 1;
            my $l = 2;
            while ($l < $n) {
                if ($timers[$l][TIME] < $time) {
                    if ($timers[$l+1][TIME] < $timers[$l][TIME]) {
                        weaken($timers[$i] = $timers[$l+1]);
                        $timers[$i][INDEX] = $i;
                        $i = $l+1;
                    } else {
                        weaken($timers[$i] = $timers[$l]);
                        $timers[$i][INDEX] = $i;
                        $i = $l;
                    }
                } elsif ($timers[$l+1][0] < $time) {
                    weaken($timers[$i] = $timers[$l+1]);
                    $timers[$i][INDEX] = $i;
                    $i = $l+1;
                } else {
                    last;
                }
                $l = $i * 2;
            }
            if ($l == $n && $timers[$l][TIME] < $time) {
                weaken($timers[$i] = $timers[$l]);
                $timers[$i][INDEX] = $i;
                $i = $l;
            }
            weaken($timers[$i] = pop @timers);
            $timers[$i][INDEX] = $i;
            return 0 if $timers[1][TIME] > $now;
        }
        if (@timers == 2) {
            $timers[1][INDEX] = 0;
            weaken($expired[@expired] = pop @timers);
        }

        return 0;
    }

    sub timers_run {
        @expired || return;
        my $timer;

        # Using while instead of for in case a callback dies
        ($timer = shift @expired and
         $timer->[KEEPDEAD]++ || $Events::nr_events-- and
         $timer->[OBJ] and
         $timer->[CODE]->($timer->[OBJ])) while @expired;
    }

    sub events_immediate {
        my $events = shift;
        for my $timer (@immediate) {
            push @$events, sprintf("Immediate%s -> %s (id=%08x)",
                                   $timer->[KEEPDEAD] ?  " (dead)" : "",
                                   ::object_name($timer->[OBJ]),
                                   refaddr($timer)) if $timer;
        }
    }

    sub events_timer {
        my $events = shift;
        my $now = clocktime();
        push @$events, map {
            sprintf("Timer%s %2d -> %s (id=%08x timeout=%.3f)",
                    $_->[KEEPDEAD] ?  " (dead)" : "",
                    $_->[INDEX],
                    ::object_name($_->[OBJ]),
                    refaddr($_),
                    $_->[TIME]-$now,
                )
        } sort { $a->[TIME] <=> $b->[TIME] } grep defined, @timers;
    }
}

package Ids;
# Allocate and free unique numbers

# First id that will be given out
use constant INIT_ID => 1;

sub new {
    my $ids = bless {}, shift;
    $ids->id_init;
    return $ids;
}

sub id_init {
    my ($ids) = @_;

    $ids->{free_ids} = [];
    $ids->{free_id}  = INIT_ID() - 1;
}

sub id_alloc {
    my ($ids) = @_;

    return shift @{$ids->{free_ids}} || ++$ids->{free_id};
}

sub id_free {
    my ($ids, $id) = @_;

    push @{$ids->{free_ids}}, int $id;
    # Decrease free_ids some if we are lucky
    while (@{$ids->{free_ids}}) {
        if ($ids->{free_ids}[-1] == $ids->{free_id}) {
            --$ids->{free_id};
            pop @{$ids->{free_ids}};
        } elsif ($ids->{free_ids}[0] == $ids->{free_id}) {
            --$ids->{free_id};
            shift @{$ids->{free_ids}};
        } else {
            last;
        }
    }
}

sub count {
    my ($ids) = @_;

    return $ids->{free_id} - @{$ids->{free_ids}} + (1-INIT_ID);
}

sub id_check {
    die "Assertion: Inconsistent id usage [", ::callers() . "]\n";
}

package Ids2;
# Allocate and free unique numbers but server and client use different parity
# This allows each side to allocate without disturbing the other
use vars qw(@ISA);
@ISA = qw(Ids);

sub new {
    my $class = shift;
    my $ids = $class->SUPER::new(@_);
    $ids->{offset} = $ids->{free_id} + ($role eq "client" ? 1 : 0);
    return $ids;
}

sub id_alloc {
    return 2*$_[0]->SUPER::id_alloc() - $_[0]->{offset};
}

sub id_free {
    my $ids = shift;
    my $id = $ids->{offset} + shift;
    $ids->SUPER::id_free($id >> 1) unless $id &1;
}

sub id_check {
    my $ids = shift;
    my $id = $ids->{offset} + shift;
    $ids->SUPER::id_check($id) unless $id &1;
}

{
    package Address;
    use Socket qw(AF_INET pack_sockaddr_in unpack_sockaddr_in inet_aton inet_ntoa);
    use Carp qw(croak);

    sub new {
        my ($class, %options) = @_;

        # Make a (modified) copy if an object is passed
        return bless { %$class, %options }, ref $class if ref $class ne "";
        return bless \%options, $class;
    }

    my @ADDRESS_TYPES = ("", qw(tcp_name udp_name tcp4 udp4 tcp6 udp6));
    my %ADDRESS_TYPES = map {$ADDRESS_TYPES[$_], $_} 0..$#ADDRESS_TYPES;
    my %ADDRESS_DECODERS = (
        udp_name	=> \&decode_name,
        tcp_name	=> \&decode_name,
        tcp4		=> \&decode_ipv4,
        udp4		=> \&decode_ipv4,
    );
    my @ADDRESS_DECODERS;
    @ADDRESS_DECODERS[@ADDRESS_TYPES{keys %ADDRESS_DECODERS}] = values %ADDRESS_DECODERS;
    my %ADDRESS_MODES = (
        tcp_name	=> "stream",
        udp_name	=> "packet",
        tcp4	=> "stream",
        udp4	=> "packet",
    );
    my @ADDRESS_MODES;
    @ADDRESS_MODES[@ADDRESS_TYPES{keys %ADDRESS_MODES}] = values %ADDRESS_MODES;

    my $default_bind  = "127.0.0.1";

    sub number_from_type {
        my $type = ref $_[0] eq "" ? $_[1] : $_[0]->{type};
        return $ADDRESS_TYPES{$type} || die "Unknown type '$type'";
    }

    # IPv6 could use [fe80::240:63ff:fede:3c19]:1234 as notation (like RFC 3986)
    my %parse_regex = (
        tcp4	=> "(?:([^:/]*):|^)([^:/]*)",
        udp4	=> "(?:([^:/]*):|^)([^:/]*)",
    );

    my %from_defaults = (
        tcp4	=> "0.0.0.0:0",
        udp4	=> "0.0.0.0:0",
    );

    sub build_parser {
        my ($mode, $types, $matches) = @_;

        my @regex;
        $types = "TCP4" if !defined $types || $types eq "";
        for my $type (split /\|/, $types) {
            my $regex = $parse_regex{lc $type} || croak "Unknown $mode type '$type'";
            $regex =~ s/\((?!\?)/(?:/g;
            push @regex, "($regex)";
            push @$matches, [$mode, lc $type];
        }
        # print STDERR "REGEX: <@regex>\n";
        return join("|", @regex);
    }

    sub resolve {
        my ($address, $context) = @_;

        if ($address->{type} eq "udp_name") {
            $address->{type} = "udp4";
        } elsif ($address->{type} eq "tcp_name") {
            $address->{type} = "tcp4";
        } elsif ($address->{type} ne "udp4" && $address->{type} ne "tcp4") {
            die "Assertion: Unknown address type '$address->{type}'";
        }

        $address->{family} = AF_INET;
        $address->{addr} = inet_aton($address->{host}) ||
            die "Could not resolve $context '$address->{host}'\n";
        $address->{port} = $address->{port} =~
            # There is no port 0 in /etc/services so we can use ||
            /^0\z|^[1-9][0-9]*\z/ ? int($address->{port}) :
            $address->{type} =~ /^udp/ ? getservbyname($address->{port}, "udp") ||
            die("$context: Unknown UDP service '$address->{port}'\n") :
            $address->{type} =~ /^tcp/ ? getservbyname($address->{port}, "tcp") ||
            die("$context: Unknown TCP service '$address->{port}'\n") :
            die("Assertion: $context: Unknown type '$address->{type}'");
        $address->{host} = inet_ntoa($address->{addr});
        $address->{display} = "$address->{host}:$address->{port}";
        $address->{packed} = pack_sockaddr_in($address->{port}, $address->{addr});
    }

    sub parse {
        my ($class, $str, $context, %options) = @_;

        my $resolve = delete $options{resolve};
        my (@matches, @modes);
        my $regex = "";
        for my $mode (qw(from to)) {
            defined(my $types = delete $options{$mode}) || next;
            my $r = build_parser($mode, $types, \@matches);
            $regex = $regex eq "" ? $r : "(?:$regex:)?$r";
            push @modes, $mode;
        }
        die "Unknown option " . join(", ", map "'$_'", sort keys %options) if %options;
        my @matched = $str =~ /^$regex\z/ or
            die "Could not parse $context '$str'\n";
        my %matches;
        for my $i (0..$#matched) {
            defined(my $matched = $matched[$i]) || next;
            my ($mode, $type) =
                @{$matches[$i] || die "Assertion: Impossible match"};
            my @parts = $matched =~ $parse_regex{$type};
            if ($type eq "udp4" || $type eq "tcp4") {
                if (!defined $parts[0]) {
                    $parts[0] = $default_bind;
                } elsif ($parts[0] eq "") {
                    $parts[0] = $mode eq "from" ? "0.0.0.0" : "127.0.0.1";
                } elsif ($parts[0] eq "*") {
                    # die "Cannot connect to the $context '*'" if $mode eq "to";
                    $parts[0] = "0.0.0.0";
                }
                if (!defined $parts[1] || $parts[1] eq "") {
                    # die "Missing $context port" if $mode eq "to";
                    $parts[1] = "0";
                }
                $matches{$mode} = bless {
                    type	=> $type,
                    host	=> $parts[0],
                    port	=> $parts[1],
                    user	=> $matched,
                    display	=> "$parts[0]:$parts[1]",
                }, $class;
                $matches{$mode}->resolve($context) if $resolve;
            } else {
                die "Assertion: Type '$type' not implemented";
            }
        }
        my @result = @matches{@modes} or die "Assertion: No modes";
        if (@result == 2 && !defined $result[0]) {
            # Both from and to but no from part given
            my $type = $result[1]{type};
            my $from = $from_defaults{$type} ||
                die "$context: No default from for type '$type'";
            $result[0] = $class->parse($from, $context, from => $type, resolve => $resolve);
        }
        return @result if wantarray;
        croak "Cannot return multiple results in a scalar" if @result != 1;
        return $result[0];
    }

    sub from_packed {
        my ($class, $packed, $type) = @_;

        my ($port, $addr) = unpack_sockaddr_in($packed);
        my $host = inet_ntoa($addr);
        return bless {
            type	=> $type || croak("Missing type"),
            addr	=> $addr,
            host	=> $host,
            port	=> $port,
            display	=> "$host:$port",
            user	=> "$host:$port",
            # Normalize packed so it has no random bytes in any padding
            packed	=> pack_sockaddr_in($port, $addr),
        }, $class;
    }

    # The format we use on the LineProtocol wire
    sub decode {
        my ($class, $string, $mode, $resolve) = @_;

        my $type_num = unpack("C", substr($string, 0, 1, ""));
        my $decoder = $ADDRESS_DECODERS[$type_num] ||
            croak "No decoder for type number '$type_num'";
        my $type = $ADDRESS_TYPES[$type_num] ||
            croak "No type for type number '$type_num'";
        my $m = $ADDRESS_MODES[$type_num] ||
            croak "No mode for type number '$type_num'";
        $m eq $mode || croak "Type '$type' is for $m, not $mode";
        return $decoder->($class, $string, $type, $resolve);
    }

    sub decode_name {
        # @_ = ($class, $string, $type, $resolve)
        my $class = shift;

        my ($port, $host) = unpack("na*", shift);
        my $address = $class->new(
            type	=> shift,
            host	=> $host,
            port	=> $port,
            display	=> "$host:$port",
        );
        $address->resolve if shift;
        return $address;
    }

    sub decode_ipv4 {
        # @_ = ($class, $string, $type, $resolve)
        my $class = shift;

        my ($port, $addr) = unpack("na4", shift);
        my $host = inet_ntoa($addr);
        my $address = $class->new(
            type	=> shift,
            host	=> $host,
            port	=> $port,
            display	=> "$host:$port",
        );
        $address->resolve if shift;
        return $address;
    }

    sub encode {
        my ($address) = @_;

        return pack("Cna4",
                    $ADDRESS_TYPES{$address->{type}} ||
                    die("Unknown address type $address->{type}"),
                    @$address{qw(port addr)});
    }

    # Return a copy of $value (which is assumed to be resolved) but fill in the
    # old attribute (user) from the new attributes (display) of
    # $template (which is assumed to be unresolved)
    sub copy2 {
        my ($value, $template) = @_;

        $template->{type} eq $value->{type} || croak "Inconsistent type";
        return $value->new(user => $template->{display});
    }

    # Return a copy of $template (which is assumed not to be resolved)
    # Copy host 0.0.0.0 and port 0 from $value (which is assumed to be resolved)
    sub copy0_resolve {
        my ($template, $value, $context) = @_;

        $template->{type} eq $value->{type} || croak "Inconsistent type";
        my $result = bless {%$template}, ref $template;
        $result->{host} = $value->{host} if $result->{host} eq "0.0.0.0";
        $result->{port} ||= $value->{port};
        $result->resolve($context);
        return $result;
    }
}

my $TCP4_ANY = Address->parse("0.0.0.0:0", "ADDRESS_ANY", from => "tcp4", resolve => 1);
my $UDP4_ANY = Address->parse("0.0.0.0:0", "ADDRESS_ANY", from => "udp4", resolve => 1);
my $ADDRESS_TYPE_UDP4     = Address->number_from_type("udp4");
my $ADDRESS_TYPE_UDP_NAME = Address->number_from_type("udp_name");

package ConnUtils;
# Utilities to set up connections
# Other package should need less Socket exports this way
use Socket qw(PF_INET SOCK_DGRAM SOCK_STREAM
               SOL_SOCKET SO_REUSEADDR SO_KEEPALIVE TCP_NODELAY
               pack_sockaddr_in inet_aton);
use Errno qw(EADDRINUSE EPROTONOSUPPORT EACCES ENOPROTOOPT);
use POSIX qw(ceil);

# Should probably move this into Address
sub socket_udp_connected {
    my ($class, $address, $probe) = @_;

    socket(my $socket, PF_INET, SOCK_DGRAM, $PROTO_UDP) ||
        die "Could not create UDP socket: $^E";
    if ($probe) {
        connect($socket, $address->{packed}) || return $!;
        my $sockaddr = getsockname($socket) ||
            die "Assertion: Could not getsockname: $^E";
        return Address->from_packed($sockaddr, "udp4");
    }
    connect($socket, $address->{packed}) || die "Could not UDP connect to '$address->{display}': $^E";
    $socket->blocking(0);

    wantarray || return $socket;

    my $sockaddr = getpeername($socket) ||
        die "Assertion: Could not getpeername: $^E";
    return Address->from_packed($sockaddr), $socket;
}

sub socket_udp {
    my ($class, $address, $probe) = @_;

    socket(my $socket, PF_INET, SOCK_DGRAM, $PROTO_UDP) ||
        die "Could not create UDP socket: $^E";
    if ($probe) {
        return 1 if bind($socket, $address->{packed});
        $! == EADDRINUSE ||
            die "Could not bind socket to '$address->{display}': $^E";
        return 0;
    }
    bind($socket, $address->{packed}) ||
        die "Could not bind socket to '$address->{display}': $^E";
    $socket->blocking(0);
    wantarray || return $socket;

    my $sockaddr = getsockname($socket) ||
        die "Assertion: Could not getsockname: $^E";
    return Address->from_packed($sockaddr, "udp4")->copy2($address), $socket;
}

sub _socket_tcp {
    my ($settings, $address, $listen) = @_;

    socket(my $socket, PF_INET, SOCK_STREAM, $PROTO_TCP) ||
        die "Could not create TCP socket: $^E";
    if ($listen) {
        setsockopt($socket, SOL_SOCKET, SO_REUSEADDR, 1) ||
            die "Assertion: Could not setsockopt(SOL_SOCKET, SO_REUSEADDR): $^E";
        bind($socket, $address->{packed}) ||
            die "Could not bind socket to '$address->{display}': $^E";
        listen($socket, $LISTEN_BACKLOG) || die "Could not listen: $^E";
        $socket->blocking(0);
    } elsif (defined $listen) {
        bind($socket, $address->{packed}) ||
            die "Could not bind socket to '$address->{display}': $^E ", ::callers();
        _tcp_set($settings, $socket);
    } else {
        # This is a blocking connect
        connect($socket, $address->{packed}) ||
            die "Could not connect to '$address->{display}': $^E";
        _tcp_set($settings, $socket);
    }
    wantarray || return $socket;

    my $sockaddr = getsockname($socket) ||
        die "Assertion: Could not getsockname: $^E";
    my $local = Address->from_packed($sockaddr, "tcp4");
    $local->{user} = $address->{user} if
        defined $listen && defined $address->{user};
    return $local, $socket;
}

sub socket_icmp {
    my ($class, $host, $id) = @_;

    $host = "0.0.0.0" if !defined $host;
    $id = 0 if !defined $id;

    $id =~ /^0\z|^[1-9][0-9]*\z/  || die "Invalid id '$id'";
    my $addr = inet_aton($host) || die "Could not resolve '$host'";
    socket(my $socket, PF_INET, SOCK_DGRAM, $PROTO_ICMP) || do {
        return if $! == EPROTONOSUPPORT || $! == EACCES;
        die "Could not create ICMP socket: $^E";
    };
    my $local = pack_sockaddr_in($id, $addr);
    bind($socket, $local) || die "Could not bind socket: $^E";
    $socket->blocking(0);
    wantarray || return $socket;

    my $sockaddr = getsockname($socket) ||
        die "Assertion: Could not getsockname: $^E";
    return Address->from_packed($sockaddr), $socket;
}

my $CAN_KEEPALIVE = 1;
sub _tcp_set {
    my ($settings, $socket) = @_;

    $socket->blocking(0);
    setsockopt($socket, $PROTO_TCP, TCP_NODELAY, 1) ||
        die "Couldn't disable Nagle's algorithm: $^E";
    setsockopt($socket, SOL_SOCKET, SO_KEEPALIVE, 1) ||
        die "Couldn't enable keealive: $^E";
    if ($CAN_KEEPALIVE && defined $TCP_KEEPIDLE) {
        if (setsockopt($socket, $PROTO_TCP, $TCP_KEEPIDLE, ceil($settings->{KEEPALIVE}))) {
            if (defined $TCP_KEEPCNT && defined $TCP_KEEPINTVL) {
                my $interval = ceil($settings->{TIMEOUT} / $TCP_KEEPALIVE_PROBES);
                setsockopt($socket, $PROTO_TCP, $TCP_KEEPINTVL, $interval) ||
                    die "Couldn't set TCP_KEEPINTVL to $interval: $^E";
                setsockopt($socket, $PROTO_TCP, $TCP_KEEPCNT, $TCP_KEEPALIVE_PROBES) ||
                    die "Couldn't set TCP_KEEPCNT to $TCP_KEEPALIVE_PROBES: $^E";
            }
        } elsif ($! == ENOPROTOOPT) {
            ::info("Couldn't set TCP_KEEPIDLE: $^E") if $verbose > 1;
            $CAN_KEEPALIVE = 0;
        } else {
            die "Couldn't set TCP_KEEPIDLE: $^E";
        }
    }
}

# This is more subtle that it seems. It doesn't just not accept until data,
# it doesn't send the final ACK of the connect handshake leading to
# retransmits if the data is late. Still it is may be good fit for protocols
# that immediately expect data (like SOCKS)
my $CAN_DEFER_ACCEPT = 10;
sub defer_accept {
    my ($class, $socket) = @_;

    $CAN_DEFER_ACCEPT || return;
    if (defined $TCP_DEFER_ACCEPT) {
        setsockopt($socket, $PROTO_TCP, $TCP_DEFER_ACCEPT, $CAN_DEFER_ACCEPT) ||
            die "Couldn't set TCP_DEFER_ACCEPT: $^E";
    } else {
        $CAN_DEFER_ACCEPT = 0;
    }
}

package Object;
# Base class of elements in out Object Tree
# This should make it easy to clean up subtrees by simply deleting the root
use Scalar::Util qw(weaken isweak);
use Carp qw(croak);

use constant {
    UNFINISHED	=> 0,
    FINISHING	=> 1,
    FINISHED	=> 2,
    DELETING	=> 3,
    UNDELETED	=> 4,	# Special state for partnered. on_finish incomplete
    DELETED	=> 5,
};
 sub DESTROY { shift->caller_info("DESTROY") if $verbose > 2; }

sub new {
    my $class  = shift;
    my $parent = shift || croak "No parent";

    @_ % 2 == 0 || croak "Odd number of arguments";

    $parent->bug("Attempt to add '$class' child to cleaned Object") if $parent->{finished};
    my $object= bless {
        @_,
        finished	=> UNFINISHED,
        parent		=> $parent,
    }, $class;
    weaken($object->{parent});
    if (defined $object->{id}) {
        # Caller managed IDs
        $parent->{ids}{$class}->id_check($object->{id}) if $parent->{ids}{$class};
        $parent->bug("Child " . $object->name() . " already exists") if
            $parent->{children}{$class}{$object->{id}};
    } else {
        # Locally managed IDs
        $object->{id} = ($parent->{ids}{$class} ||= Ids->new)->id_alloc;
    }
    $parent->{children}{$class}{$object->{id}} = $object;

    $object->info("CREATE") if $verbose > 2;

    return $object;
}

# Neuter the obect. From here on it shouldn't do anything anymore
# It will however remain in the object tree. This is typically used
# to wait for remote finish of its mutual partner which in turn is
# important to make sure the id isn't reused until all messages stop
# Normally don't override this (override _finish instead)
sub finish {
    my $object = shift;

    if ($object->{finished}) {
        $object->bug("Recursive finish on '@_'") if
            $object->{finished} == FINISHING;
        return if $object->{finished} == UNDELETED;
        $object->bug("Double finish (state $object->{finished}) on '@_'");
    }
    $object->{finished} = FINISHING;
    $object->info("Finish: @_") if $verbose;
    if (my $classes = $object->{children}) {
        # The sorts shouldn't matter, but make bugs more repeatable and portable
        for my $class (sort keys %$classes) {
            my $children = $classes->{$class};
            # $children->{$_}->finish(@_) for sort { $a <=> $b } keys %$children;
            $children->{$_}->finish("Parent finish") for sort { $a <=> $b } keys %$children;
        }
    }
    $object->_finish(@_);
    $object->{finished} = FINISHED;
    $object->on_finish(@_);
}

# Subclasses override finish using this method to add their specific cleanups
sub _finish {
    delete shift->{timeout};
}

# Don't override this (see _on_finish instead)
sub on_finish {
    my $object = shift;

    $object->bug("on_finish while finished=$object->{finished} != FINISHED") if
        $object->{finished} != FINISHED;
    $object->{finished} = DELETING;
    $object->_on_finish(@_);
    if ($object->{finished} == DELETING) {
        $object->{finished} = UNDELETED;
    } elsif ($object->{finished} != DELETED) {
        $object->bug("Bad finished state $object->{finished}");
    }
}

# Subclasses override on_finish using this method
# The default is to remove the obect from the Object tree. This usually will
# lead to the Object being destroyed but it can linger if anyone has a reference
sub _on_finish {
    my $object = shift;

    $object->bug("on_finish while finished=$object->{finished}") if
        $object->{finished} != DELETING && $object->{finished} != UNDELETED;
    # We could recursively delete children first here, but we don't...
    # we assume that after the parent detach the current object soon won't be
    # referenced anymore and it and all its children will get recursively
    # destroyed. All children should be finished because finish() recursed down
    # to them. But the children could still hold ids (e.g. in an Ids object) or
    # have partners that now won't be cleaned. We however assume such ids are
    # managed by something on the same level as the current object so nothing
    # leaks and we even save time. Or for child partners that deleting the
    # current object will close the coonnection causing the partners to be
    # cleaned up anyways. If such is not the case and you didn't work around
    # that, then too bad...
    my $ids = $object->{parent}{ids}{ref $object};
    $ids->id_free($object->{id}) if $ids;
    delete $object->{parent}{children}{ref $object}{$object->{id}} ||
        $object->die("Already detached from Object tree");
    $object->{finished} = DELETED;
}

use vars qw(@dump_state $dumper);
sub dump : method {
    my ($object) = @_;

    print STDERR dumper($object);
}

sub dumper {
    local $dumper = Data::Dumper->new(\@_);
    $dumper->Freezer("freeze");
    local @dump_state;
    return $dumper->Dump;
}

sub Dump1::DESTROY {
    weaken(${$_[0][0]} = $_[0][1]);
}

sub Dump0::DESTROY {
    ${$_[0][0]} = $_[0][1];
}

sub _dump_save {
    push @dump_state, bless [\$_[0], $_[0]], isweak($_[0]) ? "Dump1" : "Dump0";
    $_[0] = $_[1];
}

sub dump_save {
    for my $val (@_) {
        next if ref $val eq "";
        _dump_save($val, "-- suppressed --");
    }
}

sub freeze {
    my $object = shift;

    push @_, "parent";
    dump_save(@$object{@_});
}

sub die : method {
    my $object = shift;
    my $format = shift;

    # Behave like sprintf, unlike builtin "die"
    if (!@_) {
        unshift @_, $format;
        $format = "%s";
    }
    my $msg = sprintf($format, @_);
    # Only add traceback if it doesn't end on \n (somewhat like builtin "die")
    $msg .= " [" . ::callers() . "]" unless $msg =~ s/\n\z//;

    $object->info("DIE: $msg") if $verbose;
    # Class call instead of object call
    die sprintf("%s: %s\n", $object, $msg) if ref $object eq "";
    # $object->finish($msg) unless $object->{finished};
    die sprintf("%s: %s\n", $object->name, $msg);
}

sub bug {
    my $object = shift;
    my $format = "Assertion: " . shift;

    # Forward to the die method using the same call frame (for better traceback)
    unshift @_, $object, $format;
    my $die = $object->can("die") || die "Assertion: no die method for die(@_)";
    goto $die;
}

sub error {
    my $object = shift;
    my $format = "Error: " . shift;

    # Forward to the die method using the same call frame (for better traceback)
    unshift @_, $object, $format;
    my $die = $object->can("die") || die "Assertion: no die method for die(@_)";
    goto $die;
}

sub error_finish {
    my $object = shift;
    my $format = "Error: " . shift;

    if (!@_) {
        unshift @_, $format;
        $format = "%s";
    }
    my $msg = sprintf($format, @_);
    $object->info($msg) if $verbose;
    $object->finish($msg);
}

sub id {
    return shift->{id};
}

sub _id_full {
    my ($object) = @_;

    return $object->{parent}->_id_full . ":" . $object->id;
}

sub id_full {
    my $id = shift->_id_full;
    $id =~ s/^://;
    return $id;
}

sub name {
    my ($object) = @_;

    return sprintf("%s[%s]", ref $object, $object->id_full);
}

sub _find {
    my ($object, $id_full, $name) = @_;

    $id_full =~ s/^:([^:]+)// || return undef;
    my $id = $1;
    my $classes = $object->{children} || return undef;
    # The sorts shouldn't matter, but make bugs more repeatable and portable
    for my $class (sort keys %$classes) {
        my $children = $classes->{$class} || next;
        my $child = $children->{$id} || next;
        return $child if $id_full eq "" && $child->name eq $name;
        my $found = $child->_find($id_full, $name);
        return $found if $found;
    }
    return undef;
}

# Tries to find an obect with name $name in the $object subtree
# Optmizes by assuming the id_full values are consistent, but does not
# assume each object is in it's proper class child list
# (The TCP::Forward class child list can have many kinds of objects)
sub find {
    my ($object, $name) = @_;

    my ($class, $id_full) = $name =~ /^( [^\[\]]* ) \[ ([^\[\]]*) \]\z/x or
        return "Invalid name '$name'";
    return $object if $name eq $object->name;
    return undef if $id_full eq "";
    my $base_id = $object->id_full;
    if ($base_id eq "") {
        $id_full = ":$id_full";
    } else {
        $id_full =~ s/\Q$base_id\E// || return undef;
    }
    return $object->_find($id_full, $name);
}

sub child {
    my ($object, $class, $id) = @_;
    return $object->{children}{$class}{$id};
}

# Move a child to a different class set
sub reclasify {
    my ($object, $class_to) = @_;

    # Be very paranoid since this is a risky move and we want too catch bugs
    my $parent = $object->{parent} ||
        $object->bug("Cannot rebless without a parent");
    my $class_from = ref $object;
    $class_from ne $class_to ||
        $object->bug("Cannot rebless from '$class_from' to itself");
    my $ids_from = $parent->{ids}{$class_from} ||
        $object->bug("Cannot rebless from '$class_from' without from Ids");
    my $ids_to = $parent->{ids}{$class_to} ||
        $object->bug("Cannot rebless to '$class_to' without to Ids");
    $ids_from == $ids_to ||
        $object->bug("Cannot rebless from '$class_from' to '$class_to' without equal Ids");
    $object->bug("Already have a '$class_to' child with id $object->{id}") if
        defined $parent->{children}{$class_to}{$object->{id}};
    my $o = delete $parent->{children}{$class_from}{$object->{id}} ||
        $object->bug("No '$class_from' child with id $object->{id}");
    if ($object != $o) {
        $parent->{children}{$class_from}{$object->{id}} = $o;
        $object->bug("Inconsistent '$class_from' child with id $object->{id}");
    }
    $parent->{children}{$class_to}{$object->{id}} = $o;
    return;
}

sub ids_set {
    my $object = shift;

    while (@_) {
        my $class = shift;
        my $ids = shift || Ids->new;
        $object->bug("Already have ids for class '$class'") if $object->{ids}{$class};
        $object->{ids}{$class} = $ids;
    }
}

sub ids_get {
    my ($object, $class) = @_;

    return $object->{ids}{$class} || $object->bug("No ids for class '$class'");
}

sub id_alloc {
    my ($object, $class) = @_;

    return $object->{ids}{$class}->id_alloc;
}

sub settings {
    my ($object) = @_;

    while ($object) {
        return $object->{settings} || next;
    } continue {
        $object = $object->{parent};
    }
    $_[0]->bug("No settings in parent chain");
}

sub tcp_set {
    my ($object, $socket) = @_;

    ConnUtils::_tcp_set(shift->settings, shift);
}

sub socket_tcp {
    ::ConnUtils::_socket_tcp(shift->settings, @_);
}

sub info {
    my $object = shift;
    my $format = shift;
    if (!@_) {
        @_ = ($format);
        $format = "%s";
    }
    unshift @_, "%s: " . $format, $object->name;
    goto &::info;
}

sub caller_info {
    my $object = shift;
    my $format = shift;
    if (@_) {
        @_ = ("%s: $format", $object->name, @_);
    } else {
        @_ = ("%s: %s", $object->name, $format);
    }
    goto &::caller_info;
}

sub immediate {
    my $object = shift;

    $object->{timeout} = Timer::immediate($object, shift);
}

sub timer {
    my $object = shift;

    $object->{timeout} = Timer::timer(shift, $object, shift);
}

sub timer0 {
    my $object = shift;

    $object->{timeout} = Timer::timer0(shift, $object, shift);
}

# Use ids
sub _count_children {
    my ($object, $class) = @_;

    my $ids = $object->{ids}{$class} ||
        $object->bug("No counter for class '$class'");
    return $ids->count;
}

# Use objects
sub count_children {
    my ($object, $class) = @_;

    return scalar keys %{$object->{children}{$class} || return 0};
}

sub status_all {
    my ($object, $control, $indent) = @_;

    $object->status($control, $indent);
    $indent .= "  ";
    for my $class (sort keys %{$object->{children} || return }) {
        my $children = $object->{children}{$class};

        $control->{collect} .= sprintf("%s%s: %s\n",
                                   $indent, $class, scalar keys %$children)
            if $class->can("status") == \&status || !%$children;
        $children->{$_}->status_all($control, $indent) for sort { $a <=> $b } keys %$children;
    }
}

sub status {
}

package Root;
# The root of our Object tree
use vars qw(@ISA);
@ISA = qw(Object);

use Carp qw(croak);
use Scalar::Util qw(weaken);

my $BASE_TIME  = Timer::realtime();
my $BASE_CLOCK = Timer::clocktime();
$BASE_CLOCK > 0 || die "Monotone clock $BASE_CLOCK was not positive";
my $root = 0;

sub new {
    my $class = shift;

    @_ % 2 == 0 || croak "Odd number of arguments";

    my $root = bless {
        @_,
        id		=> 0,
        id_full		=> "0",
        settings	=> { %settings_global },
        timeout		=> undef,
        signals		=> {},
        ping_queued	=> [],
    }, $class;
    $root->info("CREATE") if $verbose > 2;
    return $root;
}

sub _id_full {
    return "";
}

sub status {
    my ($root, $control, $indent) = @_;

    my $name = $root->name;
    my $settings = ::string_from_value($root->{settings});
    $settings =~ s/\n/\n$indent  /g;

    $control->{collect} .= <<"EOF"
$indent$name
$indent  Settings: $settings
EOF
        ;
}

sub _finish {
    my $root = shift;

    delete $root->{signals};
    $root->SUPER::_finish(@_);
}

# There is no parent to remove the root object from
sub _on_finish {
}

sub signal_add0 {
    my ($root, $sig_name, $code) = @_;

    $root->die("Already have signal '$sig_name'") if $root->{signals}{$sig_name};
    $root->{signals}{$sig_name} = Signal::add0($sig_name, $root, $code);
}

sub global_timeout {
    ::info("Global timeout") if $verbose;
    ::_cleanup_all();
    # The cleanup of the globals above should be enough to fall off mainloop
    # exit 1;
}

sub timeout {
    my ($root, $timeout) = @_;

    $root->{timeout} = Timer::timer0($timeout, $root, \&global_timeout);
    alarm($timeout+3);
}

sub client {
    my ($root, $socket_in, $socket_out, $connections, $client_only) = @_;

    my $line;
    eval {
        $line = LineProtocol->new(
            $root, $socket_in, $socket_out,
            client_only	=> $client_only,
        );

        my %connections = %$connections;
        for my $tcp (@{delete $connections{tcp_local}}) {
            my ($from, $to) = Address->parse($tcp, "TCP local", from => "tcp4", to => "tcp4");
            $from->resolve("TCP local");
            Listener::TCP::Forward->new_suspended($line, $from, remote => $to);
        }

        for my $socks (@{delete $connections{socks_local}}) {
            my $from = Address->parse($socks, "SOCKS local", from => "tcp4", resolve => 1);
            Listener::Socks::Local->new_suspended($line, $from);
        }

        for my $udp (@{delete $connections{fou_local}}) {
            my ($from, $to) =
                $udp =~ m{^([^%]+)%([^%]+)\z} or
                die "Invalid fou_local '$udp'";
            $from = Address->parse($from, "FOU local", from => "UDP4", resolve => 1);
            $to   = Address->parse($to  , "FOU local", to   => "UDP4", resolve => 1);
            my $fou = Fou::UDP->new($root, $to);
            Receiver::Fou->new_suspended($line, $from, $fou);
        }

        for my $name (sort keys %{$line->{settings}}) {
            if ($name eq "EPOCH") {
                $line->set_peer($name => $BASE_TIME);
            } elsif ($name eq "MSGHDR") {
                $line->set_peer($name => $msghdr_error || Socket::MsgHdr->VERSION);
            } else {
                $line->set_peer($name => $line->{settings}{$name});
            }
        }

        for my $tcp (@{delete $connections{tcp_remote}}) {
            # From needs to be resolved at the server side
            # To needs to be resolved at activation time
            my ($from, $to) = Address->parse(
                $tcp, "TCP remote",
                from => "TCP4",
                to   => "TCP4");
            my $id = TCP::Remote->new($line, remote => $to)->id;
            $line->write($LISTEN_REMOTE , pack("ww/a*a*", $id, $from->{type}, $from->{user}));
        }

        for my $socks (@{delete $connections{socks_remote}}) {
            my $from = Address->parse($socks, "SOCKS remote", from => "tcp4");
            # Currently we don't track which id this gets on the remote side
            $line->write($SOCKS_REMOTE, pack("w/a*a*", $from->{type}, $from->{user}));
        }

        for my $udp (@{delete $connections{fou_remote}}) {
            my ($from, $to) =
                $udp =~ m{^([^%]+)%([^%]+)\z} or
                die "Invalid fou_remote '$udp'";
            # Pure syntax check, resolving will be done remotely
            Address->parse($from, "FOU remote", from => "UDP4");
            Address->parse($to  , "FOU remote", to   => "UDP4");
            $line->write($FOU_REMOTE, $udp);
        }

        for my $control (@{delete $connections{control_remote}}) {
            # User doesn't get to do detailed control of sone random server
            die "Cannot setup remote control using a pure client connection" if
                $client_only;
            die "Not implemented (yet)"
        }

        my @unimplemented = grep @{$connections->{$_}}, sort keys %connections;
        die "Option @unimplemented not implemented (yet)" if @unimplemented;
        $line->write($START);
    };
    die "\u$role: $@" if $@;
    return $line;
}

sub server {
    my ($root, $socket_in, $socket_out) = @_;

    my $line;
    eval {
        $line = LineProtocol->new($root, $socket_in, $socket_out);

        $line->set_peer(EPOCH	 => $BASE_TIME);
        $line->set_peer(MSGHDR	 => $msghdr_error || Socket::MsgHdr->VERSION);
    };
    die "\u$role: $@" if $@;
    return $line;
}

sub ping_activate {
    my ($root, $line, $icmp) = @_;

    if ($root->count_children("Pinger") >= $root->{settings}{PING_MAX}) {
        weaken($root->{ping_queued}[@{$root->{ping_queued}}] = $line);
        return 0;
    }
    Pinger->new($root, $icmp);
    return 1;
}

sub ping_finished {
    my ($root) = @_;

    while (@{$root->{ping_queued}} &&
           $root->count_children("Pinger") < $root->{settings}{PING_MAX}) {
        my $line = shift @{$root->{ping_queued}} || next;
        weaken($root->{ping_queued}[@{$root->{ping_queued}}] = $line) if
            $line->ping_finished($root);
    }
}

package Connection;
# A class below Stream and Packet connections for shared methods
# Connection->new($parent, $socket_in, $socket_out, %options)
use vars qw(@ISA);
@ISA = qw(Object);

use Errno qw(ENOTCONN ENOTSOCK);

# If socket_in and socket_out are genuinly different it is the
# responsibity of the caller to shutdown() the write and read sides
# (if needed. pipes don't need it for example)
sub new_suspended {
    my $class = shift;
    return $class->SUPER::new(
        shift,
        socket_in	=> shift,
        socket_out	=> shift,
        reader		=> undef,
        writer		=> undef,
        timeout		=> undef,
        in		=> "",
        out		=> "",
        @_,
    );
}

sub new {
    my $class = shift;

    my $connection = $class->new_suspended(@_);
    $connection->resume_read("quiet") if $connection->{socket_in};
    return $connection;
}

sub _finish {
    my $connection = shift;

    delete @$connection{qw(in out reader writer socket_in black_hole socket_out unwritable)};
    $connection->SUPER::_finish(@_);
    ::cleanup_all() if $connection->{exit};
}

# {partner}: We are free to send stuff to the remote partner
# {partner_unfinish}: We expect stuff to receive stuff from the remote partner
sub _on_finish {
    my $connection = shift;

    $connection->finish_to_partner(@_) if delete $connection->{partner};
    if ($connection->{partner_unfinished}) {
        $connection->info("Suspend finish (waiting for remote)") if $verbose;
        return;
    }
    $connection->SUPER::_on_finish(@_);
}

# Tell remote to finish. This probably involves sending a message to the remote,
# which will be different for each type of Connection, so no implementation here
sub finish_to_partner {
    shift->bug("finish_to_partner not implemented (yet)");
}

# Remote tells us it is finished
sub finish_from_partner {
    my ($connection, $reason) = @_;

    # Do *NOT* delete {partner} here. That must remain until we send it a finish
    $reason || $connection->bug("finish_from_partner without reason");
    delete $connection->{partner_unfinished} ||
        $connection->bug("Double finish from partner");
    $reason = "Remote: $reason";
    if ($connection->{finished}) {
        $connection->info("Resume finish: $reason") if $verbose;
        $connection->SUPER::_on_finish($reason);
    } else {
        $connection->info("Remote finished: $_[1]") if $verbose;
        $connection->finished_remote($reason);
    }
}

# Tells local that partner finished. This probably means stop taking input
# and doing a complete finish if there is no more output.
# Being called implies finished=0, partner_unfinished has just been unset and
# partner can be anything
sub finished_remote {
    my ($connection, $reason) = @_;

    $connection->_end_read($reason) if
        $connection->{socket_in} && !$connection->{black_hole};
    # if end_read() causes a finish() we assume that will unset socket_out
    $connection->final_write($reason) if
        $connection->{socket_out} || $connection->{unwritable};
}

sub out_is_empty {
    my ($line) = @_;

    return shift->{out} eq "";
}

# Immediately stop writing. Never call this directly
# Override this if you have other events that lead to writing
# (e.g. LineProtocol needs to stop keepalives)
sub _end_write {
    my $connection = shift;

    $connection->{timeout} = undef;
    my $reason = $connection->{end_write} ||
        $connection->bug("No reason for _end_write");
    $connection->bug("_end_write() while unwritable") if
        $connection->{unwritable};
    if ($connection->{socket_in} && !$connection->{black_hole}) {
        # We are still interested in reading
        $connection->info("Keep reading, shutdown write: $reason") if $verbose;
        $connection->{writer} = undef;
        # e.g. STDOUT is probably not a socket, so you can't shut it down
        return shutdown(delete $connection->{socket_out}, 1) || $! == ENOTSOCK;
        $! == ENOTCONN || $connection->die("Could not shutdown write: $^E");
        # Avoid closing write/finish for unconnected UDP sockets
        return if $connection->isa("_UDP");
        $connection->info("Oops, lost the connection, so no more reading either") if $verbose > 1;
    } elsif ($verbose > 1) {
        $connection->info("I'm done. There is no reading and I finished writing: $reason");
    }
    $connection->finish($reason);
}

# Immediately stop reading. Never call this directly
sub _end_read {
    my ($connection, $reason) = @_;

    if ($connection->{socket_out} || $connection->{unwritable}) {
        # We are still interested in writing/connecting/accepting
        $connection->info("Keep writing, shutdown read: $reason") if $verbose;
        $connection->{reader} = undef;
        $connection->{black_hole} = undef;
        # e.g. STDIN is probably not a socket, so you can't shut it down
        if (shutdown(delete $connection->{socket_in}, 0) || $! == ENOTSOCK) {
            # Supposedly "in" is empty, so no need to truncate it
            $connection->eof_to_partner($reason) if $connection->{partner};
            return;
        }
        $! == ENOTCONN || $connection->die("Could not shutdown read: $^E");
        # Avoid closing read/finish for unconnected UDP sockets
        return if $connection->isa("_UDP");
        $connection->info("Oops, lost the connection, so no more writing either") if $verbose > 1;
        # finish() below will delete $connection->{socket_out}
    } elsif ($verbose > 1) {
        $connection->info("I'm done. There is no writing and I finished reading: $reason");
    }
    $connection->finish($reason);
}

sub eof_to_partner {
    shift->bug("eof_to_partner not implemented (yet)");
}

# Stop writing. But a connect can still be going on and there can still be stuff
# in the output buffer so only _end_write() once all pending activity is done
# It is perfectly fine to call this with socket_unwritable and/or no socket_out
sub final_write {
    my $connection = shift;

    # $connection->bug("Writing already finalized") if $connection->{end_write};
    $connection->{end_write} = shift ||
        $connection->bug("No write end reason");
    $connection->write(@_) if @_;
    # It's not a problem if a later write() overrides this timeout. On the
    # contrary, we WANT to process any extra bytes, the "end_write" will
    # remain active (do we really ? or does that indicate a bug ?)
    if (!$connection->{unwritable} && $connection->out_is_empty) {
        my $code = $connection->can("_end_write") ||
            $connection->bug("No _end_write method");
        $connection->{timeout} = $connection->immediate($code);
    }
}

# Stop reading
# By default we assume this means we finish once all pending activity is done
sub final_read {
    my ($connection, $reason) = @_;

    $connection->bug("final_read while finished") if $connection->{finished};
    $connection->_end_read($reason);
    # socket_out implies not finished
    $connection->final_write($reason) if
        ($connection->{socket_out} || $connection->{unwritable}) &&
        !$connection->{partner_unfinished};
}

sub suspend_read {
    my $connection = shift;

    $connection->info("suspend_read") if $verbose > 1;
    $connection->{reader} || $connection->die("Read already suspended");
    $connection->{reader} = undef;
}

# Keep socket_in open but completely ignore whatever is sent to it
# You usually want to combine thi with a final_write()
sub black_hole {
    my $connection = shift;

    $connection->{socket_in} || $connection->bug("No socket to black_hole");
    $connection->bug("Already a black hole") if $connection->{black_hole};
    $connection->info("Start completely ignoring input") if $verbose > 1;
    $connection->{black_hole} = 1;
    $connection->{in} = "";
}

sub timeout {
    shift->error("Write timeout");
}

# Think of the unwritable flag as
# "We may not have socket_out_now or aren't yet writing to it, but we plan to"
# (and {out} can already be used to accumate bytes)
# So call writable() once you have socket_out and are ready to write to it
sub writable {
    my ($connection) = @_;

    $connection->{socket_out} || $connection->bug("writable without socket");
    delete $connection->{unwritable} ||
        $connection->bug("Call writable() while state not unwritable");
    if (!$connection->out_is_empty) {
        $connection->writing;
    } elsif ($connection->{end_write}) {
        my $code = $connection->can("_end_write") ||
            $connection->bug("No _end_write method");
        $connection->{timeout} = $connection->immediate($code);
    }
}

sub status {
    my ($connection, $control, $indent) = @_;

    my $name = $connection->name;
    $control->{collect} .= "$indent$name\n";
    $control->{collect} .= "$indent  peer:   '$connection->{peer}{user}' [$connection->{peer}{display}]\n" if $connection->{peer};
    $control->{collect} .= "$indent  local:  '$connection->{local}{user}' [$connection->{local}{display}]\n" if $connection->{local};
    $control->{collect} .= "$indent  remote: '$connection->{remote}{user}' [$connection->{remote}{display}]\n" if $connection->{remote};
    $control->{collect} .= "$indent  partner: $connection->{partner}\n" if defined $connection->{partner};
    $control->{collect} .= "$indent  partner_unfinished: $connection->{partner_unfinished}\n" if defined $connection->{partner_unfinished};
    if (defined $connection->{address}) {
        for my $address (@{$connection->{address}}) {
            $control->{collect} .= "$indent  Address: '$address->{display}'\n";
        }
    }
}

package _Stream;
# Stream connections
# _Stream->new($parent, $socket_in, $socket_out, %options)
use vars qw(@ISA);
@ISA = qw(Connection);

use Errno qw(EINTR EAGAIN EWOULDBLOCK ECONNRESET EINPROGRESS);
use Socket qw(SOL_SOCKET SO_ERROR);

# Leave the option open to redirect conn_reset() to eof()
# If you do don't forget to deactivate events (reader, writer, timeout etc)
sub conn_reset {
    my $stream = shift;

    $stream->error(@_);
}

sub eof : method {
    my $stream = shift;

    $stream->final_read(shift);
}

sub reader {
    my ($stream) = @_;

    my $rc = sysread($stream->{socket_in}, my $buffer, $BLOCK_SIZE);
    if (!$rc) {
        if (defined $rc) {
            # EOF
            my $msg = $stream->{peer} ?
                "EOF from $stream->{peer}{display}" : "EOF";
            $stream->info("Received $msg") if $verbose > 1;
            $stream->{reader} = undef;
            $stream->eof($msg);
            # $stream->eof("EOF");
        } else {
            return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK;
            $stream->error("Could not sysread: $^E") if $! != ECONNRESET;
            $stream->conn_reset("Connection reset by peer");
        }
        return;
    }
    $stream->info("Received: %s", ::display($buffer)) if $verbose > 1;
    return if $stream->{black_hole};
    $stream->{in} .= $buffer;
    $stream->on_read($rc);
}

sub write : method {
    my $stream = shift;

    my $was_empty = $stream->{out} eq "";
    $stream->{out} .= join("", @_);
    $was_empty && $stream->{out} ne "" || return;
    $stream->writing();
}

sub writer {
    my ($stream) = @_;

    my $rc = syswrite($stream->{socket_out}, $stream->{out}, $BLOCK_SIZE);
    if (!$rc) {
        $stream->die("Zero write. Is this even possible ?") if defined $rc;
        return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK;
        $stream->error("Could not syswrite: $^E");
        return;
    }

    $stream->info("Wrote: %s (%d left)",
                  ::display(substr($stream->{out}, 0, $rc)),
                  length($stream->{out}) - $rc) if $verbose > 1;

    substr($stream->{out}, 0, $rc, "");
    if ($stream->{out} eq "") {
        $stream->{end_write} ?
            $stream->_end_write :
            $stream->on_empty;
        return;
    }
    $stream->writing();
}

sub on_empty {
    my ($stream) = @_;

    $stream->{writer}  = undef;
    $stream->{timeout} = undef;
}

sub connect : method {
    my ($stream) = @_;

    $stream->{peer} || $stream->bug("No peer");
    $stream->bug("Already unwritable") if $stream->{unwritable};
    $stream->bug("Already have an input socket")  if $stream->{socket_in};
    $stream->bug("Already have an output socket") if $stream->{socket_out};
    $stream->{unwritable} = 1;

    @$stream{qw(local socket_out)} =
        $stream->socket_tcp($stream->{local} || $TCP4_ANY, 0);
    if (connect($stream->{socket_out}, $stream->{peer}{packed})) {
        # Immediate connect
        $stream->{timeout} = Timer::immediate($stream, sub { shift->on_connect });
    } elsif ($! == EINPROGRESS || $! == EWOULDBLOCK) {
        $stream->info("Connecting to '$stream->{peer}{user}' [$stream->{peer}{display}]") if $verbose > 1;
        $stream->connecting;
    } else {
        # Immediate error
        my $err = $!;
        $stream->{timeout} = $stream->immediate(sub { shift->on_connect_error($err)});
    }
}

sub connect_timeout {
    shift->on_connect_error($ETIMEDOUT);
}

sub connected {
    my ($stream) = @_;

    $stream->{writer} = undef;
    # on_connect/on_connect_error will set timeout to undef
    # $stream->{timeout} = undef;

    my $packed = getsockopt($stream->{socket_out}, SOL_SOCKET, SO_ERROR) ||
        $stream->bug("Could not getsockopt(SOL_SOCKET, SO_ERROR): $^E");
    my $err = unpack("I", $packed) || ($stream->on_connect, return);
    $stream->on_connect_error($err = $! = $err);
}

sub on_connect_error {
    my ($stream, $err) = @_;

    $stream->{timeout} = undef;
    $stream->{writer}  = undef;
    $stream->{socket_out} = undef;
    # Leave unwritable

    $stream->error("Could not connect to '$stream->{peer}{user}' [$stream->{peer}{display}]: $err");
}

sub on_connect {
    my ($stream) = @_;

    $stream->{timeout} = undef;

    my $sockaddr = getsockname($stream->{socket_out}) ||
        die "Assertion: Could not getsockname: $^E";
    $stream->{local} = Address->from_packed($sockaddr, "tcp4");
    $stream->info("Connected from '$stream->{local}{display}' to '$stream->{peer}{user}' [$stream->{peer}{display}]: $!") if $verbose;

    $stream->{socket_in} = $stream->{socket_out};
    $stream->resume_read("quiet");
    $stream->writable;
}

package Stream;
# Stream connections that keep the program alive
# Stream->new($parent, $socket_in, $socket_out, %options)
use vars qw(@ISA);
@ISA = qw(_Stream);

sub writing {
    my ($stream) = @_;

    return if $stream->{unwritable};
    # This assumes parent == LineProtocol (or Root). Doesn't generalize
    $stream->{writer} ||= Events::add_write($stream->{socket_out}, $stream, \&_Stream::writer);
    $stream->{timeout} = Timer::timer($stream->{parent}{settings}{TIMEOUT}, $stream, \&Connection::timeout);
}

sub connecting {
    my ($stream) = @_;

    # This assumes parent == LineProtocol (or Root). Doesn't generalize
    $stream->{writer} = Events::add_write($stream->{socket_out}, $stream, \&_Stream::connected);
    $stream->{timeout} = $stream->timer($stream->{parent}{settings}{TIMEOUT_CONNECT}, \&connect_timeout);
}

sub resume_read {
    my $stream = shift;

    $stream->info("resume_read") if $verbose > 1 && !shift;
    $stream->{reader} && $stream->die("Read not suspended");
    $stream->{reader} = Events::add_read($stream->{socket_in}, $stream, \&_Stream::reader);
}

package Stream0;
# Stream connections that don't keep the program alive
# Stream0->new($parent, $socket_in, $socket_out, %options)
use vars qw(@ISA);
@ISA = qw(_Stream);

sub writing {
    my ($stream) = @_;

    return if $stream->{unwritable};
    # This assumes parent == LineProtocol (or Root). Doesn't generalize
    $stream->{writer} ||= Events::add_write0($stream->{socket_out}, $stream, \&_Stream::writer);
    $stream->{timeout} = Timer::timer($stream->{parent}{settings}{TIMEOUT}, $stream, \&Connection::timeout);
}

sub connecting {
    my ($stream) = @_;

    # This assumes parent == LineProtocol (or Root). Doesn't generalize
    $stream->{writer} = Events::add_write0($stream->{socket_out}, $stream, \&_Stream::connected);
    $stream->{timeout} = $stream->timer0($stream->{parent}{settings}{TIMEOUT_CONNECT}, \&connect_timeout);
}

sub resume_read {
    my $stream = shift;

    $stream->info("resume_read") if $verbose > 1 && !shift;
    $stream->{reader} && $stream->die("Read not suspended");
    $stream->{reader} = Events::add_read0($stream->{socket_in}, $stream, \&_Stream::reader);
}

package _UDP;
# Base class for UDP connections (maybe add a Packet parent later)
# _UDP->new($parent, $socket_in, $socket_out, %options)
use vars qw(@ISA);
@ISA = qw(Connection);

use Errno qw(EINTR EAGAIN EWOULDBLOCK EMSGSIZE);
use Socket qw(unpack_sockaddr_in inet_ntoa MSG_TRUNC MSG_CTRUNC);

sub new_suspended {
    my $class = shift;

    my $udp = $class->SUPER::new_suspended(
        shift, shift, shift,
        out => [],
        @_,
    );
    if ($udp->{socket_in}) {
        !$msghdr ||
            setsockopt($udp->{socket_in}, $IPPROTO_IP, $IP_RECVTTL, 1) ||
            $udp->die("setsockopt(IPPROTO_IP, IP_RECVTTL): $^E");
    }
    return $udp;
}

sub reader {
    my ($udp) = @_;

    my ($sockaddr, $bufref, $ttl);
    if ($msghdr) {
        $msghdr->{name} = "\0" x 256;
        $msghdr->{buf}  = "\0" x $UDP_SIZE;
        $msghdr->{control} = "\0" x 256;
        $msghdr->{flags} = 0;
        if (defined ::recvmsg($udp->{socket_in}, $msghdr)) {
            # I suspect Socket::MsgHdr has a bug so that flags is never set
            $udp->die("Yikes! Buffer was truncated") if
                        $msghdr->flags & MSG_TRUNC;
            $udp->die("Yikes! Ancillary data was truncated") if
                $msghdr->flags & MSG_CTRUNC;
            $bufref = \$msghdr->{buf};
            $sockaddr = $msghdr->{name};
            my ($level, $type, $data) =
                ::unpack_cmsghdr($msghdr->{control}) or
                $udp->bug("No ancillary data from socket");
            $level == $IPPROTO_IP ||
                $udp->bug("Unexpected level in ancillary data");
            $type == $IP_TTL ||
                $udp->bug("Unexpected type in ancillary data");
            $ttl = unpack("I", $data);
        }
    } else {
        $sockaddr = recv($udp->{socket_in}, my $buffer, $UDP_SIZE, 0);
        $bufref = \$bufref;
        $ttl = $TTL;
    }
    if (!defined $sockaddr) {
        return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK;
        $udp->error("Could not receive: $^E");
        return;
    }
    my $from = Address->from_packed($sockaddr, "udp4");
    # No special handling for length 0.
    # It's perfectly fine to send and receve empty UDP packets
    $udp->info("Received from %s%s: %s",
               $from->{display}, $msghdr ? " (TTL $ttl)" : "",
               ::display($$bufref)) if $verbose > 1;
    return if $udp->{black_hole};
    $udp->on_read($from, $ttl, $bufref);
}

sub timeout {
    shift->error("Send timeout");
}

sub out_is_empty {
    my ($line) = @_;

    return @{shift->{out}} == 0;
}

sub writing {
    my ($udp) = @_;

    return if $udp->{unwritable};
    # This assumes parent == LineProtocol (or Root). Doesn't generalize
    $udp->{writer} ||= Events::add_write($udp->{socket_out}, $udp, \&writer);
    $udp->{timeout} = Timer::timer($udp->{parent}{settings}{TIMEOUT}, $udp, \&timeout);
}

sub write : method {
    # @_ = ($udp, $to, $data, $ttl) if no $udp->{peer}
    # @_ = ($udp,      $data, $ttl) if    $udp->[peer}
    my $udp = shift;
    my $to = ($udp->{peer} || shift)->{packed};

    return if 1 != push @{$udp->{out}}, defined $_[1] && $msghdr ?
        bless {
            name => $to,
            buf  => shift,
            control => ::pack_cmsghdr(
                $IPPROTO_IP,
                $IP_TTL,
                pack("I", shift || die "Assertion: TTL 0")),
            flags => 0,
        }, "Socket::MsgHdr" :
        [$to, shift];
    $udp->writing;
}

sub writer {
    my ($udp) = @_;

    my $data = $udp->{out}[0];
    if (ref $data ne "ARRAY") {
        my $rc = ::sendmsg($udp->{socket_out}, $data);
        if (!defined $rc) {
            return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK;
            if ($! == EMSGSIZE) {
                $udp->info("Cannot send oversized packet. Dropped") if $verbose > 1;
                goto DROP;
            }
            $udp->error("Could not send: $^E");
            return;
        }
        if ($verbose > 1) {
            my ($port, $addr) = unpack_sockaddr_in($data->{name});
            $udp->info("Wrote data (TTL %d) to %s:%d (%d left): %s",
                       unpack("I",(::unpack_cmsghdr($udp->{out}[0]->{control}))[2]),
                       inet_ntoa($addr), $port, length($data->{buf}) - $rc,
                       ::display(substr($data->{buf}, 0, $rc)));
        }
        $rc == length($data->{buf}) ||
            $udp->bug("Incomplete send ($rc of " . length($data->{buf}) . ")");
    } else {
        my $rc = send($udp->{socket_out}, $data->[1], 0, $data->[0]);
        if (!defined $rc) {
            return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK;
            if ($! == EMSGSIZE) {
                $udp->info("Cannot send oversized packet. Dropped") if $verbose > 1;
                goto DROP;
            }
            $udp->error("Could not send: $^E");
            return;
        }
        if ($verbose > 1) {
            my ($port, $addr) = unpack_sockaddr_in($data->[0]);
            $udp->info("Wrote to %s:%d: %s (%d left)",
                       inet_ntoa($addr), $port,
                       ::display(substr($data->[1], 0, $rc)),
                       length($data->[1]) - $rc);
        }
        $rc == length($data->[1]) ||
            $udp->bug("Incomplete send ($rc of " . length($data->[1]) . ")");
    }

  DROP:
    shift @{$udp->{out}};
    if (@{$udp->{out}}) {
        $udp->writing;
    } else {
        $udp->{writer}  = undef;
        $udp->{timeout} = undef;
    }
}

package UDP;
# UDP connections that keep the program alive
# UDP->new($parent, $socket_in, $socket_out, %options)
use vars qw(@ISA);
@ISA = qw(_UDP);

sub resume_read {
    my $udp = shift;

    $udp->info("resume_read") if $verbose > 1 && !shift;
    $udp->{reader} && $udp->die("Read not suspended");
    $udp->{reader} = Events::add_read($udp->{socket_in}, $udp, \&_UDP::reader);
}

package UDP0;
# UDP connections that keep the program alive
# UDP->new($parent, $socket_in, $socket_out, %options)
use vars qw(@ISA);
@ISA = qw(_UDP);

sub resume_read {
    my $udp = shift;

    $udp->info("resume_read") if $verbose > 1 && !shift;
    $udp->{reader} && $udp->die("Read not suspended");
    $udp->{reader} = Events::add_read0($udp->{socket_in}, $udp, \&_UDP::reader);
}

package Pinger;
# Manage runs of the OS ping program
# Pinger->new($root, $client)
use vars qw(@ISA);
# We maybe should introduce a StreamReader for only the read part of Stream
@ISA = qw(Stream0);

use Scalar::Util qw(weaken);
use Socket qw(inet_aton);

sub new_suspended {
    my ($class, $root, $client) = @_;

    my ($host, $data) = $client->host_data;
    pipe(my $rd0, my $wr0) || $class->die("Could not open pipe: $^E");
    pipe(my $rd1, my $wr1) || $class->die("Could not open pipe: $^E");

    defined(my $pid = fork()) || $class->die("Could not fork: $^E");
    if ($pid == 0) {
        # Child
        select($wr1);
        $| = 1;
        eval {
            close($rd0) || $class->die("Could not close pipe: $^E");
            close($rd1) || $class->die("Could not close pipe: $^E");
            open(STDIN,  "<&", $null) || $class->die("Could not dup to STDIN: $^E");
            open(STDOUT, ">&", $wr0)  || $class->die("Could not dup to STDOUT: $^E");
            close($wr0) || $class->die("Could not close pipe: $^E");
            # open(STDERR, ">&STDOUT")  || die "Could not dup to STDERR: $^E";
            $SIG{CHLD} = "DEFAULT";
            no warnings "exec";
            exec(@{$PING[0]}, $host, @{$PING[1]}) ||
                $class->die("Could not exec $PING[0][0]: $^E");
        };
        print $@ || "Assertion: Pinger ended without error\n";
        _exit(1);
    }

    # Parent
    close($wr0) || $class->die("Could not close pipe: $^E");
    close($wr1) || $class->die("Could not close pipe: $^E");
    $rd0->blocking(0);
    $rd1->blocking(0);

    my $pinger = $class->SUPER::new_suspended(
        $root, $rd1, undef,
        waitable	=> undef,
        handle		=> $rd0,
        pid		=> $pid,
        parent_pid	=> $$,
        host		=> $host,
        data		=> $data);
    weaken($pinger->{client} = $client);

    $pinger->info("waiting to spawn ping '%s'",
                  $pinger->{host}) if $verbose > 1;
    # $pinger->info("Created");

    return $pinger;
}

sub wait : method {
    return undef if defined $SIG{CHLD} && $SIG{CHLD} eq "IGNORE";
    my ($pinger) = @_;

    my $pid = $pinger->{pid};
    return undef if $pinger->{parent_pid} != $$ || !$pid;
    $pinger->{pid} = undef;
    my $p = waitpid($pid, 0);
    if ($p != $pid) {
        $pinger->die("Could not wait for pid '$pid'") if $p < 0;
        $pinger->bug("Invalid pid result") if $p != $pid;
    }
    # die "Unexpected exitcode $? from ping $pinger->{host} (pid $pid)" if $?;
    return $?;
}

sub eof : method {
    my $pinger = shift;

    if ($pinger->{handle}) {
        # Read from the probe pipe
        $pinger->{socket_in} = delete $pinger->{handle};
        $pinger->die($pinger->{in}) if $pinger->{in} ne "";
        $pinger->{reader} = Events::add_read0($pinger->{socket_in}, $pinger, \&_Stream::reader);
        $pinger->info("Spawned. Switch to reading ping result") if $verbose > 1;
        return;
    }

    $pinger->{waitable} = 1;
    my $client = $pinger->{client};
    if (my ($ip, $ttl, $time) =
        $pinger->{in} =~ /from (\d+\.\d+\.\d+\.\d+).* icmp_[sr]eq.* ttl=(\d+).* time=(\S+ (?:ms|usec))/) {
        $pinger->info("Response from '%s' ttl=%d, time=%s",
                      $ip, $ttl, $time) if $verbose > 1;
        $ip eq $pinger->{host} ||
            $pinger->bug("Inconsistent: pinged '$pinger->{host}', got answer from '$ip'");
        $client->ping_result($pinger->{data}, $ttl, $time) if $client;
    } else {
        if ($verbose > 1) {
            if ($pinger->{in} eq "") {
                $pinger->info("No response from '%s'",
                              $pinger->{host}) if $verbose > 1;
            } else {
                $pinger->info("No result in response from '%s': %s",
                              $pinger->{host}, ::display($pinger->{in})) if $verbose > 1;
            }
        }
        $client->ping_result($pinger->{data}) if $client;
    }
    $pinger->finish("Ping result");
}

sub _finish {
    my $pinger = shift;

    delete $pinger->{data};
    $pinger->wait if $pinger->{waitable};
    $pinger->SUPER::_finish(@_);
    # ping_finished AFTER SUPER_finish so the id is freed and we won;t
    # start using ids above ping_max which looks super confusing
    $pinger->{parent}->ping_finished;
}

sub on_read {
    # Process neiher the probe pipe nor the result pipe during read
    # We could check for insanely long output here
}

sub status {
    my ($pinger, $control, $indent) = @_;

    my $name = $pinger->name;

    $control->{collect} .= <<"EOF"
$indent$name
$indent  Host: $pinger->{host}
$indent  Pid:  $pinger->{pid}
EOF
        ;
}

package Sender::ICMP;
# Send and receive ICMP (echo) messages
# Falls back to using the OS ping program if not permitted
# Sender::ICMP->new($line, $id)
use vars qw(@ISA);
@ISA = qw(UDP);

use Socket qw(inet_ntoa);

sub new_suspended {
    my ($class, $line, $id) = @_;

    # Notice this can return nothing if we can't open an UDP icmp socket
    # (either not supported on OS or user not in allowed grooup)
    my ($local, $socket) = ConnUtils->socket_icmp("0.0.0.0", 0);
    !$msghdr || !$socket || setsockopt($socket, $IPPROTO_IP, $IP_RECVTTL, 1) ||
        die "setsockopt(IPPROTO_IP, IP_RECVTTL): $^E";
    # ICMP_FILTER always gets me ENOPROTOOPT
    # However when /bin/ping does it (when sysctl group NOT set) it works???
    # !$socket || setsockopt($socket, $SOL_RAW, $ICMP_FILTER, 0xffffffff ^ 1<<$ICMP_ECHO_REPLY) ||
    #    die "setsockopt(SOL_RAW, ICMP_FILTER): $^E" if defined $ICMP_FILTER;

    my $icmp = $class->SUPER::new_suspended(
        $line, $socket, $socket,
        id		=> $id,
        pid		=> $$,
        local		=> $local,
        icmp_id		=> $local->{port},
        pending		=> 0);

    if ($verbose > 1) {
        if ($socket) {
            $icmp->info("New ICMP socket '%s'", $local->{display});
        } else {
            $icmp->info("Using external ping");
        }
    }

    return $icmp;
}

sub on_read {
    my ($icmp, $from, $ttl, $bufref) = @_;

    # 16 bytes MD5, 4 bytes rand, 4 bytes src, 2 bytes id, 2 bytes seqno
    # and at least 1 fou_id byte
    length $$bufref >= $ICMP_HEADER + (16+4+4+2+2+1) || return;
    $$bufref .= "\0";
    my $sum = unpack("%32n*", $$bufref);
    my ($type, $code, $icmp_chksum, $icmp_id, $seqno) =
        unpack("wwn3", substr($$bufref, 0, $ICMP_HEADER, ""));
    chop $$bufref;
    if (1 || $icmp_chksum) {
        while ($sum > 0xffff) {
            my $carry = $sum >> 16;
            $sum &= 0xffff;
            $sum += $carry;
        }
        $sum == 0xffff || return;
    }
    $type == $ICMP_ECHO_REPLY || return;
    $code == 0 || return;

    $icmp->info("ICMP ECHO Payload (Type %d, Code %d, Id %d, Seqno %d) from %s: %s",
                $type, $code, $icmp_id, $seqno, $from->{host},
                ::display($$bufref)) if $verbose > 1;
    $icmp->{parent}->write($RESPONSE_PING, pack("wa4C", $icmp->{id}, $from->{addr}, $ttl-1), $$bufref) if $ttl > 1;
}

sub write : method {
    # @_ = ($icmp, $dst, $seqno, $data, $ttl)
    my $icmp = shift;

    if (!$icmp->{socket_out}) {
        $icmp->info("Queue external ping %s [seqno %d]", inet_ntoa($_[0]), $_[1]) if $verbose;
        # We could retry acquiring an ICMP socket here
        $icmp->{parent}->ping_activate($icmp) if
            1 == push @{$icmp->{out}}, [shift, shift, shift];
        return;
    }

    my $dst = shift;
    $icmp->info("Need to send ICMP ECHO (Type %d, Code 0, Id %d, Seqno %d, TTL %d) to %s: %s",
                $ICMP_ECHO_REQUEST, $icmp->{icmp_id}, @_[0,2], inet_ntoa($dst),
                ::display($_[1])) if $verbose > 1;

    my $data = pack("Cx3n2a*x", $ICMP_ECHO_REQUEST, $icmp->{icmp_id},
                    shift, shift);
    my $sum = unpack("%32n*", $data);
    chop $data;
    while ($sum > 0xffff) {
        my $carry = $sum >> 16;
        $sum &= 0xffff;
        $sum += $carry;
    }
    substr($data, 2, 2, pack("n", 0xffff - $sum));
    $icmp->SUPER::write(0, $dst, $data, shift);
}

sub host_data {
    my ($icmp) = @_;
    my $out = shift @{$icmp->{out}} || $icmp->bug("Empty ping queue");
    return inet_ntoa($out->[0]), $out;
}

sub ping_result {
    my ($icmp, $out, $ttl, $time) = @_;

    $icmp->{parent}->write($RESPONSE_PING, pack("wa4C", $icmp->{id}, $out->[0], $ttl-1), $out->[2]) if defined $ttl && $ttl > 1;
}

sub ping_finished {
    my ($icmp, $line, $root) = @_;

    @{$icmp->{out}} || $icmp->bug("Empty out was queued");
    $root->ping_activate($line, $icmp);
    return scalar @{$icmp->{out}};
}

package Sender::UDP;
# Send out packets at the remote side (and wait for replies)
# Sender::UDP->new($line, $id)
use vars qw(@ISA);
@ISA = qw(UDP);

sub new_suspended {
    my ($class, $line, $id) = @_;

    my ($local, $socket) = ConnUtils->socket_udp($UDP4_ANY);

    my $sender = $class->SUPER::new_suspended(
        $line, $socket, $socket,
        id		=> $id,
        local		=> $local);

    $sender->info("Local address '%s'", $local->{display}) if $verbose > 1;
    return $sender;
}

sub on_read {
    my $sender = shift;
    # Now: @_ = ($from, $ttl, $dataref)
    $sender->{parent}->write($RESPONSE_UDP, pack("ww/a*C", $sender->{id}, shift->encode, shift()-1), ${shift()}) if $_[1] > 1;
}

package Receiver::Fou;
# Wait for packets at the local (client) side
# Sender::UDP->new($line, $from, $fou)
use vars qw(@ISA);
@ISA = qw(UDP);

use Socket qw(inet_ntoa pack_sockaddr_in);
use Digest::MD5 qw(md5);

sub new_suspended {
    my ($class, $line, $from, $fou) = @_;

    my ($local, $socket) = ConnUtils->socket_udp($from);

    my $listener = $class->SUPER::new_suspended(
        $line, $socket, undef,
        local		=> $local,
        fou_id		=> $fou->id);

    $listener->info("Listening on '%s'", $local->{display}) if $verbose > 1;
    return $listener;
}

sub on_read {
    # @_ = ($listener, $from, $ttl, $dataref)
    my ($listener, undef, undef, $bufref) = @_;

    my ($ihl, $ecn, $length, $id, $fragment, $ttl, $proto, $chksum, $nsrc, $ndst) = unpack("CCnnnCCna4a4", $$bufref);
    if ($verbose > 2) {
        $listener->info(
            "TEMP: IHL=%d, ECN=%d, LEN=%d, ID=%d, FRAGMENT=%#04X, TTL=%d, PROTO=%d, CHK=%#04X, SRC=%s, DST=%s\n",
            $ihl, $ecn, $length, $id, $fragment, $ttl, $proto, $chksum,
            inet_ntoa($nsrc), inet_ntoa($ndst));
    }

    # Don't handle spammy multicast stuff (in my case mostly OSPF)
    return if $MULTICAST_BEGIN le $ndst && $ndst lt $MULTICAST_END;

    my $version = $ihl >> 4;
    $ihl &= 0xf;
    my $flags = $fragment >> 13;
    $fragment &= 0x1fff;
    # only TCP4
    $version == $IP_VERSION || return;
    # Sanity check on buffer
    length($$bufref) == $length || return;
    # We don't handle IP options (yet)
    $ihl == $IHL || return;
    # Too many hops
    $ttl > 1 || return;
    # Don't handle fragments (fragment offset)
    return if $fragment;
    # Don't handle fragments (MF flag set)
    return if $flags & 0x1;

    $ihl *= 4;
    my $header = substr($$bufref, 0, $ihl, "");
    $length -= $ihl;

    # No buffer padding needed since length($header) is even
    my $sum = unpack("%32n*", $header);
    while ($sum > 0xffff) {
        my $carry = $sum >> 16;
        $sum &= 0xffff;
        $sum += $carry;
    }
    $sum == 0xffff || return;

    my $src = inet_ntoa($nsrc);
    my $dst = inet_ntoa($ndst);

    # print "Sender $peer:$peer_port, Receiver $local [$msg_dst]\n";

    my $dscp = $ecn >> 3;
    $ecn &= 0x7;
    # print "HEADER: DSCP=$dscp, ECN=$ecn, ID=$id, FLAGS=$flags, FRAGMENT=$fragment, TTL=$ttl, CHKSUM=$chksum, SRC=$src, DST=$dst\n";

    if ($proto == $PROTO_UDP) {
        # Only UDP

        # Must have space for UDP header
        return if $length < $UDP_HEADER;

        my $pseudo10 = pack("a4a4xC", $nsrc, $ndst, $proto);
        # Pad buffer with \0 so a last single byte still gets processed as "n"
        $sum = unpack("%32n*", $$bufref . "\x0") + unpack("%32n*", $pseudo10) + $length;
        my ($sprt, $dprt, $udp_len, $udp_chksum) = unpack("nnnn", substr($$bufref, 0, $UDP_HEADER, ""));
        $udp_len == $length || die "Inconsistent UDP length (inner UDP payload length: $udp_len, Inner IP packet length - inner UDP header length $ihl = $length)";
        $length -= $UDP_HEADER;

        if ($udp_chksum) {
            while ($sum > 0xffff) {
                my $carry = $sum >> 16;
                $sum &= 0xffff;
                $sum += $carry;
            }
            $sum == 0xffff || return;
        }

        $listener->info("FOU decoded UDP bytes (TTL %d) on $role UDP socket(%s:%d -> %s:%d): %s",
                        $ttl, $src, $sprt, $dst, $dprt,
                        ::display($$bufref)) if $verbose > 1;

        my $line = $listener->{parent};
        # On the remote side we will be able to distinguish packets coming back
        # from ($dst, $dport) so we can share a single Sender::UDP for a given
        # ($src,$port)
        my $map_src = $line->{map_udp}{"$dst:$dprt"} ||= [
            0,                 # Next seq counter
            {
            },                 # Map "src:port" to map
            [undef],           # Map id to map (the undef makes id start at 1)
            # $ndst,	# Packed destination address
            # $dprt,	# Destination Port
        ];
        my $fou_id = $listener->{fou_id};
        my $key = "$src:$sprt:$fou_id";
        # Fields must be enough like Address that we can call socket_udp
        my $map = $map_src->[1]{$key} ||= {
            key		=> $key,
            packed	=> pack_sockaddr_in($sprt, $nsrc),
            display	=> "$src:$sprt",
            type	=> "udp4",
            fou_id	=> $fou_id,
        };
        $map->{seq} = $map_src->[0]++;
        # We should be able to handle many billions of packets before this overflows
        die "Too many packets to $dst:$dprt" if $map->{seq} == $map_src->[0];
        $id = $map->{id};
        if (!defined $id) {
            my $settings = $listener->{parent}{settings};
            # A source we haven't saeen befre or we have forgotten
            if (values %{$map_src->[1]} > $settings->{UDP_MAX}) {
                my @old = sort {$a->{seq} <=> $b->{seq}} values %{$map_src->[1]};
                # Ignore the map we just added (it will have the highest packet number)
                pop @old;
                for my $old (@old) {
                    # Try to allocate the socket. If we can that means the
                    # ($src,$port) combination is not in local use anymore and
                    # we can completely drop it
                    # Notice if we receive FOU packets from a remote host we
                    # also won't be able to bind(), so this works out OK. There
                    # is a problem if we share IP addresses with the sender of
                    # the FOU packets though. So we probably need an option to
                    # turn this off and have another strategy to free up entries
                    # (e.g. a timeout)
                    # print STDERR "Probe $old->{display}\n";
                    if (ConnUtils->socket_udp($old, 1)) {
                        $listener->info("Releasing map '$key' (socket not in use any more)") if $verbose > 1;
                        $id = $old->{id};
                        last;
                    }
                }
                defined $id || die "Assertion: no Free id's";
                # $id //= $old[0]{id} // die "Assertion: no Free id's";
                my $remove = $map_src->[2][$id];
                delete $map_src->[1]{$remove->{key}} == $remove ||
                    die "Assertion: Removing unexpected entry";
            } else {
                $id = @{$map_src->[2]};
            }
            $map->{id} = $id;
            $map_src->[2][$id] = $map;
        }
        # print STDERR ::Dumper($id, $line->{map_udp});
        my $to = pack("Cna4", $ADDRESS_TYPE_UDP4, $dprt, $ndst);
        $line->write($UDP_DATA, pack("wCw/a*", $id, $ttl-1, $to), $$bufref);
    } elsif ($proto == $PROTO_ICMP) {
        # Must have ToS 0
        $dscp == 0 && $ecn == 0 || return;
        # Must have space for ICMP header
        return if $length < $ICMP_HEADER;

        # Pad buffer with \0 so a last single byte still gets processed as "n"
        $sum = unpack("%32n*", $$bufref . "\x0");
        my ($type, $code, $icmp_chksum, $id, $seqno) =
            unpack("WWn3", substr($$bufref, 0, $ICMP_HEADER, ""));
        $length -= $ICMP_HEADER;

        # For mow we only support ICMP ECHO REQUEST
        $code == 0 || return;
        my $extra = "";
        if ($type == $ICMP_ECHO_REQUEST) {
            # Resulting packet must fit
            $extra = pack("a16Na4nnw", $SECRET, rand int 2**32, $nsrc, $id, $seqno, $listener->{fou_id});
            return if $length + $ICMP_HEADER + $IHL * 4 + length($extra) >> 16;
        } else {
            return;
        }

        if (1 || $icmp_chksum) {
            while ($sum > 0xffff) {
                my $carry = $sum >> 16;
                $sum &= 0xffff;
                $sum += $carry;
            }
            $sum == 0xffff || return;
        }

        $listener->info("FOU decoded ICMP bytes (TTL %d) on $role UDP socket(%s -> %s): type %d, code %d, id %d, seqno %d, data=%s",
                        $ttl, $src, $dst,
                        $type, $code, $id, $seqno,
                        ::display($$bufref)) if $verbose > 1;

        my $line = $listener->{parent};
        # We leak $src here. We could do some unique remote port mapping instead
        substr($$bufref, 0, 0, $extra);
        substr($$bufref, 0, 16, md5($$bufref));
        my $remote_seqno = ++$line->{seqno_echo};
        $line->{seqno_echo} = $remote_seqno = 1 if $remote_seqno >> 16;
        $line->write($PING, pack("wa4nC", 1, $ndst, $remote_seqno, $ttl-1), $$bufref);
    }
}

package Fou::UDP;
# Send out proxied packets at the local (client) side using a FOU tunnel
# Fou::UDP->new($root, $address_to)
use vars qw(@ISA);
@ISA = qw(_UDP);

use Scalar::Util qw(weaken);
use Socket qw(inet_aton inet_ntoa pack_sockaddr_in);

# Called with a resolved address (see Address->parse)
{ no warnings "once"; *new = \&new_suspended; }
sub new_suspended {
    my ($class, $root, $address_to) = @_;

    my $fou = $root->{lookups}{$class}{$address_to->{display}};
    return $fou if $fou;

    # For now listen on any with a random port. Maybe make this an option
    my ($local, $socket) = ConnUtils->socket_udp($UDP4_ANY);

    $fou = $class->SUPER::new_suspended(
        $root, undef, $socket,
        local		=> $local,
        peer		=> $address_to);
    weaken($root->{lookups}{$class}{$fou->{peer}{display}} = $fou);
    return $fou;
}

sub _finish {
    my $fou = shift;

    delete $fou->{parent}{lookups}{ref $fou}{$fou->{peer}{display}} ||
        $fou->bug("Cannot find '$fou->{peer}{display}' in ", ref $fou, " lookup");
    $fou->SUPER::_finish(@_);
}

package TCP::Remote;
# Partner on the client side to a remote Listener::TCP::Forward at the server
# Does nothing except remembering the forwarding argument
# TCP::Remote->new($line, %options)
use vars qw(@ISA);
@ISA = qw(Object);

sub write : method {
    my $remote = shift;

    $remote->{out} .= join("", @_);
}

sub writing {
    shift->bug("No writing should be triggered");
}

sub status {
    my ($remote, $control, $indent) = @_;

    my $name = $remote->name;
    $control->{collect} .= <<"EOF"
$indent$name
$indent  Local:  Connect to '$remote->{remote}{display}'
EOF
        ;
}

package Listener::TCP::Forward;
# Listen for incoming connections that need forwarding on the client side
# Listener::TCP::Forward->new($line, $address, %options)
use vars qw(@ISA);
@ISA = qw(Listener);

sub on_accept {
    my ($listener, $accepted, $local, $peer) = @_;

    # Peer is who is connecting to us
    # Local is where we got connected
    # Remote is what we plan to connect to on the remote side

    my $line = $listener->{parent};
    my %remote = %{$listener->{remote}};
    $remote{port} ||= $local->{port};
    $remote{host} = $local->{host} if $remote{host} eq "0.0.0.0";
    $remote{display} = "$remote{host}:$remote{port}";

    my $forward = TCP::Forward->new(
        $line, $local, $peer,
        socket_in	=> $accepted,
        socket_out	=> $accepted,
        remote		=> \%remote,
    );
    $forward->info("Start forwarding from %s to %s (remote connect may still fail though)", $peer->{display}, $remote{display}) if $verbose > 1;
    $line->write($CONNECT, pack("ww/a*a*",
                                $forward->{id},
                                @remote{qw(type display)}));
    return $forward;
}

sub status {
    my ($listener, $control, $indent) = @_;

    $listener->SUPER::status($control, $indent);

    $control->{collect} .= "$indent  Remote: Connect to '$listener->{remote}{user}'\n";
}

package Listener::TCP::Remote;
# Listen for incoming connections that need forwarding on the server side
use vars qw(@ISA);
@ISA = qw(Listener);

sub on_accept {
    my ($listener, $accepted, $local, $peer) = @_;

    # Peer is who is connecting to us
    # Local is where we got connected
    # We don;t know what we plan to connect to on the remote (client) side
    # The client has that in the corresponding TCP::Remote object

    my $line = $listener->{parent};

    my $forward = TCP::Forward->new(
        $line, $local, $peer,
        socket_in	=> $accepted,
        socket_out	=> $accepted,
        remote_id	=> $listener->id,
    );
    $forward->info("Start forwarding from %s to TCP::Remote %d (remote connect may still fail though)", $peer->{display}, $forward->{remote_id}) if $verbose > 1;
    $line->write($CONNECT_REMOTE, pack("wwa*",
                                       @$forward{qw(id remote_id)},
                                       $local->encode));
    return $forward;
}

package Forward;
# Base class for TCP::Forward, must NOT inherit from Object

sub on_read {
    my ($forward) = @_;

    $forward->info("Forwarding data: %s", ::display($forward->{in})) if $verbose > 1;
    $forward->{parent}->write($TCP_DATA, pack("w", $forward->{id}), $forward->{in});
    $forward->{in} = "";
}

sub eof_to_partner {
    my $forward = shift;

    $forward->info("Tell remote no more data: @_") if $verbose > 1;
    $forward->{parent}->write($TCP_EOF, pack("wa*", $forward->{id}), @_);
}

# Tell remote to finish
sub finish_to_partner {
    my ($forward, $reason) = @_;

    $forward->info("Tell remote local finished: $reason") if $verbose > 1;
    $forward->{parent}->write($TCP_FIN, pack("wa*", $forward->{id}, $reason));
}

sub error {
    my $forward = shift;

    $forward->error_finish(@_);
}

package TCP::Forward;
# Generic TCP forwarder. Just copies data to the other side
# TCP::Forward->new($line, $local, $peer, %options)
# Important options: partner, partner_unfinished, socket_in, socket_out, id

use vars qw(@ISA);
@ISA = qw(Forward Stream);

# By default we assume as partner. Override if this is not (immediately) so
# e.g. Socks::Local has no partner until a SOCKS command is given
sub new_suspended {
    my $class	= shift;
    my $line	= shift;
    my $local	= shift;
    my $peer	= shift;

    my $forward = $class->SUPER::new_suspended(
        $line, undef, undef,
        local			=> $local,
        peer			=> $peer,
        partner			=> 1,
        partner_unfinished	=> 1,
        @_);
    $forward->connect if !defined $forward->{socket_out} && $forward->{peer};
    return $forward;
}

package Listener::Socks::Local;
# Listen for incoming socks connections
# Listener::Socks::Local->new($line, $address, %options)
use vars qw(@ISA);
@ISA = qw(Listener);

sub new_suspended {
    my $class = shift;
    my $socks = $class->SUPER::new_suspended(@_);
    $socks->defer_accept;
    return $socks;
}

sub on_accept {
    my ($listener, $accepted, $local, $peer) = @_;

    # Peer is who is connecting to us
    # Local is where we got connected

    my $line = $listener->{parent};

    my $socks = Socks::Local->new(
        $line, $local, $peer,
        socket_in	=> $accepted,
        socket_out	=> $accepted,
    );
    $socks->info("Socks connect from %s", $peer->{display}) if $verbose > 1;
    return $socks;
}

package Socks::Forward;
# Process socks request (local side)
# Socks::Forward->new($line, $local, $peer, %options)
# Important options: partner, partner_unfinished, socket_in, socket_out, id
use vars qw(@ISA);
@ISA = qw(TCP::Forward);

sub new_suspended {
    my $class = shift;
    my $forward = $class->SUPER::new_suspended(@_);
    $forward->reclasify("TCP::Forward");
    return $forward;
}

# Make sure the object is a TCP::Forward otherwise the parent delete will
# be done through the wrong class leading to a fatal "Already detached" error
sub _on_finish {
    my $forward = shift;
    bless $forward, "TCP::Forward";
    $forward->SUPER::_on_finish(@_);
}

package Socks::Local;
# Process socks request (local side)
# Socks::Local->new($line, $local, $peer, %options)
# Important options: partner, partner_unfinished, socket_in, socket_out
use vars qw(@ISA);
@ISA = qw(Socks::Forward);

use Socket qw(inet_ntoa);
use Scalar::Util qw(weaken);

sub new_suspended {
    my $class	= shift;
    my $line	= shift;
    my $local	= shift;
    my $peer	= shift;

    return $class->SUPER::new_suspended(
        $line, $local, $peer,
        partner			=> 0,
        partner_unfinished	=> 0,
        state			=> \&Socks::Local::version,
        request			=> Address->new(
            seqno	=> 0,
            type	=> "tcp4",
        ),
        @_);
}

sub error_response {
    my $socks = shift;

    $socks->black_hole;
    # Strictly speaking we should use a short timeout here (RFC says 10 seconds)
    # In practice this is the first packet we send and the OS should buffer it
    # for us, so we will never have to really wait for the write even if the
    # client doesn't read anything
    $socks->final_write(@_);
}

sub eof : method {
    my $socks = shift;

    if ($socks_pipeline && $socks->{remote}) {
        $socks->final_read(shift);
    } else {
        $socks->error("Unexpected @_");
    }
}

sub on_read {
    my ($socks) = @_;

    $socks->{state}->($socks);
}

sub no_input {
    my ($socks) = @_;

    $socks->{state} = \&bug_input;
    $socks->finish("Spurious input");
}

sub impossible_input {
    shift->bug("Input from finished object");
}

sub finish {
    my $socks = shift;

    $socks->{state} = \&impossible_input;
    $socks->SUPER::finish(@_);
}

sub version {
    my ($socks) = @_;

    return if $socks->{in} eq "";
    $socks->{request}{version} = ord substr($socks->{in}, 0, 1, "");
    if ($socks->{request}{version} == 4) {
        $socks->cmd4;
    } elsif ($socks->{request}{version} == 5) {
        $socks->greeting5;
    } else {
        $socks->finish("Unknown SOCKS version $socks->{request}{version}");
        return;
    }
}

# For a better explanation of SOCKS4 than the wikipedia article see for example
# https://github.com/h12w/socks/blob/master/spec/SOCKS4.protocol.txt
sub cmd4 {
    my ($socks) = @_;

    if ($socks->{in} eq "") {
        $socks->{state} = \&cmd4;
        return;
    }
    $socks->{request}{cmd} = ord substr($socks->{in}, 0, 1, "");
    if ($socks->{request}{cmd} < 1 || $socks->{request}{cmd} > 2) {
        $socks->finish("Unknown SOCKS4 command $socks->{request}{cmd}");
        return;
    }
    $socks->greeting4;
}

sub greeting4 {
    my ($socks) = @_;

    if (length $socks->{in} < 6) {
        $socks->{state} = \&greeting4;
        return;
    }
    @{$socks->{request}}{qw(port addr)} =
        unpack("na4", substr($socks->{in}, 0, 6, ""));
    $socks->username4;
}

sub username4 {
    my ($socks) = @_;

    if ($socks->{in} !~ s/^([^\0]*)\0//s) {
        $socks->{state} = \&username4;
        return;
    }

    $socks->{request}{username} = $1;
    if ($socks->{request}{addr} =~ /^\0\0\0[^\0]/) {
        $socks->greeting4a;
        return;
    }
    $socks->{request}{host} = inet_ntoa($socks->{request}{addr});
    $socks->execute();
}

sub greeting4a {
    my ($socks) = @_;

    if ($socks->{in} !~ s/^([^\0]*)\0//s) {
        $socks->{state} = \&greeting4a;
        return;
    }
    $socks->{request}{host} = $1;
    $socks->execute();
}

sub greeting5 {
    my ($socks) = @_;

    if ($socks->{in} eq "") {
        $socks->{state} = \&greeting5;
        return;
    }
    $socks->{request}{nauth} = ord substr($socks->{in}, 0, 1, "");
    $socks->auth5;
}

sub auth5 {
    my ($socks) = @_;

    if (length $socks->{in} < $socks->{request}{nauth}) {
        $socks->{state} = \&auth5;
        return;
    }
    $socks->{request}{auth} = substr($socks->{in}, 0, $socks->{request}{nauth}, "");

    if ($socks->{request}{auth} !~ /\0/) {
        $socks->error_response("User does not support 'No authentication'",
                               "\x05\xff");
        return;
    }
    $socks->write("\x05\x00");
    $socks->request5;
}

sub request5 {
    my ($socks) = @_;

    if (length $socks->{in} < 4) {
        $socks->{state} = \&request5;
        return;
    }
    my ($version, $cmd, $rsv, $type) = unpack("C4", substr($socks->{in}, 0, 4, ""));
    $socks->{request}{cmd} = $cmd;

    if ($version != 5) {
        $socks->finish("Invalid version $version in client connection request");
        return;
    }
    my ($err, $msg);
    if ($rsv != 0) {
        $msg = "Unknown reserved byte '$rsv'";
        $err = 7; # protocol error
    } elsif ($cmd < 1 || $cmd > 3) {
        $msg = "Unknown command '$cmd'";
        $err = 7; # command not supported
    } elsif ($type == 1) {
        $socks->address_ipv4;
        return;
    } elsif ($type == 3) {
        $socks->address_name_len;
        return;
    } else {
        $msg = "Address type $type not supported";
        $err = 8; # address type not supported
    }
    # Error
    $socks->error_response("SOCKS5 request error: $msg",
                           pack("CCxCx6", 5, $err, 1));
}

sub address_ipv4 {
    my ($socks) = @_;

    if (length $socks->{in} < 4) {
        $socks->{state} = \&address_ipv4;
        return;
    }
    $socks->{request}{addr} = substr($socks->{in}, 0, 4, "");
    $socks->{request}{host} = inet_ntoa($socks->{request}{addr});
    $socks->port5;
}

sub address_name_len {
    my ($socks) = @_;

    if ($socks->{in} eq "") {
        $socks->{state} = \&address_name_len;
        return;
    }
    $socks->{request}{host_length} = ord substr($socks->{in}, 0, 1, "");
    $socks->address_name;
}

sub address_name {
    my ($socks) = @_;

    if (length $socks->{in} < $socks->{request}{host_length}) {
        $socks->{state} = \&address_name;
        return;
    }
    $socks->{request}{host} = substr($socks->{in}, 0, $socks->{request}{host_length}, "");
    $socks->port5;
}

sub port5 {
    my ($socks) = @_;

    if (length $socks->{in} < 2) {
        $socks->{state} = \&port5;
        return;
    }
    $socks->{request}{port} = unpack("n", substr($socks->{in}, 0, 2, ""));
    $socks->execute;
}

sub execute {
    my ($socks) = @_;

    my $request = $socks->{remote} = delete $socks->{request};
    $request->{user} = $request->{display} = "$request->{host}:$request->{port}";
    if ($request->{cmd} == 1) {
        $request->{command} = "connect";
    } elsif ($request->{cmd} == 2) {
        $request->{command} = "bind";
    } elsif ($request->{cmd} == 3) {
        $request->{command} = "UDP relay";
        $request->{type} = "udp4";
        # Don't resolve $request here, we still need addr to check for hostname
    } else {
        # We already checked the command during request parsing
        $socks->bug("Impossible accepted command '$request->{cmd}'");
    }

    $socks->info("User %srequests %s to %s using SOCKS%d%s",
                 defined $request->{username} ? "'$request->{username}' " : "",
                 $request->{command}, $request->{user}, $request->{version},
                 $request->{version} == 4 && $request->{addr} =~ /^\0\0\0[^\0]/ ? "a" : $request->{version} == 4 && !$request->{addr} ? "h" : "") if $verbose;

    if ($request->{cmd} == 3) {
        $request->resolve;
        if ($request->{host} ne "0.0.0.0" && $request->{port} != 0) {
            # Probe for a local address
            my $local = ConnUtils->socket_udp_connected($request, 1);
            $local->{port} = 0;
            # Won't do any real lookup, all fields are numeric
            $local->resolve;
            my ($l, $socket) = ConnUtils->socket_udp($local);

            $socks->{parent}->write(
                $SOCKS, pack("wwx", $socks->{id}, $request->{cmd}));
            $socks->{partner} = 1;
            $socks->{partner_unfinished} = 1;

            $socks->socks_result(1, 0, $l);
            # Don't do final_write, too easy for the client to assume it means
            # close instead of shutdown. We may however want to set a timeout
            $socks->no_input if $socks->{in} ne "";

            my $receiver = Receiver::Socks->new(
                $socks->{parent}, $socket, $socket,
                id	=> $socks->{id},
                local	=> $l,
                peer	=> $request);
            # We can hunt for it in $socks children, but this is easier
            weaken($socks->{receiver} = $receiver);
            weaken($receiver->{socks} = $socks);

            return;
        }
    } elsif ($request->{port} != 0 || $request->{cmd} != 1) {
        $socks->{parent}->write(
            $SOCKS, pack("www/a*a*", $socks->{id}, @$request{qw(cmd type display)}));
        $socks->{partner} = 1;
        $socks->{partner_unfinished} = 1;

        $socks->{state} = $socks_pipeline ? \&Forward::on_read : \&no_input;
        if ($socks->{in} ne "") {
            $socks->{state}->($socks, length $socks->{in});
            $socks->{in} = "";
        }
        return;
    }

    $socks->error_response(
        "Cannot $request->{command} to $request->{display}",
        $request->{version} == 4 ? pack("xCx6", 0x5B) :
        $request->{version} == 5 ? pack("CCxCx6", 5, 2, 1) :
        $socks->bug("Unknown SOCKS version '$request->{version}'"));
}

sub socks_result {
    my ($socks, $seqno, $status, $address) = @_;

    my $request = $socks->{remote} || $socks->bug("Result without request");
    $seqno == ++$request->{seqno} ||
        $socks->bug("Got result packet $seqno, expected $request->{seqno}");

    if ($request->{version} == 5) {
        $socks->write(pack("CCxCa4n", 5, $status, 1, @$address{qw(addr port)}));
    } elsif ($request->{version} == 4) {
        $socks->write(
            pack("xCna4", $status ? 0x5B : 0x5A, @$address{qw(port addr)}));
    } else {
        $socks->bug("Unknown socks version $request->{version}");
    }

    # No need for cleanup, the remote side has already sent us a TCP_FIN command
    # (which also includes the error reason)
    return if $status;

    # We don't do anything with this, but can be nice for status display
    $socks->{address}[$seqno-1] = $address;

    if ($request->{cmd} == 1 || $request->{cmd} == 3) {
        $seqno == 1 || $socks->bug("Response packet $seqno");
    } elsif ($request->{cmd} == 2) {
        return if $seqno == 1;
        $seqno == 2 || $socks->bug("Response packet $seqno");
    } else {
        # We already checked that we support cmd
        $socks->bug("Impossible SOCKS command '$request->{cmd}'");
    }
    $socks->info("Become TCP::Forward[%s] after %s to '%s' [%s] succeeded",
                 $socks->id_full, $request->{command},
                 $request->{display}, $address->{display}) if $verbose > 1;
    # Socket can already be shutdown by EOF in case of pipelining
    $socks->suspend_read if $socks->{socket_in};
    bless $socks, $request->{cmd} == 3 ? "Socks::UDP" : "TCP::Forward";
    # Replace the reader by the one from TCP::Forward
    # No need to do the same for writer since we never override that one
    $socks->resume_read if $socks->{socket_in};
}

package Socks::UDP;
# Handle socks UDP associate (local side)
# new() is never directly called, Socks::Local becomes this
use vars qw(@ISA);
@ISA = qw(Socks::Forward);

sub socks_data {
    my $socks = shift;
    my $from = shift;

    $from->{type} eq "udp4" || $socks->bug("Address type $from->{type}");
    # UDP writer will silently drop oversized packets
    $socks->{receiver}->write(
        pack("x3Ca4na*", 1, $from->{addr}, $from->{port}, shift),
        shift);
}

# Works fine without this method too, but then we would send a EOF to remote
# who would write FIN, the nwe finish end send FIN to remote.
sub eof : method {
    my $socks = shift;

    $socks->finish(shift);
}

sub on_read {
    shift->Socks::Local::no_input;
}

sub _finish {
    my $socks = shift;
    $socks->SUPER::_finish(@_);
    $socks->{receiver}->finish("Master finished") if
        $socks->{receiver} && !$socks->{receiver}{finished};
}

package Socks::Remote;
# Process socks request (remote side)
# Socks::Remote->new($line, $local, $peer, %options)
# Important options: partner, partner_unfinished, socket_in, socket_out, id
use vars qw(@ISA);
@ISA = qw(Socks::Forward);

package Socks::Connect;
# Process socks connect request (remote side)
# Socks::Connect->new($line, $local, $peer, %options)
# Important options: partner, partner_unfinished, id
use vars qw(@ISA);
@ISA = qw(Socks::Remote);

use Errno qw(ENETUNREACH EHOSTUNREACH ECONNREFUSED ETIMEDOUT);

my %SOCKS_STATUS = (
    ENETUNREACH()	=> 3,
    EHOSTUNREACH()	=> 4,
    ECONNREFUSED()	=> 5,
    ETIMEDOUT()		=> 6,
);

sub on_connect_error {
    my ($connect, $err) = @_;

    my $line = $connect->{parent};
    # Send peer as address. We don't HAVE a local and it can be interesting
    # to know what we actually tried to connect to
    $line->write($SOCKS_RESULT,
                 pack("wwww/a*a*", $connect->{id}, 1,
                      $SOCKS_STATUS{$err+0} || 1,
                      @{$connect->{peer}}{qw(type display)}));
    # This will call error() and cause a finish which must come AFTER write
    $connect->SUPER::on_connect_error($err);
}

sub on_connect {
    my ($connect) = @_;

    my $line = $connect->{parent};
    # This will succeed and must come BEFORE write so we get "local"
    $connect->SUPER::on_connect(0);
    # Send "local" as address (as the RFC tells us we must)
    $line->write($SOCKS_RESULT,
                 pack("wwxw/a*a*", $connect->{id}, 1,
                      @{$connect->{local}}{qw(type display)}));
    $connect->info("Become TCP::Forward[%s] now that connect succeeded",
                   $connect->id_full) if $verbose > 1;
    bless $connect, "TCP::Forward"
}

package Listener::Socks::Accept;
# Wait for a single incoming connection
# Listener::Socks::Accept->new($accept, $address, %options)
use vars qw(@ISA);
@ISA = qw(Listener);

sub on_accept {
    my ($listener, $socket, $local, $peer) = @_;

    my $accept = $listener->{parent};
    my $line = $accept->{parent};

    if ($accept->{remote}{host} ne "0.0.0.0" &&
        $accept->{remote}{host} ne $peer->{host}) {
        # Paranoia as described in the SOCKS4 specification
        # Only accept connections from the same host that the request mentioned
        # as the destination
        # The SOCKS5 RFC doesn't mention this, but it seems like a good idea
        # A SOCKS4 description describes sending an error back to the client for
        # this case, but I don't want to shut the client down because somebody
        # else connected to the port (on the other hand maybe something is
        # genuinely asymetric and now the user will never know)
        $accept->info("Reject incoming connection from '$peer->{display}', does not match the expected host from '$accept->{remote}{user}' [$accept->{remote}{display}]") if $verbose;
        return;
    }
    $listener->finish("Acceptable connection");
    $accept->{timeout} = undef;
    $accept->{local} = $local;
    $accept->{peer}  = $peer;
    $accept->{socket_in} = $accept->{socket_out} = $socket;
    # Send "peer" as address in the second result (as the RFC tells us we must)
    $line->write($SOCKS_RESULT,
                 pack("wwxw/a*a*", $accept->{id}, 2,
                      @$peer{qw(type display)}));
    $accept->info("Become TCP::Forward[%s] now that accept succeeded",
                  $accept->id_full) if $verbose > 1;
    bless $accept, "TCP::Forward";
    $accept->resume_read("quiet");
    $accept->writable;
}

package Socks::Accept;
# Do the SOCKS bind operation (remote side)
# Socks::Accept->new($line, $remote, %options)
# Important options: id, remote
use vars qw(@ISA);
@ISA = qw(Socks::Remote);

sub new_suspended {
    my $class	= shift;
    my $line	= shift;
    my $remote	= shift;

    $remote->resolve;
    my $accept = $class->SUPER::new_suspended(
        $line, undef, undef,
        remote		=> $remote,
        unwritable	=> 1,
        @_);

    # Many (all ?) socks clients don't properly fill the host they want as peer.
    # Instead they just pass where they want to bind. In that case use that
    my $local = $accept->{remote};
    if ($local->{host} ne "0.0.0.0") {
        # Proper client has been reading the RFC
        $local = ConnUtils->socket_udp_connected($accept->{remote}, 1);
        if (ref $local eq "") {
            # UDP connect failed, errno in $local
            $line->write($SOCKS_RESULT,
                         pack("wwww/a*a*", $accept->{id}, 1,
                              $SOCKS_STATUS{$local+0} || 1,
                              @{$accept->{remote}}{qw(type display)}));
            $accept->error("Failed UDP probe connect to '$accept->{remote}{display}': $local");
            return undef;
        }
        # Local contains the local address as the result of a probe UDP connect
        # The port is meaningless, we want to do a local bind for TCP instead
        $local->{type} = "tcp4";
        $local->{port} = 0;
        # This will not actually look up anything since all addresses and ports
        # are numeric. But it will properly fill in all fields
        $local->resolve("SOCKS");
    }

    # Don't set loops = 1. We may reject some incoming connections
    my $listener = eval { Listener::Socks::Accept->new($accept, $local) };
    if ($@) {
        # bind/listen failed, errno in $!
        my $err = $@;
        $err =~ s/\sat\s.*//s;
        $line->write($SOCKS_RESULT,
                     pack("wwww/a*a*", $accept->{id}, 1,
                          $SOCKS_STATUS{$!+0} || 1,
                          @{$accept->{remote}}{qw(type display)}));
        $accept->error($err);
        return undef;
    }
    # Listener did a bind, so at least the port is filled in now
    $accept->{local} = $listener->{local};
    $line->write($SOCKS_RESULT,
                 pack("wwxw/a*a*", $accept->{id}, 1,
                      @{$listener->{local}}{qw(type display)}));
    # We expect Response -> client, client -> application server (through SOCKS)
    # and application server -> our socket. Let's give it ... two connect times
    # (maybe it's cleaner to add timer support to _Listen instead)
    $accept->timer($line->{settings}{TIMEOUT_CONNECT} * 2, \&accept_timeout);
    return $accept;
}

sub accept_timeout {
    my ($accept) = @_;

    # 6 = TTL expired which is typically interpreted as "timeout" by the client
    # We have nothing sane to put in the address, so just punt with remote
    $accept->{parent}->write($SOCKS_RESULT,
                             pack("wwww/a*a*", $accept->{id}, 2,
                                  6, @{$accept->{remote}}{qw(type display)}));
    $accept->error("Accept timed out");
}

package Receiver::Socks;
# Local side of a SOCKS UDP associate
# UDP->new($parent, $socket_in, $socket_out, %options)
use vars qw(@ISA);
@ISA = qw(UDP);

use Socket qw(inet_ntoa);

sub _finish {
    my $receiver = shift;
    $receiver->SUPER::_finish(@_);
    $receiver->{socks}->finish("Slave finished") if
        $receiver->{socks} && !$receiver->{socks}{finished};
}

sub on_read {
    my ($receiver, $from, $ttl, $bufref) = @_;

    if ($from->{packed} ne $receiver->{peer}{packed}) {
        $receiver->info("Drop packet from '%s' (only sender '%s' is valid)", $from->{display}, $receiver->{peer}{display}) if $verbose > 1;
        return;
    }
    if ($ttl <= 1) {
        $receiver->info("Drop packet: TTL %d", $ttl) if $verbose > 1;
        return;
    }
    # RSV 2, FRAG 1, ATYP 1, ADDR >= 1, PORT 2
    if (length $$bufref < 7) {
        $receiver->info("Drop packet: too short from %s: %s", $receiver->{peer}{display}, ::display($$bufref)) if $verbose > 1;
        return;
    }
    my ($rsv, $frag, $atyp, $len) = unpack("nCCC", $$bufref);
    if ($rsv != 0) {
        $receiver->info("Drop packet: Reserved %d not supported", $rsv) if $verbose > 1;
        return;
    }
    if ($frag) {
        $receiver->info("Drop packet: Fragments not supported (yet)") if $verbose > 1;
        return;
    }
    my ($port, $to);
    if ($atyp == 1) {
        # 2+1+1+4+2
        if (length $$bufref < 10) {
            $receiver->info("Drop packet: too short from %s: %s", $receiver->{peer}{display}, ::display($$bufref)) if $verbose > 1;
            return;
        }
        (my $addr, $port) = unpack("x4a4n", substr($$bufref, 0, 10, ""));
        $receiver->info("Will relay UDP packet to '%s:%d': %s",
                        inet_ntoa($addr), $port, ::display($$bufref)) if $verbose > 1;
        # $to = pack("Cna4", $ADDRESS_TYPE_UDP4, $port, $addr);
        $to = pack("Cna*", $ADDRESS_TYPE_UDP_NAME, $port, inet_ntoa($addr));
    } elsif ($atyp == 3) {
        # 2+1+1+1+$l+2
        if (length $$bufref < 7+$len) {
            $receiver->info("Drop packet: too short from %s: %s", $receiver->{peer}{display}, ::display($$bufref)) if $verbose > 1;
            return;
        }
        (my $name, $port) = unpack("x4C/a*n", substr($$bufref, 0, 7+$len, ""));
        $receiver->info("Will relay UDP packet to '%s:%d': %s",
                        $name, $port, ::display($$bufref)) if $verbose > 1;

        $to = pack("Cnw/a*", $ADDRESS_TYPE_UDP_NAME, $port, $name);
    } else {
        $receiver->info("Drop packet: Address type %d not supported (yet)", $atyp) if $verbose > 1;
        return;
    }
    if ($port == 0) {
        $receiver->info("Drop packet: Attempt to send to port 0") if $verbose > 1;
        return;
    }

    my $line = $receiver->{parent};
    $line->write($SOCKS_DATA,
                 pack("wCw/a*", $receiver->{id}, $ttl-1, $to), $$bufref)
}

package UDP::Forward;
# Send out packets at the remote side (and wait for replies)
# Sender::UDP->new($line, $id)
use vars qw(@ISA);
@ISA = qw(Forward UDP);

sub new_suspended {
    my ($class, $line, $id) = @_;

    my ($local, $socket) = ConnUtils->socket_udp($UDP4_ANY);

    my $forward = $class->SUPER::new_suspended(
        $line, $socket, $socket,
        id			=> $id,
        local			=> $local,
        partner			=> 1,
        partner_unfinished	=> 1,
    );

    $forward->reclasify("TCP::Forward");
    $forward->info("Local address '%s'", $local->{display}) if $verbose > 1;
    return $forward;
}

# Make sure the object is a TCP::Forward otherwise the parent delete will
# be done through the wrong class leading to a fatal "Already detached" error
sub _on_finish {
    my $forward = shift;
    bless $forward, "TCP::Forward";
    $forward->SUPER::_on_finish(@_);
}

sub on_read {
    my ($sender, $from, $ttl, $dataref) = @_;

    return if $ttl <= 1;
    $sender->{parent}->write($SOCKS_DATA, pack("wCw/a*", $sender->{id}, $ttl-1, $from->encode), $$dataref)
}

{
    no warnings "once";
    *socks_data = __PACKAGE__->can("write") ||
        die "Assertion: package has no write";
}

package Resolver;
# Resolve names (hosts file/DNS)
# We assume that if a name is a CNAME, it shouldn't have records of any other
# type. Zone files SHOULD be like that, but even if we get responses with
# a combination we will just drop them
# Resolver->new($root, %options)
use vars qw(@ISA);
@ISA = qw(Object);

use Scalar::Util qw(weaken looks_like_number);
use Socket qw(inet_ntoa inet_aton);
use Errno qw(ENOENT);

use constant {
    INFINITY		=> 9**9**9,
    # Minimum time to wait between file checks
    CHECK_DELAY		=> 1,
    NEGATIVE		=> 10,
    # Header + (name+type+class)
    # (we always send 1 question, so we expect 1 back, otherwise it would be 12)
    DNS_MIN_RESPONSE	=> 12 + (1+2+2),
    # Reduce any TTL higher than this
    TTL_MAX		=> 7*24*60*60,
    # Empty array for sharing. Would set it to read-only if that was portable
    ARRAY_EMPTY		=> [],
    MAX_QUERIES		=> 100,
    # Maximium number of query ids we remember.
    MAX_FREE		=> 1000,
    DNS_TIMEOUT		=> 5,

    # stat() fields
    DEV		=> 0,
    INO		=> 1,
    SIZE	=> 7,
    MTIME	=> 9,

    # Response error codes
    # https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-6
    NO_ERROR		=>  0,
    FORMAT_ERROR	=>  1,
    SERVER_FAILURE	=>  2,
    NAME_ERROR		=>  3,
    NOT_IMPLEMENTED	=>  4,
    REFUSED		=>  5,
    BADVERS		=> 16,
    BADCOOKIE		=> 23,

    # Some EDNS options
    OPTION_COOKIE	=> 10,
    OPTION_KEEPALIVE	=> 11,
    OPTION_EXT_ERROR	=> 15,

    # Some Types
    A		=> 1,
    CNAME	=> 5,
    PTR		=> 12,
    AAAA	=> 28,
    OPT		=> 41,

    # Classes
    IN		=> 1,

    # RR object
    TYPE	=> 0,
    VALUE	=> 1,
    TTL		=> 2,

    # DNS reply sections
    QUESTION	=> 0,
    ANSWER	=> 1,
    AUTHORITIVE	=> 2,
    ADDITIONAL	=> 3,

    # Query Callback
    OBJ		=> 0,
    CODE	=> 1,
    NAME	=> 2,
    PROBE	=> 3,
    DATA	=> 4,
};

use constant {
    STAT_SAME	=> [MTIME, SIZE, DEV, INO],
};

# MAX_QUERIES + MAX_FREE should be smallish to avoid query id allocation looping
MAX_QUERIES + MAX_FREE < 2**14 || die "Assertion: Can grow to too many qids";

my @foo;
sub get_foo {
    return \$foo[@foo];
}

sub foo {
    # shift->dump;
    shift;
    print STDERR ::Dumper(\@_);
}

sub new {
    my $class	= shift;
    my $root	= shift;

    $root->bug("Already have a DNS entry") if $root->{resolver};

    my $resolver = $class->SUPER::new(
        $root,
        settings	=> { %{$root->{settings}} },
        hosts		=> {
            checked	=> -INFINITY,
        },
        conf		=> {
            checked	=> -INFINITY,
            # All servers, even if not in current resolv.conf anymore
            dns_servers	=> {},
            # All nameserver entries of the current resolv.conf in file order
            nameserver	=> [],
        },
        cache		=> {},
        queries		=> {},
    );
    weaken($root->{resolver} = $resolver);

    # For debugging
    if (0) {
        $resolver->get_resolv(Timer::clocktime());
        my $dns_server = $resolver->{conf}{dns_servers}{$resolver->{conf}{nameserver}[0]} || $resolver->bug("No nameserver");
        $dns_server->tcp($resolver);
        $resolver->query(get_foo(), A, "cNAme-test2.hOme.lUNix", $resolver, \&foo, __LINE__);
        $resolver->query(get_foo(), A, "cNAme-test4.hOme.lUNix", $resolver, \&foo, __LINE__);
        $resolver->query(get_foo(), A, "cname-teST.HOMe.lunix", $resolver, \&foo, __LINE__);
        $resolver->query(get_foo(), A, "zzz.oracle.com", $resolver, \&foo, __LINE__);
        $resolver->query(get_foo(), A, "10.1", $resolver, \&foo, __LINE__);
        $resolver->query(get_foo(), A, "naS.Eth", $resolver, \&foo, __LINE__);
        $resolver->query(get_foo(), A, "www.XS4all.CoM", $resolver, \&foo, __LINE__);
        $resolver->query(get_foo(), PTR, inet_aton("10.253.1.8"), $resolver, \&foo, __LINE__);
        $resolver->query(get_foo(), PTR, inet_aton("104.73.50.128"), $resolver, \&foo, __LINE__);
    }

    return $resolver;
}

sub dispatch {
    my ($resolver, $query) = @_;

    $query->{timeout} = undef;
    while (@{$query->{callbacks}}) {
        my $callback = shift @{$query->{callbacks}} || next;
        # User must NEVER alter $query, but can access attributes
        # type, official, aliases and expires
        $callback->[CODE]->($callback->[OBJ] || next, $query->{values}, $callback->[DATA], $callback->[NAME], $query);
    }
    $query->{probe} = undef;
}

# Chase CNAMEs for the answer
# We assume $type != CNAME, but something like A or AAAA
sub chase {
    my ($resolver, $now, $query) = @_;

    if ($query->{expires} < $now) {
        # Previous answer expired.
        # But maybe the cache was updated and we can find the new answer
        my $cache = $resolver->{cache};
        my $type = $query->{type};

        # If the chase splits due to an entry with 2 (or more) CNAMES
        # (invalid but could be returned by a name server) and the some point
        # to an unexpired negative records while at others point to unexpired
        # real results this would behave as if the negative CNAME chains didn't
        # exist and you'd get a result comprised of the valid values.
        # We use the $negative flag to detect dangling CNAME's and invalidate

        my ($values, $official, @aliases, %seen, $negative, $not_first);
        my $expires = INFINITY;
        my @todo = $query->{name_low};
        while (@todo) {
            my $name = shift @todo;
            $name =~ s/([A-Z])/\l$1/g;
            # CNAME loops can only be inserted as a whole
            # (otherwise we would have set a negative placeholder for the tail)
            # So this implies some nameserver sent us a CNAME loop
            return 0 if $seen{$name}++;
            my $types = $cache->{$name} || return 0;
            if ($types->{$type}) {
                if ($types->{$type}{expires} < $expires) {
                    $expires = $types->{$type}{expires};
                    if ($expires < $now) {
                        if (keys %$types > 1) {
                            # We have other data for the name
                            delete $types->{$type};
                        } else {
                            # Only this self entry for type $type
                            delete $cache->{$name};
                        }
                        # $query->{expires} is already < $now (see test above)
                        return 0;
                    }
                }
                if ($types->{$type}{values}) {
                    $official = $types->{$type}{official} unless $negative || $not_first;
                    push @$values, @{$types->{$type}{values}}
                } else {
                    $negative ||= 1;
                }
                $not_first ||= 1;
            } elsif ($types->{CNAME()}) {
                if ($types->{CNAME()}{expires} < $expires) {
                    $expires = $types->{CNAME()}{expires};
                    if ($expires < $now) {
                        # If an entry has a CNAME it will be the only entry, so
                        # we can drop the whole name
                        delete $cache->{$name};
                        # $query->{expires} is already < $now (see test above)
                        return 0;
                    }
                }
                if ($types->{CNAME()}{values}) {
                    push @aliases, $types->{CNAME()}{official};
                    unshift @todo, @{$types->{CNAME()}{values}}
                } else {
                    $negative ||= 1;
                }
            } else {
                return 0;
            }
        }

        $values = undef if $negative;
        $resolver->bug("Empty result list") if $values && !@$values;

        $query->{values}   = $values;
        $query->{expires}  = $expires;
        $query->{official} = $official;
        $query->{aliases}  = \@aliases;
    }
    if ($verbose > 1) {
        if ($query->{values}) {
            my @values;
            if ($query->{type} == A) {
                @values = map inet_ntoa($_), @{$query->{values}};
            } else {
                @values = map ::display($_), @{$query->{values}};
            }
            $resolver->info("Resolved '$query->{name_low}' to @values");
        } else {
            $resolver->info("Could not resolve '$query->{name_low}'");
        }
    }
    return 1;
}

# Now figure out how to send the request
# $query is completely set up, this code should consider it read-only
sub queue {
    my ($resolver, $now, $query) = @_;

    # For now we always take the first server.
    # MUST implement a fallback strategy soon..
    my $dns_packed = $resolver->{conf}{nameserver}[0] ||
        $resolver->bug("No active DNS servers not supported");
    my $dns_server = $resolver->{conf}{dns_servers}{$dns_packed} ||
        $resolver->bug("Could not find an active DNS server");

    # Add Checks (length, multiple ., . at start etc), add search domains
    # Improve this at some point

    # Randomly permute case in request
    my $name_sent = $query->{name_low};
    if ($dns_server->{permute_case}) {
        my $bits = 0;
        my $rand;
        $name_sent =~ s{([a-z])}{
            if (--$bits < 0) {
                $rand = rand(1 << 31);
                $bits = 30;
            }
            my $bit = $rand & 1;
            $rand >>= 1;
            $bit ? $1 : uc $1;
        }eg;
    }

    my $qids = $dns_server->{qids};
    die "Way too many outstanding queries" if keys %$qids > MAX_QUERIES;
    my $qid = int rand(1 << 16);
    $qid = int rand(1 << 16) while vec($dns_server->{qids_bits}, $qid, 1);
    vec($dns_server->{qids_bits}, $qid, 1) = 1;

    my $packet = pack("n3x4n",
                      $qid,
                      1 << 8,	# Recursion
                      1,	# Nr questions
                      $dns_server->{edns},	# Nr additional
                  );
    my @labels = split /\./, $name_sent;
    $packet .= pack("(C/a*)*x", @labels);
    $packet .= pack("nn", $query->{type}, Resolver::IN);
    my $cookie_client = "";
    if ($dns_server->{edns}) {
        $cookie_client = $dns_server->cookie_client($now);
        $qids->{$qid}{cookie} = $cookie_client;
        my $options = pack("(nn/a*)*",
                           OPTION_COOKIE() => $cookie_client . $dns_server->{cookie_server});
        $options .= pack("nx2", OPTION_KEEPALIVE) if
            $dns_server->{tcp} && $dns_server->{tcp}{nr_sent} == 0;
        $packet .= pack("xn2x4n/a*",
                        Resolver::OPT,
                        $dns_server->{max_udp_size},
                        $options);
    }

    $qids->{$qid} = {
        query		=> $query,
        tcp		=> $dns_server->{tcp} ? 1 : 0,
        name_sent	=> $name_sent,
        # Must remember cookie we sent since it can have changed at response
        cookie_client	=> $cookie_client,
        cookie_server	=> $dns_server->{cookie_server},
        sent		=> $now,
        timeout		=>
        # $dns_server->timeout0() would (incorrectly) set $dns_server->{timeout}
        Timer::timer0(DNS_TIMEOUT, $dns_server,
                      sub {shift->dns_timeout($qid)}),
    };
    $dns_server->{sent} = $now;

    if ($dns_server->{tcp}) {
        $resolver->bug("Already had qid $qid in TCP queue") if
            $dns_server->{qids_tcp}{$qid}++;
        $dns_server->{tcp}->write($packet);
    } else {
        $resolver->{dns}->write($dns_server, $packet);
    }
    return $qid;
}

# In principle this could supports multiple questions in one query
# In practice no DNS resolver supports this
# See https://stackoverflow.com/a/4083071/3042552
sub query {
    my ($resolver, $handle_ref, $type, $name, $object, $code, $data) = @_;

    defined $name || $resolver->bug("No query");

    my $now = Timer::clocktime();
    $resolver->get_hosts($now);

    if ($type == A) {
        if ($name =~ /^ (?:0x)? [0-9]+ (?: \. (?:0x)?  [0-9]+){1,3} \z/ix) {
            $$handle_ref = undef;
            my $addr = inet_aton($name);
            $code->($object, $addr ? [$addr] : undef, $data, $name);
            return 1;
        }
        if (my $addrs = $resolver->{hosts}{forward}{lc $name}[0]) {
            $$handle_ref = undef;
            $code->($object, $addrs, $data, $name);
            return 1;
        }
        # At some point maybe add punycode support here
    } elsif ($type == PTR) {
        my $n = join("." =>
                     reverse(split /\./ => inet_ntoa($name)), "in-addr.arpa");
        if (my $names = $resolver->{hosts}{reverse}{$name}) {
            $$handle_ref = undef;
            $code->($object, $names, $data, $n);
            return 1;
        }
        $name = $n;
    }
    my $name_low = $name;
    $name_low =~ s/([A-Z])/\l$1/g;

    my $query = $resolver->{queries}{$name_low}{$type} ||= {
        # The original case is preserved in the callbacks
        name_low	=> $name_low,
        type		=> $type,
        values		=> undef,
        expires		=> -INFINITY,	# Is also a negative expires
        pending		=> undef,
        name_servers	=> {},
        probe		=> undef,
        callbacks	=> [],
    };

    # Check if we have a cached answer
    # If not, see if we can construct an answer (unlikely but possible)
    if ($now <= $query->{expires} || $resolver->chase($now, $query)) {
        $$handle_ref = undef;
        $code->($object, $query->{values}, $data, $name, $query);
        return 1;
    }

    # We didn't get a definitive answer from the cache.
    # We will have to wait for the result of a DNS query

    # Perl tracks if any callbacks are left
    if (!$query->{probe}) {
        weaken($query->{probe} = \my $a);
        @{$query->{callbacks}} = ();
    }
    # Construct a handle to indicate interest in an answer
    # Store $name in callback (to preserve case)
    my $callback = [$object, $code, $name, $query->{probe}, $data];
    weaken($callback->[OBJ]);
    # Push weakly. After this point we always return 0
    weaken($query->{callbacks}[@{$query->{callbacks}}] = $callback);
    $$handle_ref = $callback;

    # Immediately return if a DNS query is already running
    return 0 if defined $query->{pending};

    # We need to initiate a DNS query
    # Make sure we have the most recent DNS configuration
    $resolver->get_resolv($now);
    $query->{pending} = $now;
    $resolver->queue($now, $query);
    return 0;
}

# This must become a lot more robust. Most dies should be handled
sub response {
    my ($resolver, $dns_server, $now, $bufref, $tcp) = @_;

    my $response = $$bufref;
    my $rlen = length $response;
    if ($rlen < DNS_MIN_RESPONSE) {
        $resolver->info("Invalid DNS response: Too short") if $verbose > 1;
        return;
    }
    my ($qid, $flags, @counts) = unpack("n6", $response);

    # Find the query. Be paranoid about spoofing
    my $server_data = $dns_server->{qids}{$qid};
    if (!$server_data) {
        $resolver->info(
            vec($dns_server->{qids_bits}, $qid, 1) ?
            "Response from '$dns_server->{display}' with unknown query id '$qid'" :
            "Duplicate response from '$dns_server->{display}' with query id '$qid'") if $verbose > 1;
        return;
    }
    if ($server_data->{tcp} != $tcp) {
        $resolver->info("Response tcp=$tcp from '$dns_server->{display}' for query id $qid sent with tcp=$server_data->{tcp}") if $verbose > 1;
        return;
    }
    my $query = $server_data->{query} ||
        $resolver->bug("No query in server_data");

    if ($counts[0] != 1) {
        $resolver->info("%s questions in response, but I only send queries with 1 question", $counts[0] ? "Multiple" : "No") if $verbose > 1;
        return;
    }
    # Check that QR=1, OPCODE=0, RD=1, Z=0
    ($flags & 0b1111100101110000) == 0b1000000100000000 || return;
    $flags & 1 << 8 ||
        die "Nameserver $dns_server->{host} does not support recursion";
    die "Answer truncated" if $flags & 1 << 9;
    my $authorative = $flags >> 10 & 1;
    my $rcode = $flags & 0b1111;

    my $pos = 12;	# We will start parsing just after the header

    # Helper to extract the DNS name at this position
    my $get_name = sub {
        my $name = "";
        my $start_pos = $pos;
        my $resume;
        while (1) {
            die "Truncated response\n" if $pos+1 > $rlen;
            my $len = ord substr($response, $pos++, 1) || last;
            if ($len < 64) {
                # $len should also be at least 2, but we'll allow it
                # Normal label
                die "Truncated response\n" if $pos+$len > $rlen;
                my $label = substr($response, $pos, $len);
                die "Label '$label' contains '.'\n" if $label =~ /\./;
                $name .= $label;
                # Must test here to avoid evil pointer infinite name growth
                die "Name '$name' too long\n" if length $name > 255;
                $name .= ".";
                $pos += $len;
            } elsif ($len >> 6 == 3) {
                # Pointer
                die "Truncated response\n" if $pos+1 > $rlen;
                $len = ($len & 0x3f) * 256 + ord substr($response, $pos++, 1);
                die "Forward pointer $len > $start_pos\n" if $len >= $start_pos;
                $resume ||= $pos;
                $pos = $start_pos = $len;
            } else {
                die "Invalid label length $len\n";
            }
        }
        chop $name;
        die "Invalid character ", ::display($1), " in name: ", ::display($name), "\n" if $name =~ /([^a-zA-Z0-9.-])/;
        $pos = $resume if $resume;
        return $name;
    };

    my $qtype = $query->{type};
    my $trusted = 0;
    my (@response, %results, $edns);
    eval {
        for my $section (0 .. $#counts) {
            push @response, \my @rr;
            for my $i (1..$counts[$section]) {
                my %rr = (name => $get_name->());
                ($rr{name_low} = $rr{name}) =~ s/([A-Z])/\l$1/g;
                push @rr, \%rr;
                if ($section == QUESTION) {
                    $server_data->{name_sent} eq $rr{name} ||
                        die "Asked for '$server_data->{name_sent}', got '$rr{name}'\n";

                    die "Truncated response\n" if $pos + 4 > $rlen;
                    @rr{qw(type class)} = unpack("nn", substr($response, $pos, 4));
                    $pos += 4;
                    $rr{class} == IN ||
                        die "I did not ask for class '$rr{class}'\n";

                    # Reply is at least somewhat trusted. It came from the
                    # right server with the right qid with the right class with
                    # the right case
                    $trusted = 1;
                    next;
                }

                die "Truncated response\n" if $pos+10 > $rlen;
                (@rr{qw(type class ttl)}, my $rdlength) = unpack("nnNn", substr($response, $pos, 10));
                $pos += 10;
                die "Truncated response\n" if $pos+$rdlength > $rlen;
                $rr{rdata} = substr($response, $pos, $rdlength);
                $pos += $rdlength;
                if ($rr{type} == OPT && $section == ADDITIONAL) {
                    die "Multiple EDNS OPT types\n" if $edns;
                    delete $rr{name} eq "" || die "Non empty name in EDNS\n";
                    $edns = \%rr;
                    $rr{udp_size} = delete $rr{class};
                    my $ttl = delete $rr{ttl};
                    $rcode |= $ttl >> 20 & 0xff0;
                    $rr{version} = $ttl >> 16 & 0xff;
                    $rr{dnssec_ok} = $ttl >> 15 & 1;
                    $rr{Z} = $ttl & 0x7fff;
                    my $rdata = delete $rr{rdata};
                    $rr{options} = \my %options;
                    while ($rdata ne "") {
                        # Errors here indicate a bad server (or spoofer)
                        length $rdata >= 4 || die "Truncated EDNS value\n";
                        my ($code, $len) = unpack("nn", substr($rdata, 0, 4, ""));
                        # Duplicates aren't forbidden really.
                        # The cookie RFC says only the first occurance counts
                        # That is the only option we care about, so skip extras
                        next if exists $options{$code};
                        length $rdata >= $len  || die "Truncated EDNS value\n";
                        $options{$code} = substr($rdata, 0, $len, "");
                    }
                } elsif ($rr{class} != IN) {
                    die "Type $rr{type} Non class IN response\n" if $section == ANSWER;
                    next;
                }

                if ($rr{type} == CNAME || $rr{type} == PTR) {
                    my $p = $pos;
                    $pos -= $rdlength;
                    $rr{rdata} = $get_name->();
                    ($rr{rdata_low} = $rr{rdata}) =~ s/([A-Z])/\l$1/g if
                        $rr{type} == CNAME;
                    $p == $pos || die "inconsistent CNAME size\n";
                }
                push @{$results{$rr{name_low}}{$rr{type}}}, \%rr if
                    $section == ANSWER && ($rr{type} == $qtype || $rr{type} == CNAME);
            }
        }
        $pos == $rlen || die "Spurious response bytes\n";

        # How much do we trust the response ?
        $trusted || return;

        $dns_server->{edns} ||
            $resolver->bug("Non EDNS requests not implemented (yet)");
        $edns || die "Non EDNS response not implemented (yet)\n";
        my $cookie_server = $edns->{options}{OPTION_COOKIE()} ||
            die "Non cookie EDSN response not implemented (yet)\n";

        # Server does cookies. Trust must now come from cookie
        $trusted = 0;

        length $cookie_server >= 16 || die "Cookie response too short\n";
        length $cookie_server <= 49 || die "Cookie response too long\n";
        my $cookie_client = substr($cookie_server, 0, 8, "");
        $cookie_client eq $server_data->{cookie_client} || return;

        # My cookie was in the reply. We trust the sender enough for cookies
        $trusted = 1;

        # But if our cookie rolled over don't try to update the server cookie
        $cookie_client eq $dns_server->{cookie_client} || return;

        # If the response matches the request server cookie we don't update
        # (this avoids out of order replies reverting a new server cookie
        return if $cookie_server eq $server_data->{cookie_server};
        # No need for update if we got a consistent server cookie
        # (if it is different it is because we did an update in the mean time
        # which itself must have been from a devergent cookie)
        return if $cookie_server eq $dns_server->{cookie_server};

        # We got an inconsistent server cookie.
        $resolver->info("Change DNS server '%s' cookie from '%s' to '%s'",
                        $dns_server->{display},
                        unpack("H*", $dns_server->{cookie_server}),
                        unpack("H*", $cookie_server));
        $dns_server->{cookie_server} = $cookie_server;
    };

    if ($@) {
        my $err = "Type $qtype DNS query for '$query->{name_low}': $@";
        # Need to do more intelligent stuff if the response got positively
        # matched to a our query
        die $err if $trusted;
        $resolver->info($err) if $verbose > 1;
        return;
    }
    $trusted || $resolver->bug("Untrusted without error");

    $dns_server->{received} = $now;
    delete $dns_server->{qids}{$qid};
    vec($dns_server->{qids_bits}, shift @{$dns_server->{qids_free}}, 1) = 0 if
        push(@{$dns_server->{qids_free}}, $qid) > MAX_FREE;
    if ($tcp) {
        my $tcp_connection = $dns_server->{tcp} ||
            $resolver->bug("TCP answer without TCP connection");
        if (my $keepalive = $edns->{options}{OPTION_KEEPALIVE()}) {
            if (length $keepalive == 2) {
                $tcp_connection->{keepalive} = unpack("n", $keepalive) / 10;
                $resolver->info("Set TCP idle timeout to %.1fs", $tcp_connection->{keepalive}) if $verbose > 1;
            }
        }
        delete $dns_server->{qids_tcp}{$qid} ||
            $resolver->bug("Qid $qid was not on the TCP queue");
        %{$dns_server->{qids_tcp}} || $tcp_connection->idle;
    }
    $query->{pending} = undef;

    if ($rcode && $rcode != NAME_ERROR) {
        # Start doing more intelligent things here...
        die "Unhandled error code from DNS server $dns_server->{display}: $rcode";
    }

    # Packet is processed. Add result to cache
    my $error = 0;
    for my $name_low (keys %results) {
        my ($type, @values) = keys %{$results{$name_low}};
        if (@values) {
            # Due to program logic @values = 1 ($qtype and CNAME in some order)
            @values == 1 &&
                ($type == CNAME  && $values[0] == $qtype ||
                 $type == $qtype && $values[0] == CNAME) ||
                     $resolver->bug("Type $qtype query for '$name_low' returned impossible multiple result types: $type @values");
            # Getting her is not a program bug, but a DNS server giving at least
            # a combined CNAME and $qtype response (already dropped extras)
            die "Type $qtype query for '$name_low' returned a result AND a CNAME";
        }
        my $ttl = TTL_MAX;
        for my $rr (@{$results{$name_low}{$type}}) {
            # All these TTLs probable should be the same
            $ttl = $rr->{ttl} if $rr->{ttl} < $ttl;
            push @values, $rr->{rdata};
            if ($type == CNAME && !$results{$rr->{rdata_low}}) {
                $error ||= NAME_ERROR;
                delete $resolver->{cache}{$rr->{rdata_low}}{CNAME()};
                my $cache = $resolver->{cache}{$rr->{rdata_low}}{$type} ||= {};
                $cache->{expires} = $now + NEGATIVE;
                $cache->{values} = undef;
            }
        }
        my $base = $resolver->{cache}{$name_low} ||= {};
        my $cname = delete $base->{CNAME()};
        if ($type == CNAME) {
            # Clean up all other entries and re-attach the cname
            %$base = ();
            $base->{CNAME()} = $cname;
        }
        my $cache = $base->{$type} ||= {};
        $cache->{values} = \@values;
        $cache->{expires} = $now + $ttl;
        $cache->{official} = $results{$name_low}{$type}[0]{name};
    }

    if (!$results{$query->{name_low}}) {
        $error ||= NAME_ERROR;
        delete $resolver->{cache}{$query->{name_low}}{CNAME()};
        my $cache = $resolver->{cache}{$query->{name_low}}{$qtype} ||= {};
        $cache->{expires} = $now + NEGATIVE;
        $cache->{values} = undef;
    }
    $rcode == $error || do {
        print STDERR ::Dumper([\@response, \%results]);
        $resolver->bug("Expected response code $error but got $rcode");
    };

    $resolver->chase($now, $query) ||
        $resolver->bug("No chase result for response I just entered in the cache");
    $resolver->dispatch($query);
}

sub get_resolv {
    my ($resolver, $now) = @_;

    return if $now <= $resolver->{conf}{checked} + CHECK_DELAY;
    my $conf = $resolver->{conf};
    $conf->{checked} = $now;

    eval { $resolver->_get_resolv };
    if ($@) {
        die $@ unless $conf->{stat};
        # Should probably be rate limited (already implicitely by CHECK_DELAY)
        $@ =~ s/\.?\s*\z//;
        $resolver->info("File '$resolv_file': $@. Keep using the existing resolver configuration") if $verbose;
    }
}

sub _get_resolv {
    my ($resolver) = @_;

    my $conf = $resolver->{conf};
    if ($conf->{stat}) {
        my @stat = stat($resolv_file) or die "Could not stat: $^E";
        return if "@stat[@{STAT_SAME()}]" eq "@{$conf->{stat}}[@{STAT_SAME()}]";
    }

    # This part should be rarely executed (often only once)

    # If we get here we plan to a DNS query, so we need a socket
    $resolver->{dns} || weaken($resolver->{dns} = DNS::UDP->new($resolver));

    open(my $fh, "<", $resolv_file) || die "Could not open: $^E";
    my (@nameservers, %dns_servers, @search, @domain);
    my @options = (
        # These are the linux defaults
        "ndots:1",
        "timeout:5",
        "attempts:2",
    );
    local $_;
    while (<$fh>) {
        next if /^\s*[#;]/;
        s/\s+\z//;
        s/^\s+//;
        if (my ($ip, $port) =
            /^ nameserver \s+
             # ( (?:0x)? [0-9]+ (?: \. (?:0x)?  [0-9]+){1,3} )
             (\S*)
             (?::([0-9]+))?
             \z/ix) {
            $port ||= 53;
            # Will do no real resolving since we have a numeric value
            my $dns_server = DnsServer->parse("$ip:$port", "nameserver",
                                               to => "udp4", resolve => 1);
            if ($dns_servers{$dns_server->{packed}}) {
                $resolver->info("Duplicate nameserver '$dns_server->{display}'") if $verbose;
                next;
            }
            $dns_servers{$dns_server->{packed}} = $dns_server;
            push @nameservers, $dns_server->{packed};
        } elsif (/^ search \s+ (.*\S)/ix) {
            push @search, split " ", $1;
        } elsif (/^ domain \s+ (.*\S)/ix) {
            push @domain, split " ", $1;
        } elsif (/^ options \s+ (.*\S)/ix) {
            push @options, split " ", $1;
        }
    }
    @nameservers || die "No IPv4 DNS servers in file '$resolv_file'";

    if (defined $ENV{LOCALDOMAIN}) {
        @search = split " ", $ENV{LOCALDOMAIN};
    } else {
        @search = @domain if !@search;
    }
    my %seen;
    @search = grep !$seen{lc()}++, @search;

    push @options, split " ", $ENV{RES_OPTIONS} if defined $ENV{RES_OPTIONS};
    my %options;
    for my $option (@options) {
        my ($o, $rest) = split /:/, $option, 2;
        if (defined $rest) {
            $options{$o} = looks_like_number($rest) ? $rest+0 : 0;
        } else {
            $options{$o} = 1;
        }
    }
    # Linux limits
    $options{ndots}    = 15 if $options{ndots}    > 15;
    $options{timeout}  = 30 if $options{timeout}  > 30;
    $options{attempts} =  5 if $options{attempts} >  5;

    my @stat = stat($fh) or die "Could not stat open file: $^E";

    # From here on we cannot fail anymore
    for my $nameserver (@{$conf->{nameserver}}) {
        my $dns_server = $conf->{dns_servers}{$nameserver} ||
            $resolver->bug("Active nameserver not in list");
        next if $dns_servers{$nameserver};
        if (%{$dns_server->{qids}}) {
            # Old DNS servers remain in the list if they have pending requests
            $dns_server->{nameserver} = 0
        } else {
            delete $conf->{dns_servers}{$nameserver};
        }
    }
    $conf->{nameserver} = \@nameservers;
    for my $nameserver (@nameservers) {
        next if $conf->{dns_servers}{$nameserver};
        $dns_servers{$nameserver}->init;
        $conf->{dns_servers}{$nameserver} = $dns_servers{$nameserver};
    }

    $conf->{search} = \@search;
    $conf->{options} = \%options;
    $conf->{checked} = INFINITY if $options{"no-reload"};
    $conf->{stat} = \@stat;

    $resolver->info("Loaded named file '$resolv_file'") if $verbose > 1;
}

sub get_hosts {
    my ($resolver, $now) = @_;

    return if $now <= $resolver->{hosts}{checked} + CHECK_DELAY;
    $resolver->{hosts}{checked} = $now;

    eval { $resolver->_get_hosts };
    if ($@) {
        die $@ unless $resolver->{hosts}{stat};
        # Should probably be rate limited (already implicitely by CHECK_DELAY)
        $@ =~ s/\.?\s*\z//;
        $resolver->info("File '$hosts_file': $@. Keep using the existing hosts file") if $verbose;
    }
}

sub _get_hosts {
    my ($resolver) = @_;

    if ($resolver->{hosts}{stat}) {
        my @stat = stat($hosts_file) or die "Could not stat: $^E";
        return if "@stat[@{STAT_SAME()}]" eq "@{$resolver->{hosts}{stat}}[@{STAT_SAME()}]";
    }

    # This part should be rarely executed (often only once)
    open(my $fh, "<", $hosts_file) || die "Could not open: $^E";
    my (%forward, %reverse);
    local $_;
    while (<$fh>) {
        s/#.*//;
        my ($ip, $names) = /^
                            \s*
                            ( (?:0x)? [0-9]+ (?: \. (?:0x)?  [0-9]+){1,3})
                            \s+
                            (.*\S)
                           /ix or next;
        my $addr = inet_aton($ip) || next;
        my @names = split " ", $names;
        push @{$forward{lc()}[0]}, $addr for @names;
        push @{$reverse{$addr}}, @names;
    }
    # Remove duplicates
    my %seen;
    for my $names (values %reverse) {
        %seen = ();
        @$names = grep !$seen{lc()}++, @$names;
    }
    for my $ips (values %forward) {
        for my $addrs (@$ips) {
            $addrs || next; # if there is no IPv4 there will be a hole
            %seen = ();
            @$addrs = grep !$seen{$_}++, @$addrs;
        }
    }
    my @stat = stat($fh) or die "Could not stat open file: $^E";

    # From here on we cannot fail anymore
    $resolver->info("Loaded hosts file '$hosts_file'") if $verbose > 1;
    my $hosts = $resolver->{hosts};
    $hosts->{forward} = \%forward;
    $hosts->{reverse} = \%reverse;
    $hosts->{stat} = \@stat;
}

sub freeze {
    my $resolver = shift;

    for my $dns_server (values %{$resolver->{conf}{dns_servers}}) {
        my @bits = grep vec($dns_server->{qids_bits}, $_, 1), 0..8*length($dns_server->{qids_bits})-1;
        Object::_dump_save($dns_server->{qids_bits}, "bit_string(@bits)");
    }
    $resolver->SUPER::freeze(qw(hosts cache));
}

package DNS::UDP;
# Do system DNS queries over UDP
# DNS::UDP->new($parent, %options)
use vars qw(@ISA);
@ISA = qw(UDP0);

sub new_suspended {
    my $class = shift;
    my $root = shift;

    my ($local, $socket) = ConnUtils->socket_udp($UDP4_ANY);
    return $class->SUPER::new_suspended(
        $root, $socket, $socket,
        local => $local,
        @_);
}

sub on_read {
    my ($dns, $from, $ttl, $bufref) = @_;

    my $resolver = $dns->{parent};
    my $dns_server = $resolver->{conf}{dns_servers}{$from->{packed}};
    if (!$dns_server) {
        $resolver->info("Response from unknown DNS server '$from->{display}'") if $verbose > 1;
        return;
    }
    $resolver->response($dns_server, Timer::now(), $bufref, 0);
}

package DNS::TCP;
# Do system DNS queries over TCP
# DNS::UDP->new($parent, %options)
use vars qw(@ISA);
@ISA = qw(Stream0);

use constant {
    # How long we keep an idle DNS TCP connection open
    KEEPALIVE	=> 2,
    INFINITY	=> 9**9**9,
};

sub eof : method {
    die "eof not implemented (yet)";
}

sub new_suspended {
    my $class = shift;

    return $class->SUPER::new_suspended(
        shift, undef, undef,
        nr_sent		=> 0,
        nr_received	=> 0,
        keepalive	=> KEEPALIVE,
        sent		=> -INFINITY,
        received	=> -INFINITY,
        @_);
}

# Must write whole packets
sub write {
    my $tcp = shift;

    my $len = 0;
    $len += length for @_;
    $tcp->SUPER::write(pack("n", $len), @_);
    ++$tcp->{nr_sent};
}

sub on_empty {
    my ($tcp) = @_;
    $tcp->SUPER::on_empty;
    $tcp->{sent} = Timer::now();
    # Since we just sent stuff we have requests pending, so we are not idle
}

sub on_read {
    my $tcp = shift;

    my $now = $tcp->{received} = Timer::now();
    while (1) {
        my ($len) = unpack("n", $tcp->{in}) or return;
        length $tcp->{in} >= $len || return;
        ++$tcp->{nr_received};
        my $packet = substr($tcp->{in}, 0, $len+2, "");
        substr($packet, 0, 2, "");
        $tcp->{parent}->response($tcp->{peer}, $now, \$packet, 1);
    }
}

sub idle {
    my ($tcp) = @_;

    $tcp->bug("Cant't be idle if we have a timeout") if $tcp->{timeout};
    $tcp->timer0($tcp->{keepalive} * 0.9, \&idle_timeout);
}

sub idle_timeout {
    my ($tcp) = @_;

    $tcp->finish("Idle DNS TCP connection");
}

package DnsServer;
# State of a particular DNS server
use vars qw(@ISA);
@ISA = qw(Address);

use Digest::MD5 qw(md5);
use Scalar::Util qw(weaken);

use constant {
    INFINITY		=> 9**9**9,
    # Maximium number of queries per nameserver
    # Current recommended max requested UDP size to avoid fragmentation
    MAX_UDP_SIZE	=> 1232,
    COOKIE_VALIDITY	=> 24*60*60,
};

sub init {
    my ($dns_server) = @_;

    $dns_server->{nameserver} = 1;

    $dns_server->{qids} = {};
    vec($dns_server->{qids_bits} = "", int(2**16-1), 1) = 0;
    $dns_server->{qids_free} = [];

    $dns_server->{tcp} = undef;
    $dns_server->{qids_tcp} = {};
    $dns_server->{permute_case} = 1;
    $dns_server->{edns} = 1;
    $dns_server->{max_udp_size} = MAX_UDP_SIZE;
    $dns_server->{cookie_server} = "";
    $dns_server->{cookie_client} = "";
    $dns_server->{cookie_client_expires} = -INFINITY;
    $dns_server->{sent} = -INFINITY;
    $dns_server->{received} = -INFINITY;
}

sub cookie_client {
    my ($dns_server, $now) = @_;

    return $dns_server->{cookie_client} if
        $now <= $dns_server->{cookie_client_expires};

    # server cookies are based on client cookie, so invalidate them
    $dns_server->{cookie_server} = "";

    # Make cookie vaidity less predictable
    $dns_server->{cookie_client_expires} = $now +
        0.6 * COOKIE_VALIDITY + rand(0.4 * COOKIE_VALIDITY);
    my $local = ConnUtils->socket_udp_connected($dns_server, 1);
    return $dns_server->{cookie_client} = substr(md5(
        $dns_server->{packed} .
        $local->{packed} .
        $SECRET .
        pack("NN", $$ ^ rand int 2**32, $^T ^ rand int 2**32) .
        $dns_server .
        $dns_server->{cookie_client} .
        $now), 0, 8);
}

sub dns_timeout {
    my ($dns, $qid) = @_;

    die "dns_timeout not implemented (yet)";
}

sub tcp {
    my ($dns_server, $resolver) = @_;

    return $dns_server->{tcp} if $dns_server->{tcp};
    my $tcp = DNS::TCP->new($resolver, peer => $dns_server);
    weaken($dns_server->{tcp} = $tcp);
    $tcp->connect;
    return $tcp;
}

package LineProtocol;
# Handle traffic between client and server
# LineProtocol->new($root, $socket_in, $socket_out, %options)
use vars qw(@ISA);
@ISA = qw(Stream);

use FindBin qw($Script);
use Errno qw(EINTR EAGAIN EWOULDBLOCK);
use Socket qw(inet_ntoa);
use Scalar::Util qw(weaken);
use Carp qw(croak);
use Digest::MD5 qw(md5);
use Socket qw(unpack_sockaddr_in);

use constant {
    ACK_MASK	=> 0xffffffff,
};

my %process_name = (
    $SET		=> "SET",
    $START		=> "START",
    $KEEP		=> "KEEP",
    $FOU_REMOTE		=> "FOU_REMOTE",
    $UDP_DATA		=> "UDP_DATA",
    $PING		=> "PING",
    $RESPONSE_UDP	=> "RESPONSE_UDP",
    $RESPONSE_PING	=> "RESPONSE_PING",
    $CONNECT		=> "CONNECT",
    $CONNECT_REMOTE	=> "CONNECT_REMOTE",
    $LISTEN_REMOTE	=> "LISTEN_REMOTE",
    $TCP_DATA		=> "TCP_DATA",
    $TCP_EOF		=> "TCP_EOF",
    $TCP_FIN		=> "TCP_FIN",
    $SOCKS		=> "SOCKS",
    $SOCKS_REMOTE	=> "SOCKS_REMOTE",
    $SOCKS_RESULT	=> "SOCKS_RESULT",
    $SOCKS_DATA		=> "SOCKS_DATA",
);

my %process = %process_name;
$_ = __PACKAGE__->can("process_$_") || die "Unknown sub 'process_$_'" for
    values %process;

sub new_suspended {
    my $class		= shift;
    my $parent		= shift;
    my $socket_in	= shift;
    my $socket_out	= shift;

    my $line = $class->SUPER::new_suspended(
        $parent, $socket_in, $socket_out,
        settings	=> { %{$parent->{settings}} },
        started		=> undef, # Normal operations started
        utime_offset	=> 0,	# Estimated round trip time in microsecond
        keepalive	=> undef,
        map_udp		=> {},
        seqno_echo	=> 0,
        unacked		=> 0,
        in_acked	=> 0,
        out_sent	=> 0,
        out_base	=> 0,
        ping_queued	=> [],
        @_);
    my $ids2 = Ids2->new;
    # These classes share the Ids2 object since they can be reblessed
    $line->ids_set(
        "TCP::Forward"	=> $ids2,
        "Socks::Local"	=> $ids2,
        "Socks::Connect"=> $ids2,
        "Socks::Accept"	=> $ids2,
        "UDP::Forward"	=> $ids2,
    );
    return $line;
}

sub error {
    my $line = shift;

    $line->error_finish(@_);
}

sub on_read {
    my ($line, $rc) = @_;

    $line->{unacked} += $rc;
    $line->keepalive() if $line->{unacked} >= $line->{settings}{ACK_LIMIT};

    while ($line->{in} =~ /^([\x80-\xff]{0,2}[\x00-\x7f].)/s) {
        my ($length, $command) = unpack("wa", $line->{in});
        last if length($line->{in}) < $length;
        my $message = substr($line->{in}, 0, $length, "");
        substr($message, 0, length $1, "");
        $line->info("Processing %s: %s",
                    $process_name{$command} || "Unknown command $command",
                    ::display($message)) if $verbose > 1;
        my $fun = $process{$command} ||
            $line->die("No handler for proto %s", ::display($command));
        $fun->($line, $message, $command);
    }
}

sub writing {
    my ($line) = @_;

    return if $line->{unwritable};
    $line->{writer} ||= Events::add_write($line->{socket_out}, $line, \&writer);
    $line->{timeout} = Timer::timer($line->{settings}{TIMEOUT},
                                    $line, \&Conection::timeout);
}

sub write : method {
    my $line = shift;
    my $command = shift;

    my $length = 2;
    $length += length for @_;
    ++$length if $length >= 128;
    ++$length if $length >= 128*128;
    # Don't accept more than 3 BER bytes (~ 2**21 byte message)
    croak "Message too long" if $length >= 128*128*128;

    $line->{out} .= pack("wa", $length, $command);
    $line->{out} .= $_ for @_;
    # $line->info("Constructed %s: %s", $command, unpack("H*", substr($line->{out}, -$length)));

    if ($line->{out_sent} + $length == length $line->{out}) {
        $line->{keepalive} = undef;
        $line->writing;
    }
    return $length;
}

sub writer {
    my ($line) = @_;

    use Scalar::Util qw(blessed);
    blessed($line) && $line->isa("HASH") || $root->bug("Object not a line, but %s", ::Dumper($line) =~ s/\s*\z//r);
    while (1) {
        my $rc = syswrite($line->{socket_out}, $line->{out}, $BLOCK_SIZE, $line->{out_sent});
        if (!$rc) {
            $line->die("Zero write. Is this even possible ?") if defined $rc;
            if ($! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK) {
                $line->{timeout} ||= Timer::timer($line->{settings}{TIMEOUT},
                                                  $line, \&Connection::timeout);
            } else {
                $line->error("Could not write to $role_peer: $^E");
            }
            return;
        }
        $line->info("Wrote to %s: %s (%d left)",
                    $role_peer,
                    ::display(substr($line->{out}, $line->{out_sent}, $rc)),
                    length($line->{out})-$line->{out_sent}-$rc) if $verbose > 1;

        $line->{out_sent} += $rc;
        if (length $line->{out} == $line->{out_sent}) {
            $line->_end_write, return if $line->{end_write};
            $line->{timeout} = undef;
            $line->{writer} = undef;
            $line->{keepalive} =
                $line->timer($line->{settings}{KEEPALIVE}, \&keepalive);
            return;
        }
        $line->{timeout} = undef;
    }
}

sub _end_write {
    my ($line) = @_;

    $line->{keepalive} = undef;
    $line->SUPER::_end_write;
}

sub out_is_empty {
    my ($line) = @_;

    return length $line->{out} == $line->{out_sent};
}

sub ready {
    my ($line, $msg, $peer_msg) = @_;

    if ($verbose) {
        ::peer_info($peer_msg) if $line->{client_only};
        if ($verbose > 1) {
            $line->info($msg);
        } else {
            ::info($msg);
        }
        # Add extra line to make this stand out
        print STDERR "\n";
    }
    $line->activate_read;
}

sub activate_read {
    my $line = shift;

    my $classes = $line->{children} || return;
    for my $class (sort keys %$classes) {
        $class->isa("_Listener") || $class->isa("_UDP") || next;
        my $children = $classes->{$class};
        $children->{$_}->resume_read("quiet") for sort { $a <=> $b } keys %$children;
    }
}

sub keepalive {
    my ($line) = @_;

    $line->info("Sending KEEPALIVE/ACK %d (new base %d)",
                $line->{unacked},
                $line->{in_acked} + $line->{unacked} & ACK_MASK) if $verbose > 1;
    die "Assertion: Unacked $line->{unacked} is out of range" if
        $line->{unacked} > 0xffffffff;
    my $msg = sprintf("%.0f\0%0.f\0%s",
                      (Timer::realtime() - $BASE_TIME)*1e6,
                      $line->{utime_offset}, pack("V", $line->{unacked}));
    $msg =~ s/\0+\z//;
    my $length = $line->write($KEEP, $msg);
    if ($length >= $line->{settings}{ACK_LIMIT}) {
        $line->{settings}{ACK_LIMIT} = ++$length;
        $line->info("Increasing ACK_LIMIT to $length") if $verbose;
    }
    $line->{in_acked} = $line->{in_acked} + $line->{unacked} & ACK_MASK;
    $line->{unacked} = 0;
}

sub ping_activate {
    my ($line, $icmp) = @_;

    if (@{$line->{ping_queued}} || !$line->{parent}->ping_activate($line, $icmp)) {
        weaken($line->{ping_queued}[@{$line->{ping_queued}}] = $icmp);
        return 0;
    }
    return 1;
}

sub ping_finished {
    my ($line, $root) = @_;

    while (@{$line->{ping_queued}}) {
        my $icmp = shift @{$line->{ping_queued}} || next;
        weaken($line->{ping_queued}[@{$line->{ping_queued}}] = $icmp) if
            $icmp->ping_finished($line, $root);
        return scalar @{$line->{ping_queued}};
    }
    return 0;
}

sub status {
    my ($line, $control, $indent) = @_;

    #local $Data::Dumper::Varname = "VAR";
    #my $settings = ::Dumper($line->{settings});
    #$settings =~ s/\$VAR1 = //g || die "Assertion: No VAR1";
    #$settings =~ s/\s+\z//;
    my $name = $line->name;
    my $settings = ::string_from_value($line->{settings});
    $settings =~ s/\n/\n$indent  /g;

    $control->{collect} .= <<"EOF"
$indent$name
$indent  Settings: $settings
EOF
        ;
}

sub process_SET {
    my $line  = shift;

    my $i = unpack("C", substr($_[0], 0, 1, ""));
    my $name = $setting_ids[$i] || die "Unknown variable $i";
    # At the moment all values are numbers
    $line->{settings}{$name} = $_[0] =~ /^0\z|^[1-9][0-9]*\z/ ? int($_[0]) : $_[0];
    $line->info("Set %s=%s", $name, $_[0]) if $verbose > 1;
}

sub process_START {
    my $line  = shift;

    defined $line->{settings}{EPOCH} || die "Lost early epoch message";

    $line->{started} = 1;

    my $clock_name = Timer::CLOCK_TYPE_NAME;
    my $msg = "$Script $role $me\@$hostname ready (clock $clock_name, pid $$)";

    $line->write($START, $msg) if $role eq "server";
    $line->ready($msg, shift);
}

sub process_KEEP {
    my $line  = shift;

    # Transit time is of course meaningless if the clocks aren't
    # synchronized very well. offset tries to compensate for that

    # add 5 \0 in case they were trimmed (1 for the last Z and 4 for V)
    my ($utime, $uoffset, $acked) = unpack("Z*Z*V", shift() . "\0" x 5);

    die "Assertion: Impossible ACK" if $acked > $line->{out_sent};
    substr($line->{out}, 0, $acked, "");
    $line->{out_sent} -= $acked;
    $line->{out_base} = $line->{out_base} + $acked & ACK_MASK;

    # uoffset has     peertime - mytime + transit_time (me -> peer)
    # This calculates mytime - peertime + transit_time (peer -> me)
    $line->{utime_offset} = (Timer::realtime() - $line->{settings}{EPOCH})*1e6 -$utime || 1;
    $line->info("Received ACK=%d (base=%d, sent=%d), Keepalive transit=%.3f ms" .
                ($uoffset ? ", roundtrip=%.3f ms, offset=%.0f ms" : ""),
                $acked, $line->{out_base}, $line->{out_sent},
                $line->{utime_offset}/1e3,
                $uoffset ? (
                    ($line->{utime_offset}+$uoffset)/1e3,
                    ($line->{utime_offset}-$uoffset)/2e3) : ()) if $verbose > 1;
}

sub process_FOU_REMOTE {
    my ($line, $udp) = @_;

    my ($from, $to) =
        $udp =~ m{^([^%]+)%([^%]+)\z} or
        die "Invalid fou_remote '$udp'";
    $from = Address->parse($from, "FOU remote", from => "UDP4", resolve => 1);
    $to   = Address->parse($to  , "FOU remote", to   => "UDP4", resolve => 1);

    my $fou = Fou::UDP->new($line->{parent}, $to);
    my $listener = Receiver::Fou->new($line, $from, $fou);
}

sub process_UDP_DATA {
    my $line = shift;

    my ($id, $ttl, $to, $pos) = unpack("wCw/a*.", $_[0]);
    substr($_[0], 0, $pos, "");
    $to = Address->decode($to, "packet", 1);
    $id || die "Assertion: Sender socket id $id == 0";
    $id <= $line->{settings}{UDP_MAX} ||
        die "Assertion: Sender socket id $id > $line->{settings}{UDP_MAX}";
    $line->info("Need to send UDP data (TTL %d) from socket %d to %s: %s",
                $ttl, $id, $to->{display}, ::display($_[0])) if $verbose > 1;
    my $sender = $line->child("Sender::UDP", $id) ||
        Sender::UDP->new($line, $id);
    $sender->write($to, shift, $ttl);
}

sub process_RESPONSE_UDP {
    my $line = shift;

    my ($id, $from, $ttl, $data) = unpack("ww/a*Ca*", shift);
    $from = Address->decode($from, "packet", 1);
    $id || die "Assertion: Sender socket id $id == 0";
    $id <= $line->{settings}{UDP_MAX} ||
        die "Assertion: Sender socket id $id > $line->{settings}{UDP_MAX}";
    $line->info("\u$role_peer received UDP data on socket %d from %s: %s",
                $id, $from->{display}, ::display($data)) if $verbose > 1;
    my $map_src = $line->{map_udp}{$from->{display}};
    if (!$map_src) {
        # We should rate limit this message if $verbose == 1
        $line->info("No map for $from->{display}. Dropping packet") if $verbose;
        return;
    }
    my $map = $map_src->[2][$id] || die "Assertion: No Sender socket[$id]";
    $map->{seq} = $map_src->[0]++;
    die "Too many packets from $from->{display}" if
        $map->{seq} == $map_src->[0];
    my $fou = $root->child("Fou::UDP", $map->{fou_id}) ||
        die "Assertion: No Fou::UDP with id '$map->{fou_id}'";

    my ($dprt, $ndst) = unpack_sockaddr_in($map->{packed});
    my ($nsrc, $sprt) = @$from{qw(addr port)};

    # Build FOU IP packet

    # Packet ID is meaningless for atomic packets (RFC 6864)
    my $packet_id = int rand 2**16;
    my $flags = $DF;

    my $length = length($data);
    my $new_length = $length + $IHL * 4 + $UDP_HEADER;
    # Currently we don't handle overly large FOU packets
    if ($new_length >= 2**16) {
        $line->info("Cannot build oversized FOU packet. Dropped") if $verbose > 1;
        return;
    }

    my $header = pack("CCnnnCCx2a4a4",
                      $IP_VERSION << 4 | $IHL,
                      0,
                      $new_length,
                      $packet_id,
                      $DF << 13 | 0,
                      $ttl,
                      $PROTO_UDP,
                      $nsrc,
                      $ndst,
                  );
    my $sum = unpack("%32n*", $header);
    while ($sum > 0xffff) {
        my $carry = $sum >> 16;
        $sum &= 0xffff;
        $sum += $carry;
    }
    substr($header, 10, 2, pack("n", 0xffff - $sum));

    my $pseudo10 = pack("a4a4xC", $nsrc, $ndst, $PROTO_UDP);
    my $udp_header = pack("nnn", $sprt, $dprt, $length + $UDP_HEADER);
    # Temporarily add a 0 byte so we can do even padding
    $data .= "\0";

    $sum = unpack("%32n*", $pseudo10) + unpack("%32n*", $udp_header) + unpack("%32n*", $data) + $length + $UDP_HEADER;

    while ($sum > 0xffff) {
        my $carry = $sum >> 16;
        $sum &= 0xffff;
        $sum += $carry;
    }
    chop $data;
    my $buffer = $header . $udp_header . pack("n", 0xffff - $sum || 0xffff) . $data;

    if (0) {
        my $buf = $buffer;
        # For FOU packet construction debug
        my ($ihl, $ecn, $length, $packet_id, $fragment, $ttl, $proto, $chksum, $src, $dst) = unpack("CCnnnCCna4a4", $buf);
        my $version = $ihl >> 4;
        $ihl &= 0xf;
        my $flags = $fragment >> 13;
        $fragment &= 0x1fff;
        # only TCP4
        $version == $IP_VERSION || die "Wrong version $version";
        # Only UDP
        $proto == $PROTO_UDP || die "Wrong proto $proto";
        # Sanity check on buffer
        length($buf) == $length ||
            die "Wrong length ", length($buf);
        # We don't handle IP options (yet)
        $ihl == $IHL || die "Wrong ihl $ihl";
        # Too many hops
        $ttl || die "Bad TTL $ttl";
        # Don't handle fragments (fragment offset)
        die "Unexpected fragment $fragment" if $fragment;
        # Don't handle fragments (MF flag set)
        die "Bad flags $flags" if $flags & 0x1;

        my $pseudo10 = pack("a4a4xC", $src, $dst, $proto);

        $ihl *= 4;
        my $header = substr($buf, 0, $ihl, "");
        $length -= $ihl;

        # No buffer padding needed since length($header) is even
        my $sum = unpack("%32n*", $header);
        while ($sum > 0xffff) {
            my $carry = $sum >> 16;
            $sum &= 0xffff;
            $sum += $carry;
        }
        $sum == 0xffff || die "Bad IP checksum $sum";

        $src = inet_ntoa($src);
        $dst = inet_ntoa($dst);

        my $dscp = $ecn >> 3;
        $ecn &= 0x7;
        $line->info("HEADER: DSCP=$dscp, ECN=$ecn, ID=$packet_id, FLAGS=$flags, FRAGMENT=$fragment, TTL=$ttl, CHKSUM=$chksum, SUM=$sum, SRC=$src, DST=$dst");

        # Must have space for UDP header
        die "Bad UDP length $length" if $length < $UDP_HEADER;

        # Pad buffer 0 so a last single byte still gets processed as "n"
        $sum = unpack("%32n*", $buf . "\x0") + unpack("%32n*", $pseudo10) + $length;
        my ($sprt, $dprt, $udp_len, $udp_chksum) = unpack("nnnn", substr($buf, 0, $UDP_HEADER, ""));
        $udp_len == $length || die "Inconsistent UDP length";
        $length -= $UDP_HEADER;

        if ($udp_chksum) {
            while ($sum > 0xffff) {
                my $carry = $sum >> 16;
                $sum &= 0xffff;
                $sum += $carry;
            }
            $sum == 0xffff || die "Bad UDP chksum $sum";
        }

        ::info("SPRT=$sprt, DPRT=$dprt, LEN=$udp_len, CHK=$udp_chksum");
    }
    $line->info("Queue UDP packet (TTL %d) for %s: %s -> %s",
                $ttl, $fou->name, $from->{display}, $map->{display}) if $verbose > 1;
    $fou->write($buffer, $ttl);
}

sub process_PING {
    my $line = shift;
    my ($id, $dst, $seqno, $ttl, $data) = unpack("wa4nCa*", shift);
    # Currently we only ever use one pinger
    $id == 1 || die "Assertion: Pinger socket id $id != 1";
    # debug info is written by $pinger->write
    my $pinger = $line->child("Sender::ICMP", $id) ||
        Sender::ICMP->new($line, $id);
    $pinger->write($dst, $seqno, $data, $ttl);
}

sub process_RESPONSE_PING {
    my $line = shift;

    my ($id, $nsrc, $ttl, $buffer) = unpack("wa4Ca*", shift);
    my $md5 = substr($buffer, 0, 16, $SECRET);
    md5($buffer) eq $md5 || return;
    my ($ndst, $icmp_id, $seqno, $fou_id, $data) =
        unpack("x20a4n2wa*", $buffer);
    my $fou = $root->child("Fou::UDP", $fou_id) ||
        die "Assertion: No Fou::UDP with id '$fou_id'";

    # Build FOU IP packet
    my $ip_len = $IHL * 4;
    $buffer = pack("x${ip_len}CCx2nna*x", $ICMP_ECHO_REPLY, 0, $icmp_id, $seqno, $data);
    my $new_length = length($buffer)-1;
    substr($buffer, 0, $ip_len, "");
    my $sum = unpack("%32n*", $buffer);
    chop $buffer;
    while ($sum > 0xffff) {
        my $carry = $sum >> 16;
        $sum &= 0xffff;
        $sum += $carry;
    }
    substr($buffer, 2, 2, pack("n", 0xffff - $sum));

    # Packet ID is meaningless for atomic packets (RFC 6864)
    my $packet_id = int rand 2**16;
    my $header = pack("CCnnnCCx2a4a4",
                      $IP_VERSION << 4 | $IHL,
                      0,
                      $new_length,
                      $packet_id,
                      $DF << 13 | 0,
                      $ttl,
                      $PROTO_ICMP,
                      $nsrc,
                      $ndst,
                  );
    $sum = unpack("%32n*", $header);
    while ($sum > 0xffff) {
        my $carry = $sum >> 16;
        $sum &= 0xffff;
        $sum += $carry;
    }
    substr($header, 10, 2, pack("n", 0xffff - $sum));
    substr($buffer, 0, 0, $header);

    # $buffer = pack("x${ip_len}CCx2nna*x", $ICMP_ECHO_REPLY, 0, $icmp_id, $seqno, $data);

    $fou->info("Queue ICMP packet %s -> %s (TTL %d, Type %d, Code %d, Id %d, Seqno %s): %s",
           inet_ntoa($nsrc), inet_ntoa($ndst), $ttl,
           $ICMP_ECHO_REPLY, 0, $icmp_id, $seqno, ::display($data)) if $verbose > 1;
    $fou->write($buffer, $ttl);
}

sub process_LISTEN_REMOTE {
    my $line = shift;

    my ($id, $type, $from) = unpack("ww/a*a*", shift);
    $from = Address->parse($from, "TCP remote", from => $type, resolve => 1);
    Listener::TCP::Remote->new_suspended($line, $from, id => $id);
}

sub process_CONNECT {
    my $line = shift;

    my ($id, $type, $target) = unpack("ww/a*a*", shift);

    my $to = Address->parse($target, "TCP connect",
                            to => $type, resolve => 1);
    TCP::Forward->new($line, undef, $to, id => $id);
}

sub process_CONNECT_REMOTE {
    my $line = shift;

    my ($id, $remote_id, $address) = unpack("wwa*", shift);
    $address = Address->decode($address, "stream", 1);
    my $tcp_remote = $line->child("TCP::Remote", $remote_id) ||
        $line->bug("Unknown TCP::Remote[$remote_id]");
    my $to = $tcp_remote->{remote}->copy0_resolve($address);
    TCP::Forward->new($line, undef, $to, id => $id);
}

sub process_TCP_DATA {
    my $line = shift;

    my ($id, $pos) = unpack("w.", $_[0]);
    substr($_[0], 0, $pos, "");
    my $forward = $line->child("TCP::Forward", $id) ||
        $line->bug("Could not find TCP::Forward[$id]");
    $forward->write(shift) unless $forward->{finished};
}

sub process_TCP_EOF {
    my $line = shift;

    my ($id, $reason) = unpack("wa*", shift);
    my $forward = $line->child("TCP::Forward", $id) ||
        $line->bug("Could not find TCP::Forward[$id]");
    # We could introduce an eof_from_partner() if we ever feel the need to
    # do anything else than final_write()
    $forward->final_write("Remote $reason") unless $forward->{finished};
}

sub process_TCP_FIN {
    my $line = shift;

    my ($id, $msg) = unpack("wa*", shift);
    my $forward = $line->child("TCP::Forward", $id) ||
        $line->bug("Could not find TCP::Forward[$id]");
    $forward->finish_from_partner($msg);
}

sub process_SOCKS {
    my $line = shift;

    my ($id, $cmd, $type, $target) = unpack("www/a*a*", shift);
    if ($cmd == 1) {
        my $to = Address->parse($target, "SOCKS connect",
                                to => $type, resolve => 1);

        Socks::Connect->new($line, undef, $to, id => $id);
    } elsif ($cmd == 2) {
        my $to = Address->parse($target, "SOCKS bind",
                                          to => $type);
        # Just new would also suspend since we will pass no peer, so no connect
        Socks::Accept->new_suspended($line, $to, id => $id);
    } else {
        UDP::Forward->new($line, $id);
    }
}

sub process_SOCKS_RESULT {
    my $line = shift;

    my ($id, $seqno, $status, $type, $address) = unpack("wwww/a*a*", shift);
    my $socks_local = $line->child("TCP::Forward", $id) ||
        $line->bug("Could not find Socks::Local[$id]");
    $address = Address->parse($address, "SOCKS local", from => $type, resolve => 1);
    $socks_local->socks_result($seqno, $status, $address);
}

sub process_SOCKS_REMOTE {
    my $line = shift;

    my ($type, $from) = unpack("w/a*a*", shift);
    $from = Address->parse($from, "SOCKS local", from => $type, resolve => 1);
    Listener::Socks::Local->new_suspended($line, $from);
}

sub process_SOCKS_DATA {
    my $line = shift;

    my ($id, $ttl, $address, $pos) = unpack("wCw/a*.", $_[0]);

    my $forward = $line->child("TCP::Forward", $id) ||
        $line->bug("Could not find TCP::Forward[$id]");
    substr($_[0], 0, $pos, "");
    $address = Address->decode($address, "packet", 1);
    $forward->socks_data($address, shift, $ttl);
}

sub set_peer {
    my ($line, $name, $value) = @_;

    my $i = $setting_ids{$name};
    defined $i || croak "Unknown global variable '$name'";
    if (!defined $value) {
        defined($value = $line->{settings}{$name}) ||
            die "Assertion: Setting '$name' to undef";
    }
    $line->write($SET, pack("w", $i), $value);
}

package _Listener;
# Listen for incoming connections and start new Connections for them
# _Listener->new($parent, $address, %options)
use vars qw(@ISA);
@ISA = qw(Object);

use Errno qw(EINTR EAGAIN EWOULDBLOCK ECONNABORTED);

sub new_suspended {
    my $class = shift;
    my $parent = shift;
    my $address = shift || $TCP4_ANY;	# (Currently) assumed to be resolved

    my %args = (
        loops	=> -1,
        socket	=> undef,
        reader	=> undef,
        @_
    );
    @args{qw(local socket)} = $parent->socket_tcp($address, 1) if
        !$args{socket};
    my $listener = $class->SUPER::new($parent, %args);
    $listener->info("Listening on '%s' [%s]",
                    @{$listener->{local}}{qw(user display)}) if
                        $listener->{local}{user} =~ /:0$/ || $verbose > 1;
    return $listener;
}

sub new {
    my $class = shift;

    my $listener = $class->new_suspended(@_);
    $listener->resume_read("quiet");
    return $listener;
}

sub defer_accept {
    ConnUtils->defer_accept(shift->{socket});
}

sub _finish {
    my $listener = shift;

    delete @$listener{qw(reader socket)};
    $listener->SUPER::_finish(@_);
}

sub acceptable {
    my ($listener) = @_;

    my $peer = accept(my $accepted, $listener->{socket});
    if (!$peer) {
        return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK || ECONNABORTED;
        die "Accept failed: $^E";
    }
    $listener->finish("Maximum connections") if --$listener->{loops} == 0;
    my $packed = getsockname($accepted) ||
        die "Assertion: Could not getsockname(): $^E";
    my $local =
        Address->from_packed($packed, "tcp4")->copy2($listener->{local});
    $peer = Address->from_packed($peer, "tcp4");
    $listener->info("Accepted connection from '%s:%d' to '%s' [%s]",
                    @$peer{qw(host port)}, @$local{qw(user display)}) if $verbose;
    $listener->tcp_set($accepted);
    $listener->on_accept($accepted, $local, $peer);
}

sub on_accept {
    my $listener = shift;
    my $accepted = shift;

    my ($target) = ref($listener) =~ /^Listener::(.*)\z/ or
        die "Assertion: Could not parse class of '$listener'";
    $target->new($listener->{parent}, $accepted, $accepted, $listener, @_);
}

sub suspend_read {
    my $listener = shift;

    $listener->info("suspend_read") if $verbose > 1;
    $listener->{reader} || $listener->die("Read already suspended");
    $listener->{reader} = undef;
}

sub status {
    my ($listener, $control, $indent) = @_;

    my $name = $listener->name;

    $control->{collect} .= <<"EOF"
$indent$name
$indent  Loops: $listener->{loops}
$indent  Local:  Listen  on '$listener->{local}{user}' [$listener->{local}{display}]
EOF
        ;
}

package Listener;
# Listeners that keep the program alive
# Listener->new($parent, $address, %options)
use vars qw(@ISA);
@ISA = qw(_Listener);

sub resume_read {
    my $listener = shift;

    $listener->info("resume_read") if $verbose > 1 && !shift;
    $listener->{reader} && $listener->die("Read not suspended");
    $listener->{reader} = Events::add_read($listener->{socket}, $listener, \&_Listener::acceptable);
}

package Listener0;
# Listeners that don't keep the program alive
# Listener0->new($parent, $address, %options)
use vars qw(@ISA);
@ISA = qw(_Listener);

sub resume_read {
    my $listener = shift;

    $listener->info("resume_read") if $verbose > 1 && !shift;
    $listener->{reader} && $listener->die("Read not suspended");
    $listener->{reader} = Events::add_read0($listener->{socket}, $listener, \&_Listener::acceptable);
}

package Listener::Control;
# Wait for incoming Control connections
# Listener::Control->new($line, %options)
use vars qw(@ISA);
@ISA = qw(Listener0);

package Control;
# Communicate with a Controller
# Control->new($line, $term_in, $term_out, $listener, $local, $peer)
use vars qw(@ISA);
@ISA = qw(Stream0);

my %commands = (
    "?"		=> \&command_help,
    help	=> \&command_help,
    status	=> \&command_status,
    set		=> \&command_set,
    finish	=> \&command_finish,
    dump	=> \&command_dump,
    events	=> \&command_events,
    pid		=> \&command_pid,
    quit	=> \&command_exit,
    exit	=> \&command_exit,
);

sub new_suspended {
    my ($class, $line, $term_in, $term_out, $listener, $local, $peer) = @_;

    $line || die "Assertion: No line";

    $term_in  = \*STDIN  if !defined $term_in;
    $term_out = \*STDOUT if !defined $term_out;
    # STDIN and/or STDOUT can be $null if the program was called with closed
    # STDIN and/or STDOUT
    die "Input is NULL" if fileno($term_in)  == fileno($null);
    die "Ouput is NULL" if fileno($term_out) == fileno($null);
    $term_in ->blocking(0) if fileno($term_in ) == fileno(STDIN);
    $term_out->blocking(0) if fileno($term_out) == fileno(STDOUT);

    return $class->SUPER::new_suspended(
        $line, $term_in, $term_out,
        local	=> $local,
        peer	=> $peer,
        human	=> 1,
        collect	=> "",
        exit	=> fileno($term_in ) == fileno(STDIN));
}

sub _on_finish {
    my $control = shift;

    $control->SUPER::_on_finish(@_);
    ::cleanup_all() if $control->{exit};
}

sub error {
    my $control = shift;

    $control->error_finish(@_);
}

sub on_read {
    my ($control, $rc) = @_;

    my $len = length($control->{in});
    index($control->{in}, "\n", $len - $rc) >= 0 || return;
    while ($control->{in} =~ s/^(.*)\n//) {
        my ($command, @args) = split " ", $1 or next;
        next if $command =~ m{^#|^//|^--};
        my $fun = $commands{lc $command};
        if (!$fun) {
            $control->flush("Unknown command '$command'");
            next;
        }
        $fun->($control, $command, @args);
    }
}

sub flush {
    my $control = shift;

    $control->{collect} .= $_ for @_;
    $control->{collect} .= "\n" unless
        $control->{collect} eq "" || $control->{collect} =~ /\n\z/;
    if (!$control->{human}) {
        $control->{collect} =~ s/^\./../mg;
        $control->{collect} .= ".\n";
    }
    $control->write($control->{collect});
    $control->{collect} = "";
}

sub status {
    my ($control0, $control, $indent) = @_;

    my $name = $control0->name;
    my $self = $control0 == $control ? " (this session)" : "";
    $control->{collect} .= <<"EOF"
$indent$name$self
$indent  human=$control0->{human}
EOF
        ;
}

sub command_help {
    my ($control) = @_;

    $control->flush(<<"EOF")
quit               Close connection
exit               Close connection
dump               Dump internal datastructure
events             Dump internal Events
finish             End the program
help, ?            Show this help
pid                Show program pid
set {var=value}    Set variables
status             Show connections status
EOF
        ;
}

sub command_status {
    my ($control, $command, $name) = @_;

    my $object = $root;
    if (defined $name) {
        $object = $root->find($name);
        if (ref $object eq "") {
            if (defined $object) {
                # Error
                $control->flush($object);
            } else {
                $control->flush("Object not found");
            }
            return;
        }
        $object->status_all($control, "");
    } else {
        my $msghdr = $msghdr_error || Socket::MsgHdr->VERSION;

        my $rlwrap = $ENV{sssssh_rlwrap} || 0;
        $control->{collect} .= <<"EOF"
Local:
  Script $::Script (pid $$)
  VERSION $VERSION
  PROTOCOL $PROTOCOL
  Host $hostname
  User $me ($>)
  Socket::MsgHdr $msghdr
  rlwrap $rlwrap
  verbose=$verbose

EOF
        ;
        $object->status_all($control, "  ");
    }
    $control->flush;
}

sub command_dump {
    my ($control, $command, $name) = @_;

    my $object = $root;
    if (defined $name) {
        $object = $root->find($name);
        if (ref $object eq "") {
            if (defined $object) {
                # Error
                $control->flush($object);
            } else {
                $control->flush("Object not found");
            }
            return;
        }
    }
    $control->flush($object->dumper);
}

sub command_set {
    my $control = shift;
    shift;

    if (@_) {
        for my $arg (@_) {
            if ($arg =~ /^verbose\s*=\s*((?:0|[1-9]\d*))\s*\z/ia) {
                $verbose = int $1;
            } elsif ($arg =~ /^human\s*=\s*([01])\s*\z/ia) {
                $control->{human} = int $1;
            } else {
                $control->{collect} .= "Invalid $arg\n";
            }
        }
    } else {
        $control->{collect} .= "Missing arguments";
    }
    $control->flush;
}

sub command_exit {
    my ($control, $command) = @_;

    # Also emties $control->{in} which terminates the on_read() input loop
    $control->black_hole;
    $control->flush("OK");
    $control->final_write("Command '$command'");
}

sub command_finish {
    ::cleanup_all();
    shift->command_exit(@_);
}

sub command_events {
    shift->flush(Events::events());
}

sub command_pid {
    my ($control) = @_;

    $control->flush("$$");
}

package Listener::LineProtocol;
# Wait for incoming LineProtocol connections
# Listener::Control->new($root, %options)
use vars qw(@ISA);
@ISA = qw(Listener);

sub on_accept {
    my ($listener, $accepted) = @_;

    $listener->{parent}->server($accepted, $accepted);
}

package main;
use Scalar::Util qw(blessed);

sub object_name {
    my ($object) = @_;

    return display($object) if ref $object eq "";
    return $object->name if blessed($object) && $object->isa("Object");
    return ref $object;
}

sub _info {
    local ($!, $^E);
    my $role = ucfirst(shift);
    if (!@_) {
        my (undef, $filename, $line) = caller(1);
        @_ = ("$filename $line");
    }
    my $format = shift;
    $format =~ s/\n?\z/\n/;
    if (!@_) {
        @_ = ($format);
        $format = "%s";
    }
    my $time = Timer::realtime;
    my $itime = int($time);
    my ($sec, $min, $hour, $day, $mon, $year) = localtime($itime);
    my $gtime = timegm($sec, $min, $hour, $day, $mon, $year);
    my $offset = ($gtime - $itime) / 60;
    my $sign = "+";
    if ($offset < 0) {
        $sign = "-";
        $offset = -$offset;
    }
    my $hoffset = $offset / 60;
    my $moffset = $offset % 60;
    printf(STDERR "%04d-%02d-%02d %02d:%02d:%06.3f %s%02d%02d %s: $format",
           $year+1900, $mon+1, $day, $hour, $min, $time-$itime+$sec,
           $sign, $hoffset, $moffset,
           $role, @_);
}

sub info {
    _info($role, @_);
}

sub peer_info {
    _info($role_peer, @_);
}

sub callers {
    my (@lines, $line);
    # Skip the entry for callers itself, so by default start $i at 1
    my $i = shift;
    push @lines, $line while (undef, undef, $line) = caller(++$i);
    return join(" ", @lines);
}

sub caller_info {
    my $format = shift;
    if (@_) {
        info("$format [%s]", @_, callers());
    } else {
        my $callers = callers();
        $callers =~ s{%}{%%}g;
        info("$format [$callers]");
    }
}

my %display = (
    "\r"	=> '\r',
    "\n"	=> '\n',
    "\t"	=> '\t',
    "\0"	=> '\0',
    "\\"	=> '\\',
    '"'		=> '\"',
    );

sub display {
    my ($data) = @_;

    defined $data || return "undef";
    my $len = length $data;
    my $long = $len > 30;
    $data = substr($data, 0, 37) if $long;
    # $data =~ s{([^\x20-\x7e])}{sprintf('\x%02x', ord $1)}eg;
    my $hex = unpack("H*", $data);
    $data =~ s{([^\x20-\x7e])}{$display{$1} || "."}eg;
    $data = qq{"$data" ($hex)};
    $data .= " ..." if $long;
    $data .= $len == 1 ? " ($len byte)" : " ($len bytes)";
    return $data;
}

sub string_from_value {
    no warnings "once";
    # local $Data::Dumper::Varname  = "VAR";
    local $Data::Dumper::Trailingcomma = 0;
    local $Data::Dumper::Terse = 1;
    local $Data::Dumper::Quotekeys = 0;
    local $Data::Dumper::Sparseseen = 1;
    my $value = Dumper(shift);
    $value =~ s/\s+\z//;
    return $value;
}

# Try an immediate exit. No references should exist in the call chain
sub _cleanup_all {
    $root->finish("Cleanup all") if $root && !$root->{finished};
    $root &&= 0;
    Signals->_cleanup_all;
    my $nr_events = Events->nr_events;
    die "Assertion: Pid $$ Still has $nr_events events" if
        $nr_events && defined $root;
}

# Clean up all events and wait until the next loop in mainloop to exit
# (needed to give references in the callchain to get freed)
sub cleanup_all {
    ::caller_info("cleanup_all()") if $verbose > 1;
    $root->immediate(\&_cleanup_all) if $root;
}

sub add_control {
    my ($parent) = @_;

    my $address = Address->parse("127.0.0.1:0", "Control", from => "TCP4", resolve => 1);
    Listener::Control->new($parent, $address);
}

my @ARGV_OLD = @ARGV;

sub rlwrap {
    if (!$ENV{sssssh_rlwrap}) {
        die "Assertion: Already queued events" if Events->nr_events;
        local $ENV{sssssh_rlwrap} = "1";
        no warnings "exec";
        { exec("rlwrap", "-w", 100, "-S", "$Script>", "$Bin/$Script", @ARGV_OLD) }
        ;
        $! == ENOENT || die "Could not exec 'rlwrap': $^E";
        ::info("Could not exec 'rlwrap': $^E") if $verbose > 1;
    }
}

my %connection_types = (
    tcp_local		=> "L",
    tcp_remote		=> "R",
    udp_local		=> "l",
    udp_remote		=> "r",
    fou_local		=> "F",
    fou_remote		=> "f",
    socks_local		=> "D",
    socks_remote	=> "d",
    control_local	=> "C",
    control_remote	=> "c",
);
my %connections;

GetOptions("server:s"		=> \my $server,
           "client=s"		=> \my $client,
           "N|loops=o"		=> \$loops,
           "T=o"		=> \$global_timeout,
           "n+"			=> \my $no_control,
           "server_lib=s"	=> \my @server_lib,
           "ssh=s"		=> \$ssh,
           "resolv_file=s"	=> \$resolv_file,
           "server_resolv_file=s"	=> \my $server_resolv_file,
           # Add server and client variants too.
           # server: load at server side
           # client: load at client side and send content to server
           "hosts_file=s"	=> \$hosts_file,
           "M|master"		=> \my $ssh_master,
           "perl=s"		=> \my $remote_perl,
           "server_verbose+"	=> \my $server_verbose,
           "client_verbose+"	=> \my $client_verbose,
           "v|verbose+"		=> \$verbose,
           "keepalive=f"	=> \$keepalive,
           "timeout=f"		=> \$timeout,
           "connect_timeout=f"	=> \$timeout_connect,
           "stuff!"		=> \my $stuff,
           (map {; "$connection_types{$_}|$_=s" => \@{$connections{$_}}} keys %connection_types),
           "udp_max=o"		=> \$udp_max,
           "ping_max=o"		=> \$ping_max,
           "version!"		=> \my $version,
           "U|unsafe!"		=> \my $unsafe,
           "h|help!"		=> \my $help) ||
    die "Could not parse your command line. Try $Script -h\n";

if ($version) {
    print<<"EOF";
sssssh $VERSION (Net::Sssssh) $VERSION
EOF
    exit 0;
}

if ($help) {
    require Config;
    $ENV{PATH} .= ":" unless $ENV{PATH} eq "";
    $ENV{PATH} = "$ENV{PATH}$Config::Config{'installscript'}";
    exec("perldoc", "-F", $unsafe ? "-U" : (), $0) || exit 1;
    # make parser happy
    %Config::Config = ();
}

die "timeout $timeout must be positive\n" if $timeout <= 0;
$settings_global{TIMEOUT} = $timeout+0;
die "timeout $timeout_connect must be positive\n" if $timeout_connect <= 0;
$settings_global{TIMEOUT_CONNECT} = $timeout_connect+0;
die "keepalive $keepalive must be positive\n" if $keepalive <= 0;
$settings_global{KEEPALIVE} = $keepalive+0;
die "udp_max must be positive" if $udp_max < 1;
$settings_global{UDP_MAX} = int($udp_max);
die "ping_max must be positive" if $ping_max < 1;
$settings_global{PING_MAX} = int($ping_max);
die "global timeout must not be negative" if
    defined $global_timeout && $global_timeout < 0;

$no_control ||= 0;
$verbose ||= 0;
$client_verbose = $verbose if !defined $client_verbose;
$server_verbose = $verbose if !defined $server_verbose;
# control_local is special. It is always allowed (as both server and client)
my $control_local = delete $connections{control_local};

$role = "server" if defined $server;
$role_peer = $role eq "server" ? "client" : "server";

if ($role eq "server") {
    # From here on we are the server
    $verbose = $server_verbose;

    die "Cannot be both server and client\n" if defined $client;
    die "Cannot have stuff in server mode\n" if $stuff;

    for my $type (sort keys %connections) {
        die "Cannot set forwards (like --$type) in server mode\n" if
            @{$connections{$type}};
    }
    if (defined $server && $server ne "-") {
        # Manual start
        if ($no_control) {
            open(STDIN, "<&", $null) || die "Could not dup to STDIN: $^E";
            $root = Root->new();
        } else {
            rlwrap();
            $root = Root->new();
            Control->new($root);
            $| = 1;
        }
        my $address = Address->parse($server, "Server", from => "TCP4", resolve => 1);

        $loops = -1 if !defined $loops;
        Listener::LineProtocol->new($root, $address, loops => $loops) if $loops;
    } else {
        $root = Root->new();
        # Make sure that if we fork/exec things they won't get access to
        # our communication channel
        open(my $socket_in,  "<&STDIN")  || die "Could not dup STDIN: $^E";
        open(STDIN, "<&", $null) || die "Could not dup to STDIN: $^E";
        open(my $socket_out, ">&STDOUT") || die "Could not dup STDOUT: $^E";
        open(STDIN, ">&", $null) || die "Could not dup to STDOUT: $^E";
        $socket_in->blocking(0);
        $socket_out->blocking(0);
        $root->server($socket_in, $socket_out);
    }
    $root->signal_add0("USR1", \&add_control) if defined $server && $no_control < 2;
} else {
    # From here on we are the client
    $verbose = $client_verbose;

    if ($no_control) {
        open(STDIN, "<&", $null) || die "Could not dup to STDIN: $^E";
        $root = Root->new();
    } else {
        rlwrap();
        $root = Root->new();
        Control->new($root);
        $| = 1;
    }
    $root->signal_add0("USR1", \&add_control) if $no_control < 2;
    if (defined $client) {
        die "Cannot have arguments in client mode" if @ARGV;
        die "Cannot have stuff in client mode" if $stuff;

        my $to = Address->parse($client, "Client", to => "tcp4", resolve => 1);
        my $socket = $root->socket_tcp($to);
        $root->client($socket, $socket, \%connections, 1);
    } else {
        @ARGV || die "Missing remote host argument, Try $Script -h\n";
        $stuff = 1 if !defined $stuff;
        if ($stuff) {
            @ARGV == 1 || die "Spurious arguments\n";
        }

        pipe(my $rd0, my $wr0) || die "Could not pipe: $^E";
        pipe(my $rd1, my $wr1) || die "Could not pipe: $^E";
        defined(my $pid = fork()) || die "could not fork: $^E";

        if (!$pid) {
            # Child
            # This side does the ssh connection so that ^C goes to ssh
            eval {
                close $wr0;
                close $rd1;
                open(STDIN,  "<&", $rd0) || die "Could not dup STDIN: $^E";
                close $rd0;
                open(STDOUT, ">&", $wr1) || die "Could not dup STDOUT: $^E";
                close $wr1;

                $SIG{CHLD} = "DEFAULT";
                if ($stuff) {
                    # delete @ENV{qw(LANGUAGE LC_ALL LANG)};
                    my $remote_host = shift;
                    if ($remote_host eq "") {
                        $remote_perl = $^X if !defined $remote_perl;
                        exec($remote_perl) ||
                            die "Could not exec $remote_perl: $^E";
                    } else {
                        $remote_perl = "/usr/bin/perl" if !defined $remote_perl;
                        exec($ssh, $ssh_master ? "-M" : (), "-e", "none", $remote_host, $remote_perl) ||
                            die "Could not exec $ssh: $^E";
                    }
                } else {
                    push @ARGV, "$Bin/$Script" if @ARGV == 1;
                    exec($ssh, $ssh_master ? "-M" : (), "-e", "none", "-T", @ARGV) ||
                        die "Could not exec $ssh: $^E";
                }
            };
            print STDERR $@ || "No error";
            _exit(1);
        }

        # Parent
        close $rd0;
        close $wr1;
        $wr0->autoflush(1);

        if ($stuff) {
            my $self = "$Bin/$Script";
            # Maybe we could get the same info through DATA (if we didn't close)
            open(my $fh, "<", $self) || die "Could not open $self: $^E";
            my $content = qq(#line 1 "$Bin/$Script"\n);
            $content .= do { local $/; <$fh> };
            $content =~ s/\n__END__\n.*/\n/s || die "Could not find __END__";
            # Remove full line comments, but not #line statements.
            # Leave the \n so line numbers in error messages keep working
            $content =~ s/^[^\S\n]*#(?![^\S\n]*line\s).*//mg;
            # Drop leading spaces. Saves about 20%
            # (less of course if ssh does compression, which it does by default)
            $content =~ s/^[^\S\n]+//mg;

            # Change a few variables in the server code
            my %replace =
                (verbose	=> $server_verbose,
                 role		=> "server",
                 # This is needed because $SET sets the remote timeout for $line
                 # but Fou::UDP is not a child of $line and uses the
                 # global settings
                 timeout	=> $timeout,
                 ping_max	=> $ping_max,
                 global_timeout	=> $global_timeout,
             );
            if (defined $server_resolv_file) {
                $replace{resolv_file} = $server_resolv_file;
                $server_resolv_file = undef;
            }
            while (my ($name, $value) = each %replace) {
                $value = string_from_value($value);
                # info("Value $name=<$value>") if $verbose;
                $content =~ s{^([^\S\n]*(?:my|our))\s*\$\Q$name\E\s*=[^;\n]*;[^\S\n]*\n}{$1 \$$name=$value;\n}m || die "Could not set $name";
            }

            print($wr0 $PRE_STUFFER) || die "Write error:$^E";
            for my $server_lib (map split(/:/), @server_lib) {
                print($wr0 qq(use lib "$server_lib";\n)) || die "Write error:$^E";
            }
            # print($wr0 qq(\$Script="\$Script"\n)) || die "Write error:$^E";
            print($wr0 $content) || die "Write error:$^E";
            print($wr0 $POST_STUFFER) || die "Write error:$^E";
            my $line = "";
            while (length($line) < length($STUFFED)) {
                alarm(60);
                my $rc = sysread($rd1, $line, length($STUFFED)-length $line, length $line);
                if (!defined $rc) {
                    next if $! == EINTR;
                    die "Read error: $^E";
                }
                die "Unexpected EOF" if $rc == 0;
            }
            alarm(0);
            $line eq $STUFFED || die "Bad server confirm $line";
        }
        $wr0->blocking(0);
        $rd1->blocking(0);
        $root->client($rd1, $wr0, \%connections, 0);
    }
}
die "Option server_resolv_file invalid in this mode" if defined $server_resolv_file;

$root->timeout($global_timeout) if defined $global_timeout;

eval {
    Resolver->new($root);
    for my $control (@$control_local) {
        my $address = Address->parse($control, "Control", from => "TCP4", resolve => 1);
        # Imediately active. Is not related to any LineProtocol ready
        Listener::Control->new($root, $address);
    }

    Events->mainloop();
};
my $err = $@ || "";
eval { _cleanup_all() };
# print STDERR "--------------------\n";
$err .= $@;
die "\u$role DIED: $err" if $err;
# die "Assertion: \u$role fell off the mainloop";

__END__
Implementation notes:
