#!/usr/bin/perl -w
my $null;
BEGIN {
    # This must come before any modules, even use strict/warnings
    # (to avoid these modules keeping open early file handles for __DATA__)
    $^F == 2 || die "Assertion: Invalid CLO_EXEC range";
    open($null, "+<", "/dev/null") || die "Could not open '/dev/null': $^E";
    die "Assertion: Should at least have the source code open at fileno 0" if
        fileno($null) == 0;
    if (fileno($null) == 1) {
        # Perl will automatically subsume fd 1 into STDOUT
        open($null = undef, "+>&STDOUT") || die "Could not dup STDOUT: $^E";
    }
    if (fileno($null) == 2) {
        # Perl will automatically subsume fd 2 into STDERR
        open($null = undef, "+>&STDERR") || die "Could not dup STDERR: $^E";
    }
    fileno($null) > 2 || die "Assertion: Invalid NULL handle";
    # So now we are absolutely sure $null has CLO_EXEC
}
# Now take over STDIN in case we had no STDIN and perl opened it as source code
# We should have a DATA filehandle because this file has an __END__ section
# (but for unclear reasons it does not when stuffing --Ton)
if (defined fileno(DATA)) {
    fileno(DATA) != fileno(STDIN) ||
        open(STDIN, "<&", $null) || die "Could not dup to STDIN: $^E";
    close(DATA);
}

use strict;
use warnings;

# modprobe fou
# ip link add name fou1 type ipip remote 127.0.0.1 local 127.0.0.1 ttl 225 encap fou encap-sport auto encap-dport 1236
# ip link set fou1 up
# ip addr add 10.253.4.1/24 dev fou1
# # If you add "dev fou1" to the add port it seems to stop working
# # If you remove the "local 127.0.0.1" it keeps working
# ip fou add port 1237 ipproto 4 local 127.0.0.1

# Redirect packets to port 1234 into the fou1 tunnel:
# iptables -t mangle -N FWMARK2
# # iptables -t mangle -A FWMARK2 -j LOG --log-prefix 'iptables-mark2: ' --log-level info
# iptables -t mangle -A FWMARK2 -j MARK --set-mark 17
# iptables -t mangle -A OUTPUT -p udp --dport 1234 -j FWMARK2
# # Also catch ping requests
# # iptables -t mangle -A OUTPUT -p icmp --icmp-type 8 -j FWMARK2
# ip rule add fwmark 17 lookup 101
# ip route add default via 10.253.4.1 table 101

# Avoid other stuff sneaking into the tunnel
# (not sure how, but when using deluge (torrent): external traffic not on the marked port gets into the tunnel. Deluge for some reason sometimes uses the tunnel IP as its source address)
# ---- Targeted (124 is uid of deluge -----
# iptables -A OUTPUT -o ppp0 -m owner --uid-owner 124 -j DROP
# iptables -A OUTPUT -s 10.253.0.8 -m owner --uid-owner 124 -j ACCEPT
# iptables -A OUTPUT -s 10.253.1.8 -m owner --uid-owner 124 -j ACCEPT
# iptables -A OUTPUT -s 127.0.0.0/8 -m owner --uid-owner 124 -j ACCEPT
# iptables -A OUTPUT -m owner --uid-owner 124 -j DROP
# OSPF (bird)
# iptables -A OUTPUT -p 89 -s 10.253.4.1 -j DROP
# SSDP. Who is doing this ?
# iptables -A OUTPUT -p udp -s 10.253.4.1 -d 239.255.255.250 -j DROP
# ---- Brute force -----
# iptables -t mangle -A INPUT -d 10.253.4.1 -j DROP
# iptables -t mangle -A OUTPUT -s 10.253.4.1 -j DROP

# sysctl -w net.ipv4.conf.all.rp_filter=0
# sysctl -w net.ipv4.conf.fou1.rp_filter=0

# ip fou del port 1237 ipproto 4 local 127.0.0.1
# ip link del name fou1

# Native ping forwarding needs permission to open a IPPROTO_ICMP sockets on the
# forwarded host.
# E.g. On linux:
#   Query current permissions:
#      sysctl net.ipv4.ping_group_range
#   Allow group 1014:
#      sysctl net.ipv4.ping_group_range='1014 1014'
# If this permission is not available (or not supported on the OS) the program
# falls back to running an external ping program

our $VERSION = "1.000";

use FindBin qw($Bin $Script);
use Getopt::Long 2.24 qw(:config bundling require_order);
use Carp;
use Sys::Hostname;
use Errno qw(EINTR ENOENT ETIMEDOUT);
use Time::Local qw(timegm);
use Socket qw(inet_aton);
use POSIX qw(_exit);

use Data::Dumper;
$Data::Dumper::Indent   = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Useqq	= 1;

($Bin, $Script) = __FILE__ =~ m{^(.*)/(.+)\z} or
    die "Could not parse ", __FILE__ if $Script eq "-" && __FILE__ ne "-";

$SIG{PIPE} = "IGNORE";

delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};
$ENV{PATH}="/usr/bin:/usr/sbin:/bin:/sbin";

my $MULTICAST_BEGIN = inet_aton("224.0.0.0") || die "Assertion: Bad address";
# multicast range *excludes* this END address
my $MULTICAST_END   = inet_aton("240.0.0.0") || die "Assertion: Bad address";

my $IP_VERSION = 4;
defined(my $PROTO_ICMP = getprotobyname("icmp")) || die "Unknown protocol ICMP";
defined(my $PROTO_UDP  = getprotobyname("udp"))  || die "Unknown protocol UDP";
defined(my $PROTO_TCP  = getprotobyname("tcp"))  || die "Unknown protocol TCP";
my $IHL = 5;
my $ICMP_HEADER = 8;
my $UDP_HEADER  = 8;
my $DF = 2;
my $TTL = 64;
my $ICMP_ECHO_REQUEST = 8;
my $ICMP_ECHO_REPLY = 0;

# We set the PATH environment variable, so this is safe enough
my $ssh = "ssh";
my $verbose = undef;
my $global_timeout = undef;
my $timeout = 120;
my $timeout_connect = 10;
my $keepalive = 300;
my $udp_max = 10;
my $ping_max = 10;
my $default_bind  = "127.0.0.1";
my $exit = 0;

# How long a server UDP socket lingers without traffic
# How long an errored TCP connection tries to push lingering output
my $SOCKS_TIMEOUT = 120;
# How much we can typically fit into our communication channel
my $LINE_BLOCK_SIZE = int(2**14);
my $BLOCK_SIZE = int(2**16);
my $UDP_SIZE = int(2**16);
my $LISTEN_BACKLOG = 128;
my $TCP_KEEPALIVE_PROBES = 8;

my @PING =
    $^O eq "solaris" ? (["ping", "-s"], ["64", "1"]) :
    (["ping", "-c", "1"], []);

my %settings_global = (
    EPOCH	=> undef,
    MSGHDR	=> undef,
    TIMEOUT	=> undef,
    TIMEOUT_CONNECT	=> undef,
    KEEPALIVE	=> undef,
    UDP_MAX	=> undef,
    PING_MAX	=> undef,
    # ACK_LIMIT should be greater than KEEPALIVE/ACK packet
    # (Code will increase it if not, but you will still send way too many ACKs)
    ACK_LIMIT	=> int(1e6),
    # For debugging:
    # ACK_LIMIT	=> 0,
);
my @setting_ids = sort keys %settings_global;
my %setting_ids;
$setting_ids{$setting_ids[$_]} = $_ for 0..$#setting_ids;

my $SECRET = pack("NNNN", $$ ^ rand 2**32, $^T ^ rand 2**32, rand 2**32, rand 2**32);

my $STUFFED = "GoNow";

my $PROTOCOL	= 1;

# Lineprotocol commands
my $START		= "1";
my $SET			= "=";	# sets a server variable
my $KEEP		= "K";	# Keepalive/ACK packet

# Implicit about LineProtocol
my $CONNECT		= "C";	# Create a server side connecting TCP::Forward
my $CONNECT_REMOTE	= "c";	# Create a client side connecting TCP::Forward
my $LISTEN_REMOTE	= "L";	# Create a server side Listener::TCP::Remote
my $SOCKS		= "S",	# Create a remote Socks::Connect/Socks::Accept
my $SOCKS_REMOTE	= "d",	# Create a server side Listener::Socks::Local
my $FOU_REMOTE		= "r";	# Create a server side Receiver::Fou (and Fou::UDP if needed)
my $PING		= "P";	# Create a remote Sender::ICMP (if not exists)
my $RESPONSE_PING	= "p";	# Use a remote Fou::UDP to send ICMP ECHO REPLY
my $RESPONSE_UDP	= "u";	# DATA to remote (initiator)

# Implicit about TCP::Forward
my $TCP_DATA		= "T";	# DATA to remote
my $TCP_EOF		= "E";	# EOF  to remote
my $TCP_FIN		= "F";	# FINISH to remote (will never send more about this id)

# Implicit about Sender::UDP
# (UDP is handled assymetric, there is the idea of an initiator and a responder)
my $UDP_DATA		= "U";	# DATA to remote (UDP responder), create Sender::UDP if needed

# Implcit about Socks::Local (about to become TCP::Forward)
my $SOCKS_RESULT	= "s",

my $ETIMEDOUT = $! = ETIMEDOUT;

my $msghdr_error;
BEGIN {
    # Can't use "require" later on since (old) Socket::MsgHdr has INIT blocks
    $msghdr_error = eval(sprintf(qq(#line %d "%s"\nuse Socket::MsgHdr qw(pack_cmsghdr unpack_cmsghdr sendmsg recvmsg); 1), __LINE__, __FILE__)) ? "" :
        $@ || "Unknown error loading Socket::MsgHdr\n";
    $msghdr_error =~ s/^BEGIN failed.*\n\z//m;
    $msghdr_error =~ s/\s+\z//;

}
END {
    # Carp.pm can stash objects in @DB::args causing them not to get freed
    @DB::args = ();
}

my $FREE_BSD = $^O eq "freebsd";
# IPPROTO_IP exists in Socket, but not in really old ones
my $IPPROTO_IP = 0;
my ($IP_RECVTTL, $IP_TTL, $IP_PKTINFO, $ICMP_FILTER);
if (!$msghdr_error) {
    if ($FREE_BSD) {
        # FreeBSD uses IP_RECVDSTADDR
        $IP_PKTINFO	=  7;
        $IP_RECVTTL	= 65;
        $IP_TTL		=  4;
    } elsif ($^O eq "linux") {
        $IP_PKTINFO	=  8;
        $IP_RECVTTL	= 12;
        $IP_TTL		=  2;
        $ICMP_FILTER	=  1;
    } else {
        $msghdr_error = "Socket::MsgHdr constants for OS $^O not implemented (yet)\n";
    }
}

my ($TCP_KEEPIDLE, $TCP_KEEPINTVL, $TCP_KEEPCNT, $SOL_RAW, $SO_ACCEPTFILTER);
if ($FREE_BSD) {
    # Needs at least FreeBSD 9
    $TCP_KEEPIDLE	=  256;
    $TCP_KEEPINTVL	=  512;
    $TCP_KEEPCNT	= 1024;
    $SO_ACCEPTFILTER	= 4096;
} elsif ($^O eq "linux") {
    $TCP_KEEPIDLE	=  4;
    $TCP_KEEPINTVL	=  5;
    $TCP_KEEPCNT	=  6;
    $SOL_RAW		=255;
}
# FreeBSD has SO_ACCEPTFILTER instead with different call usage
my $TCP_DEFER_ACCEPT = eval { Socket::TCP_DEFER_ACCEPT() };

my $msghdr = $msghdr_error ? undef : Socket::MsgHdr->new();
my $loops;

my $role = "client";
my $role_peer;

# Determine some system settings
my $hostname = hostname();
my $me;
if ($^O eq "MSWin32") {
    require Win32;
    $me = Win32::LoginName();
} else {
    if (my $user = $ENV{LOGNAME}) {
        if (defined(my $uid = getpwnam($user))) {
            $me = $user if $> == $uid;
        }
    }
    $me ||= getpwuid $>;
}
die "Can't determine who I am" if !$me;

die "Bad file '", __FILE__, "'" if __FILE__ =~ /["\n\0]/;
# Client stuffer
my $POST_STUFFER = sprintf(qq(#line %d "%s"\n%s),
                           __LINE__, __FILE__, '
BEGIN {
    eval {
        open($SAVED_STDIN, "<&", \*STDIN);
        open(STDIN, "<", "/dev/null") || die "NULL: $!";
        1;
    } or do {
        print STDERR $@ || "Unknown error\n";
        exit 255;
    };
}
');
my $PRE_STUFFER = sprintf(qq(#line %d "%s"\n%s),
                           __LINE__, __FILE__, '
BEGIN { $^W = 1 }

my $SAVED_STDIN;
open(STDIN, "<&", $SAVED_STDIN) || die "Could not dup STDIN: $^E";
close($SAVED_STDIN) || die "Could not close SAVED_STDIN: $^E";
$| = 1;
print "' . $STUFFED . '";
');

my $nr_events = 0;
{
    package Events;
    # A small event core
    use Carp;
    use Errno qw(EINTR);
    use Scalar::Util qw(weaken);

    my $read_mask  = "";
    my $write_mask = "";
    my $error_mask = "";
    my @refs = qw(read write error);
    my %refs = (
        read	=> \my %read_refs,
        write	=> \my %write_refs,
        error	=> \my %error_refs,
    );

    # All placeholder subs are the same sub
    use constant {
        NOP	=> sub {},
        OBJ	=> 0,
        CODE	=> 1,
    };

    sub die_no_handle {
        ::caller_info("DIE: Assertion: Not a filehandle") if $verbose > 1;
        die sprintf("Assertion: Not a filehandle [%s]\n", ::callers());
    }

    sub Events::Read::DESTROY {
        defined(my $fd = ${shift()}) || die "No filedescriptor";
        ::caller_info("delete_read(%d, %s)", $fd,
                      ::object_name($read_refs{$fd}->[OBJ])) if $verbose > 1;
        # This strange assign after delete is to update the reference the for in
        # sub mainloop may still have in such a way that OBJ keeps existing
        # (otherwise a confess during the callback will access freed memory)
        # We could set either the object or the callback
        # But the object is already weak and the callback may be a closure
        delete($read_refs{$fd})->[CODE] = NOP;
        if (%read_refs) {
            vec($read_mask, $fd, 1) = 0;
            $read_mask =~ s/\x00+\z//;
        } else {
            $read_mask = "";
        }
        --$nr_events;
    }

    sub Events::Read0::DESTROY {
        defined(my $fd = ${shift()}) || die "No filedescriptor";
        ::caller_info("delete_read0(%d, %s)", $fd,
                      ::object_name($read_refs{$fd}->[OBJ])) if $verbose > 1;
        # This strange assign after delete is to update the reference the for in
        # sub mainloop may still have in such a way that OBJ keeps existing
        # (otherwise a confess during the callback will access freed memory)
        # We could set either the object or the callback
        # But the object is already weak and the callback may be a closure
        delete($read_refs{$fd})->[CODE] = NOP;
        if (%read_refs) {
            vec($read_mask, $fd, 1) = 0;
            $read_mask =~ s/\x00+\z//;
        } else {
            $read_mask = "";
        }
    }

    sub Events::Write::DESTROY {
        defined(my $fd = ${shift()}) || die "No filedescriptor";
        ::caller_info("delete_write(%d, %s)", $fd,
                      ::object_name($write_refs{$fd}->[OBJ])) if $verbose > 1;
        # This strange assign after delete is to update the reference the for in
        # sub mainloop may still have in such a way that OBJ keeps existing
        # (otherwise a confess during the callback will access freed memory)
        # We could set either the object or the callback
        # But the object is already weak and the callback may be a closure
        delete($write_refs{$fd})->[OBJ] = NOP;
        if (%write_refs) {
            vec($write_mask, $fd, 1) = 0;
            $write_mask =~ s/\x00+\z//;
        } else {
            $write_mask = "";
        }
        --$nr_events;
    }

    sub Events::Write0::DESTROY {
        defined(my $fd = ${shift()}) || die "No filedescriptor";
        ::caller_info("delete_write0(%d, %s)", $fd,
                      ::object_name($write_refs{$fd}->[OBJ])) if $verbose > 1;
        # This strange assign after delete is to update the reference the for in
        # sub mainloop may still have in such a way that OBJ keeps existing
        # (otherwise a confess during the callback will access freed memory)
        # We could set either the object or the callback
        # But the object is already weak and the callback may be a closure
        delete($write_refs{$fd})->[CODE] = NOP;
        if (%write_refs) {
            vec($write_mask, $fd, 1) = 0;
            $write_mask =~ s/\x00+\z//;
        } else {
            $write_mask = "";
        }
    }

    sub Events::Error::DESTROY {
        defined(my $fd = ${shift()}) || die "No filedescriptor";
        ::caller_info("delete_error(%d, %s)", $fd,
                      ::object_name($error_refs{$fd}->[OBJ])) if $verbose > 1;
        # This strange assign after delete is to update the reference the for in
        # sub mainloop may still have in such a way that OBJ keeps existing
        # (otherwise a confess during the callback will access freed memory)
        # We could set either the object or the callback
        # But the object is already weak and the callback may be a closure
        delete($error_refs{$fd})->[CODE] = NOP;
        if (%error_refs) {
            vec($error_mask, $fd, 1) = 0;
            $error_mask =~ s/\x00+\z//;
        } else {
            $error_mask = "";
        }
        --$nr_events;
    }

    sub Events::Error0::DESTROY {
        defined(my $fd = ${shift()}) || die "No filedescriptor";
        ::caller_info("delete_error0(%d, %s)", $fd,
                      ::object_name($error_refs{$fd}->[OBJ])) if $verbose > 1;
        # This strange assign after delete is to update the reference the for in
        # sub mainloop may still have in such a way that OBJ keeps existing
        # (otherwise a confess during the callback will access freed memory)
        # We could set either the object or the callback
        # But the object is already weak and the callback may be a closure
        delete($error_refs{$fd})->[OBJ] = NOP;
        if (%error_refs) {
            vec($error_mask, $fd, 1) = 0;
            $error_mask =~ s/\x00+\z//;
        } else {
            $error_mask = "";
        }
    }

    sub add_read {
        defined(my $fd = fileno(shift)) || die_no_handle();
        ::caller_info("add_read(%d, %s)", $fd, ::object_name($_[0])) if $verbose > 1;
        croak "Descriptor $fd already selected for read" if $read_refs{$fd};
        vec($read_mask, $fd, 1) = 1;
        weaken(($read_refs{$fd} = [shift, shift])->[OBJ]);
        ++$nr_events;
        return bless \$fd, "Events::Read";
    }

    sub add_read0 {
        defined(my $fd = fileno(shift)) || die_no_handle();
        ::caller_info("add_read0(%d, %s)", $fd, ::object_name($_[0])) if $verbose > 1;
        croak "Descriptor $fd already selected for read" if $read_refs{$fd};
        vec($read_mask, $fd, 1) = 1;
        weaken(($read_refs{$fd} = [shift, shift])->[OBJ]);
        return bless \$fd, "Events::Read0";
    }

    sub add_write {
        defined(my $fd = fileno(shift)) || die_no_handle();
        ::caller_info("add_write(%d, %s)", $fd, ::object_name($_[0])) if $verbose > 1;
        croak "Descriptor $fd already selected for write" if $write_refs{$fd};
        vec($write_mask, $fd, 1) = 1;
        weaken(($write_refs{$fd} = [shift, shift])->[OBJ]);
        ++$nr_events;
        return bless \$fd, "Events::Write";
    }

    sub add_write0 {
        defined(my $fd = fileno(shift)) || die_no_handle();
        ::caller_info("add_write0(%d, %s)", $fd, ::object_name($_[0])) if $verbose > 1;
        croak "Descriptor $fd already selected for write" if $write_refs{$fd};
        vec($write_mask, $fd, 1) = 1;
        weaken(($write_refs{$fd} = [shift, shift])->[OBJ]);
        return bless \$fd, "Events::Write0";
    }

    sub add_error {
        defined(my $fd = fileno(shift)) || die_no_handle();
        ::caller_info("add_error(%d, %s)", $fd, ::object_name($_[0])) if $verbose > 1;
        croak "Descriptor $fd already selected for error" if $error_refs{$fd};
        vec($error_mask, $fd, 1) = 1;
        weaken(($error_refs{$fd} = [shift, shift])->[OBJ]);
        ++$nr_events;
        return bless \$fd, "Events::Error";
    }

    sub add_error0 {
        defined(my $fd = fileno(shift)) || die_no_handle();
        ::caller_info("add_error0(%d, %s)", $fd, ::object_name($_[0])) if $verbose > 1;
        croak "Descriptor $fd already selected for error" if $error_refs{$fd};
        vec($error_mask, $fd, 1) = 1;
        weaken(($error_refs{$fd} = [shift, shift])->[OBJ]);
        return bless \$fd, "Events::Error0";
    }

    sub __unloop {
        no warnings "exiting";
        last MAINLOOP;
    }

    my $unloop;
    sub _unloop {
        return if $unloop;
        $unloop = bless {};
        $unloop->{timer} = Timer::immediate(
            $unloop,
            sub {
                $unloop = undef;
                no warnings "exiting";
                last MAINLOOP;
            });
    }

    sub events_fd {
        my $events = shift;
        for my $name (@refs) {
            my $refs = $refs{$name};
            push @$events, map {
                $refs->{$_} ?
                    sprintf("%-5s%s %2d -> %s",
                            ucfirst $name,
                            ref $refs->{$_} =~ /0\z/ ? " (dead)" : "",
                            $_,
                            ::object_name($refs->{$_}[OBJ])) : ()
                } sort { $a <=> $b } keys %$refs;
        }
    }

    sub _events {
        my @events;
        events_fd(\@events);
        Timer::events_immediate(\@events);
        Timer::events_timer(\@events);
        return \@events;
    }
    sub events {
        return join("", map "$_\n", @{_events()});
    }

    sub mainloop {
        # ::info("WARNING (can safely be ignored): $msghdr_error") if
        #    $msghdr_error && $verbose;
        ::info("Entering mainloop $$ (nr_events=$nr_events)") if $verbose;
        _mainloop();
        ::info("Exiting mainloop $$ (nr_events=$nr_events)") if $verbose;
    }

    sub _mainloop {
        my ($r, $w, $e);
        # my $name;
      MAINLOOP:
        while ($nr_events) {
            if ((select($r = $read_mask,
                        $w = $write_mask,
                        $e = $error_mask,
                        Timer::timers_collect()) || next) > 0) {
                # The copy to @tmp is because the stack doesn't keep values
                # alive, so any deletes on xxx_refs during the loop can make
                # the value go poof. The copy temporarily increases the
                # refcount so the value doesn't go away. That is also why the
                # delete_xxx functions modify the value before delete
                # $name = $_->[CODE], $_->[OBJ]->$name for my @tmp=(
                $_->[CODE]->($_->[OBJ] || next) for my @tmp=(
                    @read_refs{ grep vec($r, $_, 1), keys %read_refs},
                    @write_refs{grep vec($w, $_, 1), keys %write_refs},
                    @error_refs{grep vec($e, $_, 1), keys %error_refs});
            } elsif ($! == EINTR) {
                redo;
            } else {
                die "Select failed: $^E";
            }
        } continue {
            Timer::timers_run();
        }
    }

    #no warnings "once";
    #*IO::Handle::add_read	= \&add_read;
    #*IO::Handle::add_read0	= \&add_read0;
    #*IO::Handle::add_write	= \&add_write;
    #*IO::Handle::add_write0	= \&add_write0;
    #*IO::Handle::add_error	= \&add_error;
    #*IO::Handle::add_error0	= \&add_error0;
}

package Signals;
use Scalar::Util qw(weaken);

sub DESTROY {
    my ($signals) = @_;

    # This makes sure Signal::DESTROY uses the efficient code path
    $_ &&= 0 for values %{$signals->{count}};
    @{$signals->{signalled}} = ();
    %{$signals->{handlers}} = ();

    # The user can be holding on to some Signal objects so their DESTROY
    # doesn't get called and so some $SIG entries can survive. Kill them.
    for my $sig_name (sort keys %{$signals->{old}}) {
        ::caller_info("Restore signal $sig_name") if $verbose > 1;
        $SIG{$sig_name} = $signals->{old}{$sig_name};
    }
    %{$signals->{old}} = ();
}

{
    my $signals;

    sub init {
        my ($class) = @_;

        return $signals if $signals;

        my %signals = (
            signalled 	=> [],
            handlers	=> {},
            count	=> {},
            old		=> {},
        );
        pipe($signals{rd}, $signals{wr}) ||
            die "Could not create signal pipe: $^E";
        $signals{rd}->blocking(0);
        # Leave the write side blocking
        $signals{reader} = Events::add_read0($signals{rd}, \%signals, \&dealer);
        return $signals = bless \%signals, $class;
    }

    sub _cleanup_all {
        weaken(my $probe = $signals);
        $signals = undef;
        die "Assertion: Somebody is holding a reference to signals" if $probe;
    }

    sub signal_handler {
        my ($sig_name) = @_;

        $signals || die "Assertion: signal $sig_name without Signals object";
        $signals->{count}{$sig_name} ||
            die "Assertion: signal $sig_name without handlers";
        my $from = @{$signals->{signalled}} or
            syswrite($signals->{wr}, "x") ||
            die "Could not write to signal pipe: $^E";
        push @{$signals->{signalled}}, @{$signals->{handlers}{$sig_name}};
        for my $i ($from .. $#{$signals->{signalled}}) {
            weaken($signals->{signalled}[$i]);
        }
    }
}

package Signal;
use Errno qw(EINTR EAGAIN EWOULDBLOCK);
use Scalar::Util qw(weaken);

# Signal indices
use constant {
    SIGNALS	=> 0,
    NAME	=> 1,
    OBJ		=> 2,
    CODE	=> 3,
};

# Hard to classify this one. It belongs to both Signals and Signal really
sub Signals::dealer {
    my ($signals) = @_;

    while (@{$signals->{signalled}}) {
        my $handler = shift @{$signals->{signalled}} || next;
        # No need to check $handler->[SIGNALS] since we KNOW we have $signals
        defined $handler->[OBJ] || next;
        $handler->[CODE]->($handler->[OBJ], $handler->[NAME]);
    }

    # Avoid endless EINTR/read
    for my $i (1..100) {
        my $rc = sysread($signals->{rd}, my $buffer, $BLOCK_SIZE) && next;
        die "Assertion: EOF from signal pipe" if defined $rc;
        next if $! == EINTR;
        $! == EAGAIN || $! == EWOULDBLOCK ||
            die "error reading drom signal pipe: $^E";
        return;
    }
    die "Assertion: Seemingly endless read from signal pipe";
}

sub DESTROY {
    my ($handler) = @_;

    my $sig_name = $handler->[NAME];
    ::caller_info("delete_signal $sig_name") if $verbose > 1;

    my $signals = $handler->[SIGNALS] || return;

    if ($signals->{count}{$sig_name} > 1) {
        # This makes managing lots of handlers for the same signal
        # O(n^2). We could go for a doubly linked list of handlers or
        # some other datastructure if this ever becomes relevant
        my $handlers = $signals->{handlers}{$sig_name};
        my $to = 0;
        for my $i (0..$#$handlers) {
            next if !$handlers->[$i] || !defined $handlers->[$i][OBJ] || $handlers->[$i] == $handler;
            weaken($handlers->[$to] = $handlers->[$i]) if $i != $to;
            ++$to;
        }
        $#$handlers = $to-1;
        $to < $signals->{count}{$sig_name} ||
            die "Assertion: Could not find DESTROYed signal handler";
        return if $signals->{count}{$sig_name} = $to;
    }
    @{$signals->{handlers}{$sig_name}} = ();
    if (exists $signals->{old}{$sig_name}) {
        ::info("Restore signal $sig_name (deleted all signal callbacks)") if $verbose > 1;
        $SIG{$sig_name} = delete $signals->{old}{$sig_name};
    }
}

sub add0 {
    my $sig_name = shift;

    ::caller_info("add_signal $sig_name") if $verbose > 1;

    # We store $signals because if $signals gets cleaned up and restored
    # before Signal DESTROY we don't want it to impact the wrong object
    my $signals = Signals->init;
    my $handler = bless [$signals, $sig_name, shift, shift], "Signal";
    weaken($handler->[OBJ]);
    weaken($handler->[SIGNALS]);
    if (1 == ++$signals->{count}{$sig_name}) {
        ::caller_info("Take over_signal $sig_name") if $verbose > 1;
        $signals->{old}{$sig_name} = $SIG{$sig_name};
        $SIG{$sig_name} = \&Signals::signal_handler;
    }
    weaken($signals->{handlers}{$sig_name}[@{$signals->{handlers}{$sig_name}}] = $handler);
    return $handler;
}

my $CLOCK_TYPE_NAME;
{
    package Timer;
    # A small timer core
    use Scalar::Util qw(weaken refaddr);
    use Carp;
    use Time::HiRes qw(clock_gettime CLOCK_REALTIME CLOCK_MONOTONIC);

    # Timer indices
    use constant {
        INDEX	=> 0,
        TIME	=> 1,
        OBJ	=> 2,	# Must come after TIME
        CODE	=> 3,
        KEEPDEAD=> 4,
        CALLERS	=> 5,
    };

    my @timers = (undef);
    # @expired must be persistent so no timers get lost if a callback dies
    my @expired;
    # Simular for @expired. @immediate contains timeout 0 timers that we don't
    # even bother to put in @timers
    my @immediate;

    my $CLOCK_TYPE;
    $CLOCK_TYPE_NAME =
        eval { $CLOCK_TYPE = CLOCK_MONOTONIC; "MONOTONIC" } ||
    eval { $CLOCK_TYPE = CLOCK_REALTIME;  "REAL" } ||
    die "Time::HiRes doesn't even have CLOCK_REALTIME";

    sub realtime {
        return clock_gettime(CLOCK_REALTIME);
    }

    sub clocktime : method {
        return clock_gettime($CLOCK_TYPE);
    }

    # Timers are kept in a simple binary heap @timers
    sub timer {
        if ($verbose > 1) {
            my $v = $verbose;
            $verbose = 0;
            my $timer = timer(@_);
            $verbose = $v;
            my $callers = ::callers();
            $timer->[CALLERS] = $callers;
            ::info("add Timer(%s, %s) %08x [%s]",
                   $_[0], ::object_name($timer->[OBJ]), refaddr($timer), $callers);
            return $timer;
        }
        my $time = shift() + clocktime();
        my $i = @timers;
        while ($i > 1 && $time < $timers[$i >> 1][TIME]) {
            weaken($timers[$i] = $timers[$i >> 1]);
            $i = ($timers[$i][INDEX] = $i) >> 1;
        }
        my $timer = bless [$i, $time, shift, shift, 0];
        weaken($timer->[OBJ]);
        weaken($timers[$i] = $timer);
        ++$nr_events;
        return $timer;
    }

    sub timer0 {
        if ($verbose > 1) {
            my $v = $verbose;
            $verbose = 0;
            my $timer = timer0(@_);
            $verbose = $v;
            my $callers = ::callers();
            $timer->[CALLERS] = $callers;
            ::info("add0 Timer(%s, %s) %08x [%s]",
                   $_[0], ::object_name($timer->[OBJ]), refaddr($timer), $callers);
            return $timer;
        }
        my $time = shift() + clocktime();
        my $i = @timers;
        while ($i > 1 && $time < $timers[$i >> 1][TIME]) {
            weaken($timers[$i] = $timers[$i >> 1]);
            $i = ($timers[$i][INDEX] = $i) >> 1;
        }
        my $timer = bless [$i, $time, shift, shift, 1];
        weaken($timer->[OBJ]);
        weaken($timers[$i] = $timer);
        return $timer;
    }

    sub immediate {
        # If we ever expose the TIME element we should put clocktime() there
        my $timer = bless [0, 0, shift, shift, 0];
        weaken($timer->[OBJ]);
        weaken($immediate[@immediate] = $timer);
        if ($verbose > 1) {
            my $callers = ::callers();
            $timer->[CALLERS] = $callers;
            ::info("add Immediate Timer(%s) %08x [%s]",
                   ::object_name($timer->[OBJ]), refaddr($timer), $callers);
        }
        ++$nr_events;
        return $timer;
    }

    sub DESTROY {
        my ($timer) = @_;

        my $i = $timer->[INDEX];
        if ($verbose > 1 && defined $i) {
            if ($timer->[CALLERS]) {
                my $callers = ::callers();
                ::info("delete Timer(%s) %08x [%s], added at [%s]",
                       ::object_name($timer->[OBJ]),
                       refaddr($timer), $callers, $timer->[CALLERS]);
            } else {
                ::caller_info("delete Timer(%s) %08x",
                              ::object_name($timer->[OBJ]), refaddr($timer));
            }
        }
        if (!$i) {
            croak "Not a timer reference" unless defined($i);
            # Could be a timer sitting on the expired queue in run_now
            # This slicing will only be useful if not called by perl internals
            if (@$timer > TIME) {
                --$nr_events unless $timer->[KEEPDEAD];
                $#$timer = TIME;
            }
            return;
        }
        --$nr_events unless $timer->[KEEPDEAD];
        $timer->[INDEX] = 0;
        # Last element or beyond...
        if ($i >= $#timers) {
            croak "Not a timer reference" if $i > $#timers;
            pop @timers;
            return;
        }
        my $time = $timers[-1][TIME];
        if ($i > 1 && $time < $timers[$i >> 1][TIME]) {
            # percolate to root
            do {
                weaken($timers[$i] = $timers[$i >> 1]);
                $i = ($timers[$i][INDEX] = $i) >> 1;
            } while ($i > 1 && $time < $timers[$i >> 1][TIME]);
        } else {
            # percolate to leafs
            my $n = @timers-2;
            my $l = $i * 2;
            while ($l < $n) {
                if ($timers[$l][TIME] < $time) {
                    if ($timers[$l+1][TIME] < $timers[$l][TIME]) {
                        weaken($timers[$i] = $timers[$l+1]);
                        $timers[$i][INDEX] = $i;
                        $i = $l+1;
                    } else {
                        weaken($timers[$i] = $timers[$l]);
                        $timers[$i][INDEX] = $i;
                        $i = $l;
                    }
                } elsif ($timers[$l+1][TIME] < $time) {
                    weaken($timers[$i] = $timers[$l+1]);
                    $timers[$i][INDEX] = $i;
                    $i = $l+1;
                } else {
                    last;
                }
                $l = $i * 2;
            }
            if ($l == $n && $timers[$l][TIME] < $time) {
                weaken($timers[$i] = $timers[$l]);
                $timers[$i][INDEX] = $i;
                $i = $l;
            }
        }
        weaken($timers[$i] = pop @timers);
        $timers[$i][INDEX] = $i;
    }

    sub timers_collect {
        if (@immediate) {
            my $from = @expired;
            push @expired, @immediate;
            weaken($expired[$_]) for $from .. $#expired;
            @immediate = ();
        }
        return @expired ? 0 : undef if @timers <= 1;
        my $now = clocktime();
        return @expired ? 0 : $timers[1][TIME] - $now if $timers[1][TIME] > $now;

        # We will expire at least 1 timer
        # @timers > 2 makes sure that if we pop @timers we don't remove $timers[1]
        while (@timers > 2) {
            $timers[1][INDEX] = 0;
            weaken($expired[@expired] = $timers[1]);

            my $time = $timers[-1][TIME];
            my $n = @timers-2;
            my $i = 1;
            my $l = 2;
            while ($l < $n) {
                if ($timers[$l][TIME] < $time) {
                    if ($timers[$l+1][TIME] < $timers[$l][TIME]) {
                        weaken($timers[$i] = $timers[$l+1]);
                        $timers[$i][INDEX] = $i;
                        $i = $l+1;
                    } else {
                        weaken($timers[$i] = $timers[$l]);
                        $timers[$i][INDEX] = $i;
                        $i = $l;
                    }
                } elsif ($timers[$l+1][0] < $time) {
                    weaken($timers[$i] = $timers[$l+1]);
                    $timers[$i][INDEX] = $i;
                    $i = $l+1;
                } else {
                    last;
                }
                $l = $i * 2;
            }
            if ($l == $n && $timers[$l][TIME] < $time) {
                weaken($timers[$i] = $timers[$l]);
                $timers[$i][INDEX] = $i;
                $i = $l;
            }
            weaken($timers[$i] = pop @timers);
            $timers[$i][INDEX] = $i;
            return 0 if $timers[1][TIME] > $now;
        }
        if (@timers == 2) {
            $timers[1][INDEX] = 0;
            weaken($expired[@expired] = pop @timers);
        }

        return 0;
    }

    sub timers_run {
        @expired || return;
        my $timer;

        # Using while instead of for in case a callback dies
        ($timer = shift @expired and
         $timer->[KEEPDEAD]++ || $nr_events-- and
         $timer->[OBJ] and
         $timer->[CODE]->($timer->[OBJ])) while @expired;
    }

    sub events_immediate {
        my $events = shift;
        for my $timer (@immediate) {
            push @$events, sprintf("Immediate%s -> %s (id=%08x)",
                                   $timer->[KEEPDEAD] ?  " (dead)" : "",
                                   ::object_name($timer->[OBJ]),
                                   refaddr($timer)) if $timer;
        }
    }

    sub events_timer {
        my $events = shift;
        my $now = clocktime();
        push @$events, map {
            sprintf("Timer%s %2d -> %s (id=%08x timeout=%.3f)",
                    $_->[KEEPDEAD] ?  " (dead)" : "",
                    $_->[INDEX],
                    ::object_name($_->[OBJ]),
                    refaddr($_),
                    $_->[TIME]-$now,
                )
        } sort { $a->[TIME] <=> $b->[TIME] } grep defined, @timers;
    }
}

package Ids;
# Allocate and free unique numbers

# First id that will be given out
use constant INIT_ID => 1;

sub new {
    my $ids = bless {}, shift;
    $ids->id_init;
    return $ids;
}

sub id_init {
    my ($ids) = @_;

    $ids->{free_ids} = [];
    $ids->{free_id}  = INIT_ID() - 1;
}

sub id_alloc {
    my ($ids) = @_;

    return shift @{$ids->{free_ids}} || ++$ids->{free_id};
}

sub id_free {
    my ($ids, $id) = @_;

    push @{$ids->{free_ids}}, $id;
    # Decrease free_ids some if we are lucky
    while (@{$ids->{free_ids}}) {
        if ($ids->{free_ids}[-1] == $ids->{free_id}) {
            --$ids->{free_id};
            pop @{$ids->{free_ids}};
        } elsif ($ids->{free_ids}[0] == $ids->{free_id}) {
            --$ids->{free_id};
            shift @{$ids->{free_ids}};
        } else {
            last;
        }
    }
}

sub count {
    my ($ids) = @_;

    return $ids->{free_id} - @{$ids->{free_ids}} + (1-INIT_ID);
}

sub id_check {
    die "Assertion: Inconsistent id usage [", ::callers() . "]\n";
}

package Ids2;
# Allocate and free unique numbers but server and client use different parity
# This allows each side to allocate without disturbing the other
use vars qw(@ISA);
@ISA = qw(Ids);

sub new {
    my $class = shift;
    my $ids = $class->SUPER::new(@_);
    $ids->{offset} = $ids->{free_id} + ($role eq "client" ? 1 : 0);
    return $ids;
}

sub id_alloc {
    return 2*$_[0]->SUPER::id_alloc() - $_[0]->{offset};
}

sub id_free {
    my $ids = shift;
    my $id = $ids->{offset} + shift;
    $ids->SUPER::id_free($id >> 1) unless $id &1;
}

sub id_check {
    my $ids = shift;
    my $id = $ids->{offset} + shift;
    $ids->SUPER::id_check($id)  unless $id &1;
}

package Address;
use Socket qw(AF_INET pack_sockaddr_in unpack_sockaddr_in inet_aton inet_ntoa);
use Carp qw(croak);
# IPv6 could use [fe80::240:63ff:fede:3c19]:1234 as notation (like RFC 3986)
my %parse_regex = (
    tcp4	=> "(?:([^:/]*):|^)([^:/]*)",
    udp4	=> "(?:([^:/]*):|^)([^:/]*)",
);

my %from_defaults = (
    tcp4	=> "0.0.0.0:0",
    udp4	=> "0.0.0.0:0",
);

my $ADDRESS_ANY = __PACKAGE__->parse("0.0.0.0:0", "ADDRESS_ANY", from => "tcp4", resolve => 1);
my $ADDRESS_REMOTE = __PACKAGE__->parse("8.8.8.8:53", "ADDRESS_REMOTE", from => "tcp4", resolve => 1);

sub build_parser {
    my ($mode, $types, $matches) = @_;

    my @regex;
    $types = "TCP4" if !defined $types || $types eq "";
    for my $type (split /\|/, $types) {
        my $regex = $parse_regex{lc $type} || croak "Unknown $mode type '$type'";
        $regex =~ s/\((?!\?)/(?:/g;
        push @regex, "($regex)";
        push @$matches, [$mode, lc $type];
    }
    # print STDERR "REGEX: <@regex>\n";
    return join("|", @regex);
}

sub resolve {
    my ($address, $context) = @_;

    $address->{type} eq "udp4" || $address->{type} eq "tcp4" || next;

    $address->{addr} = inet_aton($address->{host}) ||
        die "Could not resolve $context '$address->{host}'\n";
    $address->{port} = $address->{port} =~
        # There is no port 0 in /etc/services so we can use ||
        /^0\z|^[1-9][0-9]*\z/ ? int($address->{port}) :
        $address->{type} =~ /^udp/ ? getservbyname($address->{port}, "udp") ||
        die("$context: Unknown UDP service '$address->{port}'\n") :
        $address->{type} =~ /^tcp/ ? getservbyname($address->{port}, "tcp") ||
        die("$context: Unknown TCP service '$address->{port}'\n") :
        die("Assertion: $context: Unknown type '$address->{type}'");
    $address->{host} = inet_ntoa($address->{addr});
    $address->{display} = "$address->{host}:$address->{port}";
    $address->{packed} = pack_sockaddr_in($address->{port}, $address->{addr});
}

sub parse {
    my ($class, $str, $context, %options) = @_;

    my $resolve = delete $options{resolve};
    my (@matches, @modes);
    my $regex = "";
    for my $mode (qw(from to)) {
        defined(my $types = delete $options{$mode}) || next;
        my $r = build_parser($mode, $types, \@matches);
        $regex = $regex eq "" ? $r : "(?:$regex:)?$r";
        push @modes, $mode;
    }
    die "Unknown option " . join(", ", map "'$_'", sort keys %options) if %options;
    my @matched = $str =~ /^$regex\z/ or
        die "Could not parse $context '$str'\n";
    my %matches;
    for my $i (0..$#matched) {
        defined(my $matched = $matched[$i]) || next;
        my ($mode, $type) =
            @{$matches[$i] || die "Assertion: Impossible match"};
        my @parts = $matched =~ $parse_regex{$type};
        if ($type eq "udp4" || $type eq "tcp4") {
            if (!defined $parts[0]) {
                $parts[0] = $default_bind;
            } elsif ($parts[0] eq "") {
                $parts[0] = $mode eq "from" ? "0.0.0.0" : "127.0.0.1";
            } elsif ($parts[0] eq "*") {
                # die "Cannot connect to the $context '*'" if $mode eq "to";
                $parts[0] = "0.0.0.0";
            }
            if (!defined $parts[1] || $parts[1] eq "") {
                # die "Missing $context port" if $mode eq "to";
                $parts[1] = "0";
            }
            $matches{$mode} = bless {
                type	=> $type,
                family	=> AF_INET,
                host	=> $parts[0],
                port	=> $parts[1],
                user	=> $matched,
                display	=> "$parts[0]:$parts[1]",
            }, $class;
            $matches{$mode}->resolve($context) if $resolve;
        } else {
            die "Assertion: Type '$type' not implemented";
        }
    }
    my @result = @matches{@modes} or die "Assertion: No modes";
    if (@result == 2 && !defined $result[0]) {
        # Both from and to but no from part given
        my $type = $result[1]{type};
        my $from = $from_defaults{$type} ||
            die "$context: No default from for type '$type'";
        $result[0] = $class->parse($from, $context, from => $type, resolve => $resolve);
    }
    return @result if wantarray;
    croak "Cannot return multiple results in a scalar" if @result != 1;
    return $result[0];
}

sub from_packed {
    my ($class, $packed, $type) = @_;

    my ($port, $addr) = unpack_sockaddr_in($packed);
    my $host = inet_ntoa($addr);
    return bless {
        type	=> $type || croak("Missing type"),
        family	=> AF_INET,
        addr	=> $addr,
        host	=> $host,
        port	=> $port,
        display	=> "$host:$port",
        user	=> "$host:$port",
        # Normalize packed so it has no random bytes in any padding
        packed	=> pack_sockaddr_in($port, $addr),
    }, $class;
}

# The format we use on the LineProtocol wire
sub decode {
    my ($class, $string, $type) = @_;

    my ($family, $port, $addr) = unpack("wna4", $string);
    $family == AF_INET || croak "Unimplemented family $family";
    $type eq "stream" || croak "Unimplemented type $type";
    return $class->from_packed(pack_sockaddr_in($port, $addr), "tcp4");
}

sub encode {
    my ($address) = @_;

    return pack("wna4", @$address{qw(family port addr)});
}

# Return a copy of $value (which is assumed to be resolved) but fill in the
# old attribute (user) from the new attributes (display) of
# $template (which is assumed to be unresolved)
sub copy2 {
    my ($value, $template) = @_;

    $template->{type} eq $value->{type} || croak "Inconsistent type";
    return bless {
        %$value,
        user	=> $template->{display}
    }, ref $value;
}

# Return a copy of $template (which is assumed not to be resolved)
# Copy host 0.0.0.0 and port 0 from $value (which is assumed to be resolved)
sub copy0_resolve {
    my ($template, $value, $context) = @_;

    $template->{type} eq $value->{type} || croak "Inconsistent type";
    my $result = bless {%$template}, ref $template;
    $result->{host} = $value->{host} if $result->{host} eq "0.0.0.0";
    $result->{port} ||= $value->{port};
    $result->resolve($context);
    return $result;
}

package ConnUtils;
# Utilities to set up connections
# Other package should need less Socket exports this way
use Socket qw(PF_INET SOCK_DGRAM SOCK_STREAM
               SOL_SOCKET SO_REUSEADDR SO_KEEPALIVE TCP_NODELAY
               pack_sockaddr_in inet_aton);
use Errno qw(EADDRINUSE EPROTONOSUPPORT EACCES ENOPROTOOPT);
use POSIX qw(ceil);

sub socket_udp_connected {
    my ($class, $address, $probe) = @_;

    socket(my $socket, PF_INET, SOCK_DGRAM, $PROTO_UDP) ||
        die "Could not create UDP socket: $^E";
    if ($probe) {
        connect($socket, $address->{packed}) || return $!;
        my $sockaddr = getsockname($socket) ||
            die "Assertion: Could not getsockname: $^E";
        return Address->from_packed($sockaddr, "udp4");
    }
    connect($socket, $address->{packed}) || die "Could not UDP connect to '$address->{display}': $^E";
    $socket->blocking(0);

    wantarray || return $socket;

    my $sockaddr = getpeername($socket) ||
        die "Assertion: Could not getpeername: $^E";
    return Address->from_packed($sockaddr), $socket;
}

sub socket_udp {
    my ($class, $host, $port, $probe) = @_;

    $port = $port =~ /^0\z|^[1-9][0-9]*\z/ ? int($port) :
        getservbyname($port, "udp") || die "Unknown UDP service '$port'";
    my $addr = inet_aton($host) || die "Could not resolve '$host'";
    socket(my $socket, PF_INET, SOCK_DGRAM, $PROTO_UDP) ||
        die "Could not create UDP socket: $^E";
    my $local = pack_sockaddr_in($port, $addr);
    if ($probe) {
        return 1 if bind($socket, $local);
        $! == EADDRINUSE || die "Could not bind socket: $^E";
        return 0;
    }
    bind($socket, $local) || die "Could not bind socket: $^E";
    $socket->blocking(0);
    wantarray || return $socket;

    my $sockaddr = getsockname($socket) ||
        die "Assertion: Could not getsockname: $^E";
    return Address->from_packed($sockaddr, "udp4"), $socket;
}

sub _socket_tcp {
    my ($settings, $address, $listen) = @_;

    socket(my $socket, PF_INET, SOCK_STREAM, $PROTO_TCP) ||
        die "Could not create TCP socket: $^E";
    $address ||= $ADDRESS_ANY;
    if ($listen) {
        setsockopt($socket, SOL_SOCKET, SO_REUSEADDR, 1) ||
            die "Assertion: Could not setsockopt(SOL_SOCKET, SO_REUSEADDR): $^E";
        bind($socket, $address->{packed}) ||
            die "Could not bind socket to '$address->{display}': $^E";
        listen($socket, $LISTEN_BACKLOG) || die "Could not listen: $^E";
        $socket->blocking(0);
    } elsif (defined $listen) {
        bind($socket, $address->{packed}) ||
            die "Could not bind socket to '$address->{display}': $^E ", ::callers();
        _tcp_set($settings, $socket);
    } else {
        # This is a blocking connect
        connect($socket, $address->{packed}) ||
            die "Could not connect to '$address->{display}': $^E";
        _tcp_set($settings, $socket);
    }
    wantarray || return $socket;

    my $sockaddr = getsockname($socket) ||
        die "Assertion: Could not getsockname: $^E";
    my $local = Address->from_packed($sockaddr, "tcp4");
    $local->{user} = $address->{user} if
        defined $listen && defined $address->{user};
    return $local, $socket;
}

sub socket_icmp {
    my ($class, $host, $id) = @_;

    $host = "0.0.0.0" if !defined $host;
    $id = 0 if !defined $id;

    $id =~ /^0\z|^[1-9][0-9]*\z/  || die "Invalid id '$id'";
    my $addr = inet_aton($host) || die "Could not resolve '$host'";
    socket(my $socket, PF_INET, SOCK_DGRAM, $PROTO_ICMP) || do {
        return if $! == EPROTONOSUPPORT || $! == EACCES;
        die "Could not create ICMP socket: $^E";
    };
    my $local = pack_sockaddr_in($id, $addr);
    bind($socket, $local) || die "Could not bind socket: $^E";
    $socket->blocking(0);
    wantarray || return $socket;

    my $sockaddr = getsockname($socket) ||
        die "Assertion: Could not getsockname: $^E";
    return Address->from_packed($sockaddr), $socket;
}

my $CAN_KEEPALIVE = 1;
sub _tcp_set {
    my ($settings, $socket) = @_;

    $socket->blocking(0);
    setsockopt($socket, $PROTO_TCP, TCP_NODELAY, 1) ||
        die "Couldn't disable Nagle's algorithm: $^E";
    setsockopt($socket, SOL_SOCKET, SO_KEEPALIVE, 1) ||
        die "Couldn't enable keealive: $^E";
    if ($CAN_KEEPALIVE && defined $TCP_KEEPIDLE) {
        if (setsockopt($socket, $PROTO_TCP, $TCP_KEEPIDLE, ceil($settings->{KEEPALIVE}))) {
            if (defined $TCP_KEEPCNT && defined $TCP_KEEPINTVL) {
                my $interval = ceil($settings->{TIMEOUT} / $TCP_KEEPALIVE_PROBES);
                setsockopt($socket, $PROTO_TCP, $TCP_KEEPINTVL, $interval) ||
                    die "Couldn't set TCP_KEEPINTVL to $interval: $^E";
                setsockopt($socket, $PROTO_TCP, $TCP_KEEPCNT, $TCP_KEEPALIVE_PROBES) ||
                    die "Couldn't set TCP_KEEPCNT to $TCP_KEEPALIVE_PROBES: $^E";
            }
        } elsif ($! == ENOPROTOOPT) {
            ::info("Couldn't set TCP_KEEPIDLE: $^E") if $verbose > 1;
            $CAN_KEEPALIVE = 0;
        } else {
            die "Couldn't set TCP_KEEPIDLE: $^E";
        }
    }
}

# This is more subtle that it seems. It doesn't just not accept until data,
# it doesn't send the final ACK of the connect handshake leading to
# retransmits if the data is late. Still it is may be good fit for protocols
# that immediately expect data (like SOCKS)
my $CAN_DEFER_ACCEPT = 10;
sub defer_accept {
    my ($class, $socket) = @_;

    $CAN_DEFER_ACCEPT || return;
    if (defined $TCP_DEFER_ACCEPT) {
        setsockopt($socket, $PROTO_TCP, $TCP_DEFER_ACCEPT, $CAN_DEFER_ACCEPT) ||
            die "Couldn't set TCP_DEFER_ACCEPT: $^E";
    } else {
        $CAN_DEFER_ACCEPT = 0;
    }
}

package Object;
# Base class of elements in out Object Tree
# This should make it easy to clean up subtrees by simply deleting the root
use Scalar::Util qw(weaken);
use Carp qw(croak);

# sub DESTROY { shift->caller_info("DESTROY") if $verbose > 2; }

sub new {
    my $class  = shift;
    my $parent = shift || croak "No parent";

    @_ % 2 == 0 || croak "Odd number of arguments";

    $parent->bug("Attempt to add '$class' child to cleaned Object") if $parent->{finished};
    my $object= bless {
        @_,
        deleted	=> 0,
        cleaned	=> 0,
        parent	=> $parent,
    }, $class;
    weaken($object->{parent});
    if (defined $object->{id}) {
        # Caller managed IDs
        $parent->{ids}{$class}->id_check($object->{id}) if $parent->{ids}{$class};
        $parent->bug("Child " . $object->name() . " already exists") if
            $parent->{children}{$class}[$object->{id}];
    } else {
        # Local managed IDs
        $object->{id} = ($parent->{ids}{$class} ||= Ids->new)->id_alloc;
    }
    $object->{id_full} = $parent->{id_full} ? "$parent->{id_full}:$object->{id}": "$object->{id}";
    $parent->{children}{$class}[$object->{id}] = $object;

    $object->info("CREATE") if $verbose > 2;

    return $object;
}

# Remove the obect from the Object tree. This usually will lead to
# the Object being destroyed but it can linger if anyone has a reference
# So you can't depend on this call doing an implicit finish()
sub delete : method {
    my $object = shift;

    if ($object->{deleted}) {
        $object->bug("Double delete on '@_'") if $object->{deleted} > 0;
        $object->bug("Recursive delete on '@_'");
    }
    $object->{deleted} = -1;
    $object->info("DELETING") if $verbose > 2;
    $object->finish(@_) unless $object->{finished};
    $object->_delete(@_);
    $object->info("DELETED") if $verbose > 2;
    $object->{deleted} = 1;
}

sub _delete {
    my $object = shift;

    my $ids = $object->{parent}{ids}{ref $object};
    $ids->id_free($object->{id}) if $ids;
    delete $object->{parent}{children}{ref $object}[$object->{id}] ||
        $object->isa("Root") ||
        $object->die("Detached from Object tree");
}

# Neuter the obect. From here on it shouldn't do anything anymore
# It will however remain in the object tree. This is typically used
# to wait for remote finish of its mutual partner which in turn is
# important to make sure the id isn't reused until all messages stop
sub finish {
    my $object = shift;

    if ($object->{finished}) {
        $object->bug("Double finish on '@_'") if $object->{finished} > 0;
        $object->bug("Recursive finish on '@_'");
    }
    $object->{finished} = -1;
    if (my $children = $object->{children}) {
        for my $class (sort keys %$children) {
            $_ && $_->delete(@_) for @{$children->{$class}};
        }
        %$children = ();
    }
    $object->_finish(@_);
    $object->{finished} = 1;
}

sub _finish {
    delete shift->{timeout};
}

sub die : method {
    my ($object, $msg) = @_;

    $object->info("DIE: $msg") if $verbose > 1;
    # Class call instead of obbject call
    die sprintf("%s: %s [%s]\n", $object, $msg, ::callers()) if ref $object eq "";
    $object->delete($msg) unless $object->{deleted};
    die sprintf("%s: %s [%s]\n", $object->name, $msg, ::callers());
}

sub dump : method {
    my ($object) = @_;
    local $object->{parent};
    print STDERR ::Dumper($object);
}

sub bug {
    my ($object, $msg) = @_;

    $object->die("Assertion: $msg");
}

sub error {
    my $object = shift;
    $object->die(@_);
}

sub id {
    return shift->{id};
}

sub id_full {
    return shift->{id_full};
}

sub name {
    my ($object) = @_;

    return sprintf("%s[%s]", ref $object, $object->{id_full});
}

sub child {
    my ($object, $class, $id) = @_;
    return $object->{children}{$class}[$id];
}

sub reclasify {
    my ($object, $class_to) = @_;

    my $parent = $object->{parent} ||
        $object->bug("Cannot rebless without a parent");
    my $class_from = ref $object;
    $class_from ne $class_to ||
        $object->bug("Cannot rebless from '$class_from' to itself");
    my $ids_from = $parent->{ids}{$class_from} ||
        $object->bug("Cannot rebless from '$class_from' without from Ids");
    my $ids_to = $parent->{ids}{$class_to} ||
        $object->bug("Cannot rebless to '$class_to' without to Ids");
    $ids_from == $ids_to ||
        $object->bug("Cannot rebless from '$class_from' to '$class_to' without equal Ids");
    $object->bug("Already have a '$class_to' child with id $object->{id}") if
        defined $parent->{children}{$class_to}[$object->{id}];
    my $o = delete $parent->{children}{$class_from}[$object->{id}] ||
        $object->bug("No '$class_from' child with id $object->{id}");
    if ($object != $o) {
        $parent->{children}{$class_from}[$object->{id}] = $o;
        $object->bug("Inconsistent '$class_from' child with id $object->{id}");
    }
    $parent->{children}{$class_to}[$object->{id}] = $o;
    return;
}

sub ids_set {
    my $object = shift;

    while (@_) {
        my $class = shift;
        my $ids = shift || Ids->new;
        $object->bug("Already have ids for class '$class'") if $object->{ids}{$class};
        $object->{ids}{$class} = $ids;
    }
}

sub ids_get {
    my ($object, $class) = @_;

    return $object->{ids}{$class} || $object->bug("No ids for class '$class'");
}

sub id_alloc {
    my ($object, $class) = @_;
    return $object->{ids}{$class}->id_alloc;
}

sub settings {
    my ($object) = @_;

    while ($object) {
        return $object->{settings} || next;
    } continue {
        $object = $object->{parent};
    }
    $_[0]->bug("No settings in parent chain");
}

sub tcp_set {
    my ($object, $socket) = @_;

    ConnUtils::_tcp_set(shift->settings, shift);
}

sub socket_tcp {
    ::ConnUtils::_socket_tcp(shift->settings, @_);
}

sub info {
    my $object = shift;
    my $format = shift;
    if (!@_) {
        @_ = ($format);
        $format = "%s";
    }
    unshift @_, "%s: " . $format, $object->name;
    goto &::info;
}

sub caller_info {
    my $object = shift;
    my $format = shift;
    if (@_) {
        @_ = ("%s: $format [%s]", $object->name, @_, ::callers());
    } else {
        @_ = ("%s: %s [%s]", $object->name, $format, ::callers());
    }
    goto &::info;
}

sub immediate {
    my $object = shift;
    $object->{timeout} = Timer::immediate($object, shift);
}

sub timer {
    my $object = shift;
    $object->{timeout} = Timer::timer(shift, $object, shift);
}

sub count_children {
    my ($object, $class) = @_;

    my $ids = $object->{ids}{$class} ||
        $object->bug("No counter for class '$class'");
    return $ids->count;
}

sub status_all {
    my ($object, $control, $indent) = @_;

    $object->status($control, $indent);
    $indent .= "  ";
    for my $class (sort keys %{$object->{children} || {}}) {
        my @objects = grep defined, @{$object->{children}{$class}};
        $control->{out} .= sprintf("%s%s: %s\n",
                                   $indent, $class, scalar @objects) if $class->can("status") == \&status || @objects == 0;
        $_->status_all($control, $indent) for @objects;
    }
}

sub status {
}

package Root;
# The root of our Object tree
use vars qw(@ISA);
@ISA = qw(Object);

use Carp qw(croak);
use Scalar::Util qw(weaken);

my $BASE_TIME  = Timer->realtime();
my $BASE_CLOCK = Timer->clocktime();
my $root = 0;

sub new {
    my $class = shift;

    @_ % 2 == 0 || croak "Odd number of arguments";

    my $root = bless {
        @_,
        id		=> 0,
        id_full		=> "0",
        settings	=> { %settings_global },
        timeout		=> undef,
        signals		=> {},
        ping_queued	=> [],
    }, $class;
    $root->info("CREATE") if $verbose > 2;
    $root->ids_set("Pinger");
    return $root;
}

sub status {
    my ($root, $control, $indent) = @_;

    my $name = $root->name;
    my $settings = ::string_from_value($root->{settings});
    $settings =~ s/\n/\n$indent  /g;

    $control->{out} .= <<"EOF"
$indent$name
$indent  Settings: $settings
EOF
        ;
}

sub _finish {
    my $root = shift;

    delete $root->{signals};
    $root->SUPER::_finish(@_);
}

sub signal_add0 {
    my ($root, $sig_name, $code) = @_;

    $root->die("Already have signal '$sig_name'") if $root->{signals}{$sig_name};
    $root->{signals}{$sig_name} = Signal::add0($sig_name, $root, $code);
}

sub global_timeout {
    ::info("Global timeout") if $verbose;
    ::_cleanup_all();
    # The cleanup of the globals above should be enough to fall off mainloop
    # $exit = 1;
    # exit $exit;
}

sub timeout {
    my ($root, $timeout) = @_;

    $root->{timeout} = Timer::timer0($timeout, $root, \&global_timeout);
    alarm($timeout+3);
}

sub client {
    my ($root, $socket_in, $socket_out, $connections, $client_only) = @_;

    my $line;
    eval {
        $line = LineProtocol->new(
            $root, $socket_in, $socket_out,
            client_only	=> $client_only,
        );

        my %connections = %$connections;
        for my $tcp (@{delete $connections{tcp_local}}) {
            my ($from, $to) = Address->parse($tcp, "TCP local", from => "tcp4", to => "tcp4");
            $from->resolve("TCP local");
            Listener::TCP::Forward->new_suspended($line, $from, remote => $to);
        }

        for my $socks (@{delete $connections{socks_local}}) {
            my $from = Address->parse($socks, "SOCKS local", from => "tcp4", resolve => 1);
            Listener::Socks::Local->new_suspended($line, $from);
        }

        for my $udp (@{delete $connections{fou_local}}) {
            my ($from, $to) =
                $udp =~ m{^([^%]+)%([^%]+)\z} or
                die "Invalid fou_local '$udp'";
            $from = Address->parse($from, "FOU local", from => "UDP4");
            $to   = Address->parse($to  , "FOU local", to   => "UDP4", resolve => 1);
            my $fou = Fou::UDP->new($to);
            Receiver::Fou->new_suspended($line, $from->{host}, $from->{port}, $fou);
        }

        for my $name (sort keys %{$line->{settings}}) {
            if ($name eq "EPOCH") {
                $line->set_peer($name => $BASE_TIME);
            } elsif ($name eq "MSGHDR") {
                $line->set_peer($name => $msghdr_error || Socket::MsgHdr->VERSION);
            } else {
                $line->set_peer($name => $line->{settings}{$name});
            }
        }

        for my $tcp (@{delete $connections{tcp_remote}}) {
            # From needs to be resolved at the server side
            # To needs to be resolved at activation time
            my ($from, $to) = Address->parse(
                $tcp, "TCP remote",
                from => "TCP4",
                to   => "TCP4");
            my $id = TCP::Remote->new($line, remote => $to)->id;
            $line->write($LISTEN_REMOTE, pack("ww/a*a*", $id, $from->{type}, $from->{user}));
        }

        for my $socks (@{delete $connections{socks_remote}}) {
            my $from = Address->parse($socks, "SOCKS remote", from => "tcp4");
            # Currently we don't track which id this gets on the remote side
            $line->write($SOCKS_REMOTE, pack("w/a*a*", $from->{type}, $from->{user}));
        }

        for my $udp (@{delete $connections{fou_remote}}) {
            my ($from, $to) =
                $udp =~ m{^([^%]+)%([^%]+)\z} or
                die "Invalid fou_remote '$udp'";
            # Pure syntax check, resolving will be done remotely
            Address->parse($from, "FOU remote", from => "UDP4");
            Address->parse($to  , "FOU remote", to   => "UDP4");
            $line->write($FOU_REMOTE, $udp);
        }

        for my $control (@{delete $connections{control_remote}}) {
            # User doesn't get to do detailed control of sone random server
            die "Cannot setup remote control using a pure client connection" if
                $client_only;
            die "Not implemented (yet)"
        }

        my @unimplemented = grep @{$connections->{$_}}, sort keys %connections;
        die "Option @unimplemented not implemented (yet)" if @unimplemented;
        $line->write($START);
    };
    die "\u$role: $@" if $@;
    return $line;
}

sub server {
    my ($root, $socket_in, $socket_out) = @_;

    my $line;
    eval {
        $line = LineProtocol->new($root, $socket_in, $socket_out);

        $line->set_peer(EPOCH	 => $BASE_TIME);
        $line->set_peer(MSGHDR	 => $msghdr_error || Socket::MsgHdr->VERSION);
    };
    die "\u$role: $@" if $@;
    return $line;
}

sub ping_activate {
    my ($root, $line, $icmp) = @_;

    if ($root->count_children("Pinger") >= $root->{settings}{PING_MAX}) {
        weaken($root->{ping_queued}[@{$root->{ping_queued}}] = $line);
        return 0;
    }
    Pinger->new($root, $icmp);
    return 1;
}

sub ping_finished {
    my ($root) = @_;

    while (@{$root->{ping_queued}} &&
           $root->count_children("Pinger") < $root->{settings}{PING_MAX}) {
        my $line = shift @{$root->{ping_queued}} || next;
        weaken($root->{ping_queued}[@{$root->{ping_queued}}] = $line) if
            $line->ping_finished($root);
    }
}

package Connection;
# A class below Stream and Packet connections for shared methods
use vars qw(@ISA);
@ISA = qw(Object);

# We could put a "new" method here setting finished_local and finished_remote
# to undef, but not all Streams are actually associated with another object
# at the other end of a LineProtocol (e.g. Pinger and Control aren't)

# If socket_in and socket_out are genuinly different it is the
# responsibity of the caller to shutdown() the write and read sides
# (if needed. pipes don't need it for example)
sub new_suspended {
    my $class = shift;
    return $class->SUPER::new(
        shift,
        socket_in	=> shift,
        socket_out	=> shift,
        reader		=> undef,
        writer		=> undef,
        timeout		=> undef,
        in		=> "",
        out		=> "",
        @_,
    );
}

sub new {
    my $class = shift;

    my $connection = $class->new_suspended(@_);
    $connection->resume_read if $connection->{socket_in};
    return $connection;
}

sub _delete {
    my $connection = shift;
    $connection->SUPER::_delete(@_);
    ::cleanup_all() if $connection->{exit};
}

sub _finish {
    my $connection = shift;

    delete @$connection{qw(in out reader writer socket_in socket_out)};
    $connection->SUPER::_finish(@_);
}

sub write_end {
    my $connection = shift;

    $connection->info("Finished writing. Will now delete($connection->{reason})") if $verbose > 1;
    $connection->delete($connection->{reason} || "Unknown reason");
}

sub delayed_write_end {
    my $connection = shift;
    $connection->{timeout} = undef;
    $connection->{on_written}->($connection);
}

sub _end_on_flushed {
    my $connection = shift;
    $connection->{reason} = shift || $connection->bug("No end reason");
    $connection->write(@_) if @_;
    $connection->{on_written} = $connection->can("write_end") ||
        $connection->bug("Cannot write_end");

    # It's fine if a later write() overrides this timeout, we DO want to
    # process the extra bytes, the on_written ramains active
    $connection->{timeout} = $connection->immediate(\&delayed_write_end);
}

# Flush pending output, then calls method "write_end" which triggers something.
# By default it deletes the object which closes the connection
# If you do more complex stuff and still need $connection->{in} you might want
# to call _end_on_flushed() or override end_on_flushed (and eof) instead
sub end_on_flushed {
    my $connection = shift;

    delete @$connection{qw(socket_in reader)};
    # In case we are called during a naive loop on $connection->{in} we want
    # to automatically drop out
    $connection->{in} = "" if defined $connection->{in};
    $connection->_end_on_flushed(@_);
}

sub suspend_read {
    my $connection = shift;

    $connection->info("suspend_read") if $verbose > 1;
    $connection->{reader} || $connection->die("Read already suspended");
    $connection->{reader} = undef;
}

sub black_hole {
    shift->{in} = "";
}

# Remote tells us it is finished
sub finished_remote {
    my ($connection, $reason) = @_;

    $connection->die("Already finished remote") if $connection->{finished_remote};
    $reason ||= "Unknown reason";
    $connection->{finished_remote} = $reason = "Remote: $reason";
    $connection->info("Finished \l$reason") if $verbose > 1;
    if ($connection->{finished}) {
        $connection->delete($reason);
    } else {
        $connection->finish_local($reason);
    }
}

# Tell remote to finish. This probably involves sending a message to the remote,
# which will be different for each type of Object, so no implementation here
sub finish_remote {
    shift->bug("finish_remote not implemented (yet)");
}

# Start cleaning up locally
sub finished_local {
    my ($connection, $reason) = @_;

    $connection->info("Finished local: $reason") if $verbose;
    $connection->die("Already finished local") if $connection->{finished};
    $connection->finish_remote($reason);
    if ($connection->{finished_remote}) {
        $connection->delete($reason);
    } else {
        $connection->finish($reason);
    }
}

# Tell local to finish. This probably involves flushing the output queue,
# which will be different for each type of Object, so no implementation here
sub finish_local {
    shift->bug("finish_local not implemented (yet)");
}

package _Stream;
# Stream connections
use vars qw(@ISA);
@ISA = qw(Connection);

use Errno qw(EINTR EAGAIN EWOULDBLOCK ECONNRESET);

# Leave the option open to redirect conn_reset() to eof()
# If you do don't forget to deactivate events (reader, writer, timeout etc)
sub conn_reset {
    my $stream = shift;

    $stream->error(@_);
}

sub eof : method {
    my $stream = shift;

    $stream->info("@_") if $verbose > 1;
    $stream->delete(@_);
}

sub reader {
    my ($stream) = @_;

    my $rc = sysread($stream->{socket_in}, my $buffer, $BLOCK_SIZE);
    if (!$rc) {
        if (defined $rc) {
            # EOF
            $stream->{reader} = undef;
            $stream->eof($stream->{peer} ? "EOF from $stream->{peer}{display}" : "EOF");
            # $stream->eof("EOF");
        } else {
            return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK;
            $stream->error("Could not sysread: $^E") if $! != ECONNRESET;
            $stream->conn_reset("Connection reset by peer");
        }
        return;
    }
    $stream->info("Received: %s", ::display($buffer)) if $verbose > 1;
    $stream->{in} .= $buffer;
    $stream->on_read($rc);
}

sub timeout {
    shift->error("Write timeout");
}

sub write : method {
    my $stream = shift;

    my $was_empty = $stream->{out} eq "";
    $stream->{out} .= join("", @_);
    $was_empty && $stream->{out} ne "" || return;
    $stream->writing();
}

sub writer {
    my ($stream) = @_;

    my $rc = syswrite($stream->{socket_out}, $stream->{out}, $BLOCK_SIZE);
    if (!$rc) {
        $stream->die("Zero write. Is this even possible ?") if defined $rc;
        return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK;
        $stream->error("Could not syswrite: $^E");
        return;
    }

    $stream->info("Wrote: %s (%d left)",
                  ::display(substr($stream->{out}, 0, $rc)),
                  length($stream->{out}) - $rc) if $verbose > 1;

    substr($stream->{out}, 0, $rc, "");
    if ($stream->{out} eq "") {
        $stream->{writer}  = undef;
        $stream->{timeout} = undef;
        $stream->{on_written}->($stream, $stream->{reason}) if $stream->{on_written};
        return;
    }
    $stream->writing();
}

package Stream;
# Stream connections that keep the program alive
use vars qw(@ISA);
@ISA = qw(_Stream);

sub writing {
    my ($stream) = @_;

    return if $stream->{unwritable};
    # This assumes parent == LineProtocol (or Root). Doesn't generalize
    $stream->{writer} ||= Events::add_write($stream->{socket_out}, $stream, \&_Stream::writer);
    $stream->{timeout} = Timer::timer($stream->{parent}{settings}{TIMEOUT}, $stream, \&_Stream::timeout);
}

sub resume_read {
    my $stream = shift;

    $stream->info("resume_read") if $verbose > 1;
    $stream->{reader} && $stream->die("Read not suspended");
    $stream->{reader} = Events::add_read($stream->{socket_in}, $stream, \&_Stream::reader);
}

package Stream0;
# Stream connections that don't keep the program alive
use vars qw(@ISA);
@ISA = qw(_Stream);

sub writing {
    my ($stream) = @_;

    return if $stream->{unwritable};
    # This assumes parent == LineProtocol (or Root). Doesn't generalize
    $stream->{writer} ||= Events::add_write0($stream->{socket_out}, $stream, \&_Stream::writer);
    $stream->{timeout} = Timer::timer($stream->{parent}{settings}{TIMEOUT}, $stream, \&_Stream::timeout);
}

sub resume_read {
    my $stream = shift;

    $stream->info("resume_read") if $verbose > 1;
    $stream->{reader} && $stream->die("Read not suspended");
    $stream->{reader} = Events::add_read0($stream->{socket_in}, $stream, \&_Stream::reader);
}

package Connect;
# Make a connection, then behave like a Stream
use vars qw(@ISA);
@ISA = qw(Stream);

use Errno qw(EINPROGRESS EWOULDBLOCK);
use Socket qw(SOL_SOCKET SO_ERROR);

sub new_suspended {
    my $class  = shift;
    my $parent = shift;
    my $local  = shift;
    my $peer   = shift;

    # pass undef for socket_in.  This avoid reader being started by Stream
    # pass undef for socket_out. This allows alternate call without connect()
    my $connect = $class->SUPER::new_suspended(
        $parent, undef, undef,
        local	=> $local,
        peer	=> $peer,
        @_,
    );
    if (!defined $connect->{socket_out} && $peer) {
        @$connect{qw(local socket_out)} = $connect->socket_tcp($local, 0);
        $connect->{unwritable} = 1;
        if (connect($connect->{socket_out}, $peer->{packed})) {
            # Immediate connect
            $connect->{timeout} = Timer::immediate($connect, sub { shift->on_connect(0)});
        } elsif ($! == EINPROGRESS || $! == EWOULDBLOCK) {
            $connect->info("Connecting to '$peer->{user}' [$peer->{display}]") if $verbose > 1;
            $connect->{writer} = Events::add_write0($connect->{socket_out}, $connect, \&connected);
            $connect->{timeout} = $connect->timer($connect->{parent}{settings}{TIMEOUT_CONNECT}, \&connect_timeout);
        } else {
            my $err = $!;
            $connect->{timeout} = $connect->immediate(sub { shift->on_connect($err)});
        }
    }
    return $connect;
}

sub connect_timeout {
    my ($connect) = @_;

    $connect->on_connect($ETIMEDOUT);
}

sub connected {
    my ($connect) = @_;

    $connect->{writer} = undef;
    # on_connect will set timeout to undef
    # $connect->{timeout} = undef;

    my $packed = getsockopt($connect->{socket_out}, SOL_SOCKET, SO_ERROR) ||
        $connect->bug("Could not getsockopt(SOL_SOCKET, SO_ERROR): $^E");
    $connect->on_connect(my $err = $! = unpack("I", $packed));
}

sub on_connect {
    my ($connect, $err) = @_;

    if ($err) {
        $connect->error("Could not connect to '$connect->{peer}{user}' [$connect->{peer}{display}]: $err");
        return;
    }
    $connect->{timeout} = undef;

    my $sockaddr = getsockname($connect->{socket_out}) ||
        die "Assertion: Could not getsockname: $^E";
    $connect->{local} = Address->from_packed($sockaddr, "tcp4");
    $connect->info("Connected from '$connect->{local}{display}' to '$connect->{peer}{user}' [$connect->{peer}{display}]: $!") if $verbose;

    $connect->{socket_in} = $connect->{socket_out};
    $connect->resume_read;
    delete $connect->{unwritable};
    $connect->writing if $connect->{out} ne "";
}

package _UDP;
# Base class for UDP connections (maybe add a Packet parent later)
use vars qw(@ISA);
@ISA = qw(Connection);

use Errno qw(EINTR EAGAIN EWOULDBLOCK EMSGSIZE);
use Socket qw(pack_sockaddr_in unpack_sockaddr_in inet_ntoa
              MSG_TRUNC MSG_CTRUNC);

sub new_suspended {
    my $class = shift;

    my $udp = $class->SUPER::new_suspended(
        shift, shift, shift,
        out => [],
        @_,
    );
    return $udp;
}

sub reader {
    my ($udp) = @_;

    my ($sockaddr, $bufref, $ttl);
    if ($msghdr) {
        $msghdr->{name} = "\0" x 256;
        $msghdr->{buf}  = "\0" x $UDP_SIZE;
        $msghdr->{control} = "\0" x 256;
        $msghdr->{flags} = 0;
        if (defined ::recvmsg($udp->{socket_in}, $msghdr)) {
            # I suspect Socket::MsgHdr has a bug so that flags is never set
            $udp->die("Yikes! Buffer was truncated") if
                        $msghdr->flags & MSG_TRUNC;
            $udp->die("Yikes! Ancillary data was truncated") if
                $msghdr->flags & MSG_CTRUNC;
            $bufref = \$msghdr->{buf};
            $sockaddr = $msghdr->{name};
            my ($level, $type, $data) =
                ::unpack_cmsghdr($msghdr->{control}) or
                $udp->bug("No ancillary data from socket");
            $level == $IPPROTO_IP ||
                $udp->bug("Unexpected level in ancillary data");
            $type == $IP_TTL ||
                $udp->bug("Unexpected type in ancillary data");
            $ttl = unpack("I", $data);
        }
    } else {
        $sockaddr = recv($udp->{socket_in}, my $buffer, $UDP_SIZE, 0);
        $bufref = \$bufref;
        $ttl = $TTL;
    }
    if (!defined $sockaddr) {
        return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK;
        $udp->error("Could not receive: $^E");
        return;
    }
    # No special handling for length 0.
    # It's perfectly fine to send and receve empty UDP packets
    my ($port, $addr) = unpack_sockaddr_in($sockaddr);
    $udp->info("Received from %s:%d%s: %s",
               inet_ntoa($addr), $port, $msghdr ? " (TTL $ttl)" : "",
               ::display($$bufref)) if $verbose > 1;
    $udp->on_read($addr, $port, $ttl, $bufref);
}

sub timeout {
    shift->error("Send timeout");
}

sub writing {
    my ($udp) = @_;

    return if $udp->{unwritable};
    # This assumes parent == LineProtocol (or Root). Doesn't generalize
    $udp->{writer} ||= Events::add_write($udp->{socket_out}, $udp, \&writer);
    $udp->{timeout} = Timer::timer($udp->{parent}{settings}{TIMEOUT}, $udp, \&timeout);
}

sub write : method {
    # @_ = ($udp, $port, $addr, $data, $ttl) if no $udp->{to}
    # @_ = ($udp, $data, $ttl)               if    $udp->[to}
    my $udp = shift;

    return if 1 != push @{$udp->{out}}, $msghdr ?
        bless {
            name => $udp->{to} || pack_sockaddr_in(shift, shift),
            buf  => shift,
            control => ::pack_cmsghdr(
                $IPPROTO_IP,
                $IP_TTL,
                pack("I", shift || die "Assertion: TTL 0")),
            flags => 0,
        }, "Socket::MsgHdr" :
        [$udp->{to} || pack_sockaddr_in(shift, shift), shift];
    $udp->writing;
}

sub writer {
    my ($udp) = @_;

    my $data = $udp->{out}[0];
    if ($msghdr) {
        my $rc = ::sendmsg($udp->{socket_out}, $data);
        if (!defined $rc) {
            return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK;
            if ($! == EMSGSIZE) {
                $udp->info("Cannot send oversized packet. Dropped") if $verbose > 1;
                goto DROP;
            }
            $udp->error("Could not send: $^E");
            return;
        }
        if ($verbose > 1) {
            my ($port, $addr) = unpack_sockaddr_in($data->{name});
            $udp->info("Wrote data (TTL %d) to %s:%d (%d left): %s",
                       unpack("I",(::unpack_cmsghdr($udp->{out}[0]->{control}))[2]),
                       inet_ntoa($addr), $port, length($data->{buf}) - $rc,
                       ::display(substr($data->{buf}, 0, $rc)));
        }
        $rc == length($data->{buf}) ||
            $udp->bug("Incomplete send ($rc of " . length($data->{buf}) . ")");
    } else {
        my $rc = send($udp->{socket_out}, $data->[1], 0, $data->[0]);
        if (!defined $rc) {
            return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK;
            if ($! == EMSGSIZE) {
                $udp->info("Cannot send oversized packet. Dropped") if $verbose > 1;
                goto DROP;
            }
            $udp->error("Could not send: $^E");
            return;
        }
        if ($verbose > 1) {
            my ($port, $addr) = unpack_sockaddr_in($data->[0]);
            $udp->info("Wrote to %s:%d: %s (%d left)",
                       inet_ntoa($addr), $port,
                       ::display(substr($data->[1], 0, $rc)),
                       length($data->[1]) - $rc);
        }
        $rc == length($data->[1]) ||
            $udp->bug("Incomplete send ($rc of " . length($data->[1]) . ")");
    }

  DROP:
    shift @{$udp->{out}};
    if (@{$udp->{out}}) {
        $udp->writing;
    } else {
        $udp->{writer}  = undef;
        $udp->{timeout} = undef;
    }
}

package UDP;
# UDP connections that keep the program alive
use vars qw(@ISA);
@ISA = qw(_UDP);

sub new_suspended {
    my $class = shift;

    my $udp = $class->SUPER::new_suspended(@_);
    if ($udp->{socket_in}) {
        !$msghdr ||
            setsockopt($udp->{socket_in}, $IPPROTO_IP, $IP_RECVTTL, 1) ||
            $udp->die("setsockopt(IPPROTO_IP, IP_RECVTTL): $^E");
    }
    return $udp;
}

sub resume_read {
    my $udp = shift;

    $udp->info("resume_read") if $verbose > 1;
    $udp->{reader} && $udp->die("Read not suspended");
    $udp->{reader} = Events::add_read($udp->{socket_in}, $udp, \&_UDP::reader);
}

package Pinger;
# Manage runs of the OS ping program
use vars qw(@ISA);
# We maybe should introduce a StreamReader for only the read part of Stream
@ISA = qw(Stream0);

use Scalar::Util qw(weaken);
use Socket qw(inet_aton);

sub new_suspended {
    my ($class, $root, $client) = @_;

    my ($host, $data) = $client->host_data;
    pipe(my $rd0, my $wr0) || $class->die("Could not open pipe: $^E");
    pipe(my $rd1, my $wr1) || $class->die("Could not open pipe: $^E");

    defined(my $pid = fork()) || $class->die("Could not fork: $^E");
    if ($pid == 0) {
        # Child
        select($wr1);
        $| = 1;
        eval {
            close($rd0) || $class->die("Could not close pipe: $^E");
            close($rd1) || $class->die("Could not close pipe: $^E");
            open(STDIN,  "<&", $null) || $class->die("Could not dup to STDIN: $^E");
            open(STDOUT, ">&", $wr0)  || $class->die("Could not dup to STDOUT: $^E");
            close($wr0) || $class->die("Could not close pipe: $^E");
            # open(STDERR, ">&STDOUT")  || die "Could not dup to STDERR: $^E";
            $SIG{CHLD} = "DEFAULT";
            no warnings "exec";
            exec(@{$PING[0]}, $host, @{$PING[1]}) ||
                $class->die("Could not exec $PING[0][0]: $^E");
        };
        print $@ || "Assertion: Pinger ended without error\n";
        _exit(1);
    }

    # Parent
    close($wr0) || $class->die("Could not close pipe: $^E");
    close($wr1) || $class->die("Could not close pipe: $^E");
    $rd0->blocking(0);
    $rd1->blocking(0);

    my $pinger = $class->SUPER::new_suspended(
        $root, $rd1, undef,
        waitable	=> undef,
        handle		=> $rd0,
        pid		=> $pid,
        parent_pid	=> $$,
        host		=> $host,
        data		=> $data);
    weaken($pinger->{client} = $client);

    $pinger->info("waiting to spawn ping '%s'",
                  $pinger->{host}) if $verbose > 1;
    # $pinger->info("Created");

    return $pinger;
}

sub wait : method {
    return undef if defined $SIG{CHLD} && $SIG{CHLD} eq "IGNORE";
    my ($pinger) = @_;

    my $pid = $pinger->{pid};
    return undef if $pinger->{parent_pid} != $$ || !$pid;
    $pinger->{pid} = undef;
    my $p = waitpid($pid, 0);
    if ($p != $pid) {
        $pinger->die("Could not wait for pid '$pid'") if $p < 0;
        $pinger->bug("Invalid pid result") if $p != $pid;
    }
    # die "Unexpected exitcode $? from ping $pinger->{host} (pid $pid)" if $?;
    return $?;
}

sub eof : method {
    my $pinger = shift;

    if ($pinger->{handle}) {
        # Read from the probe pipe
        $pinger->{socket_in} = delete $pinger->{handle};
        $pinger->die($pinger->{in}) if $pinger->{in} ne "";
        $pinger->{reader} = Events::add_read0($pinger->{socket_in}, $pinger, \&_Stream::reader);
        $pinger->info("Spawned. Switch to reading ping result") if $verbose > 1;
        return;
    }

    $pinger->{waitable} = 1;
    my $client = $pinger->{client};
    if (my ($ip, $ttl, $time) =
        $pinger->{in} =~ /from (\d+\.\d+\.\d+\.\d+).* icmp_[sr]eq.* ttl=(\d+).* time=(\S+ (?:ms|usec))/) {
        $pinger->info("Response from '%s' ttl=%d, time=%s",
                      $ip, $ttl, $time) if $verbose > 1;
        $ip eq $pinger->{host} ||
            $pinger->bug("Inconsistent: pinged '$pinger->{host}', got answer from '$ip'");
        $client->ping_result($pinger->{data}, $ttl, $time) if $client;
    } else {
        if ($verbose > 1) {
            if ($pinger->{in} eq "") {
                $pinger->info("No response from '%s'",
                              $pinger->{host}) if $verbose > 1;
            } else {
                $pinger->info("No result in response from '%s': %s",
                              $pinger->{host}, ::display($pinger->{in})) if $verbose > 1;
            }
        }
        $client->ping_result($pinger->{data}) if $client;
    }
    $pinger->delete("Ping result");
}

sub _finish {
    my $pinger = shift;

    delete $pinger->{data};
    $pinger->wait if $pinger->{waitable};
    $pinger->SUPER::_finish(@_);
}

# This code belongs in _finish really
# But that would allow new Pingers to be started while the finished one is
# not freed yet, so the ids would go above ping_max which looks super confusing
sub _delete {
    my $pinger = shift;
    $pinger->SUPER::_delete(@_);
    $pinger->{parent}->ping_finished;
}

sub on_read {
    # Process neiher the probe pipe nor the result pipe during read
    # We could check for insanely long output here
}

sub status {
    my ($pinger, $control, $indent) = @_;

    my $name = $pinger->name;

    $control->{out} .= <<"EOF"
$indent$name
$indent  Host: $pinger->{host}
$indent  Pid:  $pinger->{pid}
EOF
        ;
}

package Sender::ICMP;
# Send and receive ICMP (echo) messages
# Falls back to using the OS ping program if not permitted
use vars qw(@ISA);
@ISA = qw(UDP);

use Socket qw(inet_ntoa);

sub new_suspended {
    my ($class, $line, $id) = @_;

    # Notice this can return nothing if we can't open an UDP icmp socket
    # (either not supported on OS or user not in allowed grooup)
    my ($local, $socket) = ConnUtils->socket_icmp("0.0.0.0", 0);
    !$msghdr || !$socket || setsockopt($socket, $IPPROTO_IP, $IP_RECVTTL, 1) ||
        die "setsockopt(IPPROTO_IP, IP_RECVTTL): $^E";
    # ICMP_FILTER always gets me ENOPROTOOPT
    # However when /bin/ping does it (when sysctl group NOT set) it works???
    # !$socket || setsockopt($socket, $SOL_RAW, $ICMP_FILTER, 0xffffffff ^ 1<<$ICMP_ECHO_REPLY) ||
    #    die "setsockopt(SOL_RAW, ICMP_FILTER): $^E" if defined $ICMP_FILTER;

    my $icmp = $class->SUPER::new_suspended(
        $line, $socket, $socket,
        id		=> $id,
        pid		=> $$,
        local		=> $local,
        icmp_id		=> $local->{port},
        pending		=> 0);

    if ($verbose > 1) {
        if ($socket) {
            $icmp->info("New ICMP socket '%s'", $local->{display});
        } else {
            $icmp->info("Using external ping");
        }
    }

    return $icmp;
}

sub on_read {
    my ($icmp, $addr, $port, $ttl, $bufref) = @_;

    # 16 bytes MD5, 4 bytes rand, 4 bytes src, 2 bytes id, 2 bytes seqno
    # and at least 1 fou_id byte
    length $$bufref >= $ICMP_HEADER + (16+4+4+2+2+1) || return;
    $$bufref .= "\0";
    my $sum = unpack("%32n*", $$bufref);
    my ($type, $code, $icmp_chksum, $icmp_id, $seqno) =
        unpack("wwn3", substr($$bufref, 0, $ICMP_HEADER, ""));
    chop $$bufref;
    if (1 || $icmp_chksum) {
        while ($sum > 0xffff) {
            my $carry = $sum >> 16;
            $sum &= 0xffff;
            $sum += $carry;
        }
        $sum == 0xffff || return;
    }
    $type == $ICMP_ECHO_REPLY || return;
    $code == 0 || return;

    $icmp->info("ICMP ECHO Payload (Type %d, Code %d, Id %d, Seqno %d) from %s: %s",
                $type, $code, $icmp_id, $seqno, inet_ntoa($addr),
                ::display($$bufref)) if $verbose > 1;
    $icmp->{parent}->write($RESPONSE_PING, pack("wa4C", $icmp->{id}, $addr, $ttl-1), $$bufref) if $ttl > 1;
}

sub write : method {
    # @_ = ($icmp, $dst, $seqno, $data, $ttl)
    my $icmp = shift;

    if (!$icmp->{socket_out}) {
        $icmp->info("Queue external ping %s [seqno %d]", inet_ntoa($_[0]), $_[1]) if $verbose;
        # We could retry acquiring an ICMP socket here
        $icmp->{parent}->ping_activate($icmp) if
            1 == push @{$icmp->{out}}, [shift, shift, shift];
        return;
    }

    my $dst = shift;
    $icmp->info("Need to send ICMP ECHO (Type %d, Code 0, Id %d, Seqno %d, TTL %d) to %s: %s",
                $ICMP_ECHO_REQUEST, $icmp->{icmp_id}, @_[0,2], inet_ntoa($dst),
                ::display($_[1])) if $verbose > 1;

    my $data = pack("Cx3n2a*x", $ICMP_ECHO_REQUEST, $icmp->{icmp_id},
                    shift, shift);
    my $sum = unpack("%32n*", $data);
    chop $data;
    while ($sum > 0xffff) {
        my $carry = $sum >> 16;
        $sum &= 0xffff;
        $sum += $carry;
    }
    substr($data, 2, 2, pack("n", 0xffff - $sum));
    $icmp->SUPER::write(0, $dst, $data, shift);
}

sub host_data {
    my ($icmp) = @_;
    my $out = shift @{$icmp->{out}} || $icmp->bug("Empty ping queue");
    return inet_ntoa($out->[0]), $out;
}

sub ping_result {
    my ($icmp, $out, $ttl, $time) = @_;

    $icmp->{parent}->write($RESPONSE_PING, pack("wa4C", $icmp->{id}, $out->[0], $ttl-1), $out->[2]) if defined $ttl && $ttl > 1;
}

sub ping_finished {
    my ($icmp, $line, $root) = @_;

    @{$icmp->{out}} || $icmp->bug("Empty out was queued");
    $root->ping_activate($line, $icmp);
    return scalar @{$icmp->{out}};
}

package Sender::UDP;
# Send out packets at the remote side (and wait for replies)
use vars qw(@ISA);
@ISA = qw(UDP);

sub new_suspended {
    my ($class, $line, $id) = @_;

    my ($local, $socket) = ConnUtils->socket_udp("0.0.0.0", 0);

    my $sender = $class->SUPER::new_suspended(
        $line, $socket, $socket,
        id		=> $id,
        local		=> $local);

    $sender->info("Local address '%s'", $local->{display}) if $verbose > 1;
    return $sender;
}

sub on_read {
    my $sender = shift;
    # Now: @_ = ($from_addr, $from_port, $ttl, $dataref)
    $sender->{parent}->write($RESPONSE_UDP, pack("wa4nC", $sender->{id}, shift, shift, shift()-1), ${shift()}) if $_[2] > 1;
}

package Receiver::Fou;
# Wait for packets at the local (client) side
use vars qw(@ISA);
@ISA = qw(UDP);

use Socket qw(inet_ntoa);
use Digest::MD5 qw(md5);

sub new_suspended {
    my ($class, $line, $host, $port, $fou) = @_;

    my ($local, $socket) = ConnUtils->socket_udp($host, $port);

    my $listener = $class->SUPER::new_suspended(
        $line, $socket, undef,
        local		=> $local,
        fou_id		=> $fou->id);

    $listener->info("Listening on '%s'", $local->{display}) if $verbose > 1;
    return $listener;
}

sub on_read {
    # @_ = ($listener, $from_addr, $from_port, $ttl, $dataref)
    my ($listener, undef, undef, undef, $bufref) = @_;

    my ($ihl, $ecn, $length, $id, $fragment, $ttl, $proto, $chksum, $nsrc, $ndst) = unpack("CCnnnCCna4a4", $$bufref);
    if ($verbose > 2) {
        $listener->info(
            "TEMP: IHL=%d, ECN=%d, LEN=%d, ID=%d, FRAGMENT=%#04X, TTL=%d, PROTO=%d, CHK=%#04X, SRC=%s, DST=%s\n",
            $ihl, $ecn, $length, $id, $fragment, $ttl, $proto, $chksum,
            inet_ntoa($nsrc), inet_ntoa($ndst));
    }

    # Don't handle spammy multicast stuff (in my case mostly OSPF)
    return if $MULTICAST_BEGIN le $ndst && $ndst lt $MULTICAST_END;

    my $version = $ihl >> 4;
    $ihl &= 0xf;
    my $flags = $fragment >> 13;
    $fragment &= 0x1fff;
    # only TCP4
    $version == $IP_VERSION || return;
    # Sanity check on buffer
    length($$bufref) == $length || return;
    # We don't handle IP options (yet)
    $ihl == $IHL || return;
    # Too many hops
    $ttl > 1 || return;
    # Don't handle fragments (fragment offset)
    return if $fragment;
    # Don't handle fragments (MF flag set)
    return if $flags & 0x1;

    $ihl *= 4;
    my $header = substr($$bufref, 0, $ihl, "");
    $length -= $ihl;

    # No buffer padding needed since length($header) is even
    my $sum = unpack("%32n*", $header);
    while ($sum > 0xffff) {
        my $carry = $sum >> 16;
        $sum &= 0xffff;
        $sum += $carry;
    }
    $sum == 0xffff || return;

    my $src = inet_ntoa($nsrc);
    my $dst = inet_ntoa($ndst);

    # print "Sender $peer:$peer_port, Receiver $local [$msg_dst]\n";

    my $dscp = $ecn >> 3;
    $ecn &= 0x7;
    # print "HEADER: DSCP=$dscp, ECN=$ecn, ID=$id, FLAGS=$flags, FRAGMENT=$fragment, TTL=$ttl, CHKSUM=$chksum, SRC=$src, DST=$dst\n";

    if ($proto == $PROTO_UDP) {
        # Only UDP

        # Must have space for UDP header
        return if $length < $UDP_HEADER;

        my $pseudo10 = pack("a4a4xC", $nsrc, $ndst, $proto);
        # Pad buffer with \0 so a last single byte still gets processed as "n"
        $sum = unpack("%32n*", $$bufref . "\x0") + unpack("%32n*", $pseudo10) + $length;
        my ($sprt, $dprt, $udp_len, $udp_chksum) = unpack("nnnn", substr($$bufref, 0, $UDP_HEADER, ""));
        $udp_len == $length || die "Inconsistent UDP length (inner UDP payload length: $udp_len, Inner IP packet length - inner UDP header length $ihl = $length)";
        $length -= $UDP_HEADER;

        if ($udp_chksum) {
            while ($sum > 0xffff) {
                my $carry = $sum >> 16;
                $sum &= 0xffff;
                $sum += $carry;
            }
            $sum == 0xffff || return;
        }

        $listener->info("FOU decoded UDP bytes (TTL %d) on $role UDP socket(%s:%d -> %s:%d): %s",
                        $ttl, $src, $sprt, $dst, $dprt,
                        ::display($$bufref)) if $verbose > 1;

        my $line = $listener->{parent};
        # On the remote side we will be able to distinguish packets coming back
        # from ($dst, $dport) so we can share a single Sender::UDP for a given
        # ($src,$port)
        my $map_src = $line->{map_udp}{"$dst:$dprt"} ||= [
            0,                 # Next seq counter
            {
            },                 # Map "src:port" to map
            [undef],           # Map id to map (the undef makes id start at 1)
            # $ndst,	# Packed destination address
            # $dprt,	# Destination Port
        ];
        my $fou_id = $listener->{fou_id};
        my $key = "$src:$sprt:$fou_id";
        my $map = $map_src->[1]{$key} ||= {
            key		=> $key,
            port	=> $sprt,
            host	=> $src,
            addr	=> $nsrc,
            fou_id	=> $fou_id,
        };
        $map->{seq} = $map_src->[0]++;
        # We should be able to handle many billions of packets before this overflows
        die "Too many packets to $dst:$dprt" if $map->{seq} == $map_src->[0];
        $id = $map->{id};
        if (!defined $id) {
            my $settings = $listener->{parent}{settings};
            # A source we haven't saeen befre or we have forgotten
            if (values %{$map_src->[1]} > $settings->{UDP_MAX}) {
                my @old = sort {$a->{seq} <=> $b->{seq}} values %{$map_src->[1]};
                # Ignore the map we just added (it will have the highest packet number)
                pop @old;
                for my $old (@old) {
                    # Try to allocate the socket. If we can that means the
                    # ($src,$port) combination is not in local use anymore and we
                    # can completely drop it
                    # Notice if we receive FOU packets from a remote host we also
                    # won't be able to bind(), so this works out OK. There is a
                    # problem if we share IP addresses with the sender of the FOU
                    # packets though. So we probably need an option to turn this
                    # off and have another strategy to free up entries
                    # (e.g. a timeout)
                    # print STDERR "Probe $old->{host}, $old->{port}\n";
                    if (ConnUtils->socket_udp($old->{host}, $old->{port}, 1)) {
                        $listener->info("Releasing map '$key' (socket not in use any more)") if $verbose > 1;
                        $id = $old->{id};
                        last;
                    }
                }
                defined $id || die "Assertion: no Free id's";
                # $id //= $old[0]{id} // die "Assertion: no Free id's";
                my $remove = $map_src->[2][$id];
                delete $map_src->[1]{$remove->{key}} == $remove ||
                    die "Assertion: Removing unexpected entry";
            } else {
                $id = @{$map_src->[2]};
            }
            $map->{id} = $id;
            $map_src->[2][$id] = $map;
        }
        # print STDERR ::Dumper($id, $line->{map_udp});
        $line->write($UDP_DATA, pack("wa4nC", $id, $ndst, $dprt, $ttl-1), $$bufref);
    } elsif ($proto == $PROTO_ICMP) {
        # Must have ToS 0
        $dscp == 0 && $ecn == 0 || return;
        # Must have space for ICMP header
        return if $length < $ICMP_HEADER;

        # Pad buffer with \0 so a last single byte still gets processed as "n"
        $sum = unpack("%32n*", $$bufref . "\x0");
        my ($type, $code, $icmp_chksum, $id, $seqno) =
            unpack("WWn3", substr($$bufref, 0, $ICMP_HEADER, ""));
        $length -= $ICMP_HEADER;

        # For mow we only support ICMP ECHO REQUEST
        $code == 0 || return;
        my $extra = "";
        if ($type == $ICMP_ECHO_REQUEST) {
            # Resulting packet must fit
            $extra = pack("a16Na4nnw", $SECRET, rand int 2**32, $nsrc, $id, $seqno, $listener->{fou_id});
            return if $length + $ICMP_HEADER + $IHL * 4 + length($extra) >> 16;
        } else {
            return;
        }

        if (1 || $icmp_chksum) {
            while ($sum > 0xffff) {
                my $carry = $sum >> 16;
                $sum &= 0xffff;
                $sum += $carry;
            }
            $sum == 0xffff || return;
        }

        $listener->info("FOU decoded ICMP bytes (TTL %d) on $role UDP socket(%s -> %s): type %d, code %d, id %d, seqno %d, data=%s",
                        $ttl, $src, $dst,
                        $type, $code, $id, $seqno,
                        ::display($$bufref)) if $verbose > 1;

        my $line = $listener->{parent};
        # We leak $src here. We could do some unique remote port mapping instead
        substr($$bufref, 0, 0, $extra);
        substr($$bufref, 0, 16, md5($$bufref));
        my $remote_seqno = ++$line->{seqno_echo};
        $line->{seqno_echo} = $remote_seqno = 1 if $remote_seqno >> 16;
        $line->write($PING, pack("wa4nC", 1, $ndst, $remote_seqno, $ttl-1), $$bufref);
    }
}

package Fou::UDP;
# Send out proxied packets at the local (client) side usinga FOU tunnel
use vars qw(@ISA);
@ISA = qw(_UDP);

use Scalar::Util qw(weaken);
use Socket qw(inet_aton inet_ntoa pack_sockaddr_in);

# Called with a resolved address (see Address->parse)
{ no warnings "once"; *new = \&new_suspended; }
sub new_suspended {
    my ($class, $address_to) = @_;

    my $lookup_id = "$address_to->{host}:$address_to->{port}";
    my $fou = $root->{lookups}{$class}{$lookup_id};
    return $fou if $fou;

    # For now listen on any with a random port. Make this an option
    my ($local, $socket) = ConnUtils->socket_udp("0.0.0.0", 0);

    $fou = $class->SUPER::new_suspended(
        $root, undef, $socket,
        lookup_id	=> $lookup_id,
        local		=> $local,
        # Maybe just store $address_to
        to		=> $address_to->{packed},
        host		=> $address_to->{host},
        port		=> $address_to->{port});
    weaken($root->{lookups}{$class}{$lookup_id} = $fou);
    return $fou;
}

sub _finish {
    my $fou = shift;

    delete $fou->{parent}{lookups}{ref $fou}{$fou->{lookup_id}};
    $fou->SUPER::_finish(@_);
}

package TCP::Remote;
# Partner on the client side to a remote Listener::TCP::Forward at the server
# Does nothing except remembering the forwarding argument
use vars qw(@ISA);
@ISA = qw(Object);

sub write : method {
    my $remote = shift;

    $remote->{out} .= join("", @_);
}

sub writing {
    shift->bug("No writing should be triggered");
}

sub status {
    my ($remote, $control, $indent) = @_;

    my $name = $remote->name;
    $control->{out} .= <<"EOF"
$indent$name
$indent  Local Connect to '$remote->{remote}{display}'
EOF
        ;
}

package Listener::TCP::Forward;
# Listen for incoming connections that need forwarding on the client side
use vars qw(@ISA);
@ISA = qw(Listener);

sub on_accept {
    my ($listener, $accepted, $local, $peer) = @_;

    # Peer is who is connecting to us
    # Local is where we got connected
    # Remote is what we plan to connect to on the remote side

    my $line = $listener->{parent};
    my %remote = %{$listener->{remote}};
    $remote{port} ||= $local->{port};
    $remote{host} = $local->{host} if $remote{host} eq "0.0.0.0";
    $remote{display} = "$remote{host}:$remote{port}";

    my $forward = TCP::Forward->new(
        $line, undef, $peer,
        socket_in	=> $accepted,
        socket_out	=> $accepted,
        local		=> $local,
        remote		=> \%remote,
    );
    $forward->info("Start forwarding from %s to %s (remote connect may still fail though)", $peer->{display}, $remote{display}) if $verbose > 1;
    $line->write($CONNECT, pack("ww/a*a*",
                                $forward->{id},
                                @remote{qw(type display)}));
    return $forward;
}

sub status {
    my ($listener, $control, $indent) = @_;

    $listener->SUPER::status($control, $indent);

    $control->{out} .= "$indent  Remote Connect to '$listener->{remote}{user}'\n";
}

package Listener::TCP::Remote;
# Listen for incoming connections that need forwarding on the server side
use vars qw(@ISA);
@ISA = qw(Listener);

sub on_accept {
    my ($listener, $accepted, $local, $peer) = @_;

    # Peer is who is connecting to us
    # Local is where we got connected
    # We don;t know what we plan to connect to on the remote (client) side
    # The client has that in the corresponding TCP::Remote object

    my $line = $listener->{parent};

    my $forward = TCP::Forward->new(
        $line, undef, $peer,
        socket_in	=> $accepted,
        socket_out	=> $accepted,
        local		=> $local,
        remote_id	=> $listener->id,
    );
    $forward->info("Start forwarding from %s to TCP::Remote %d (remote connect may still fail though)", $peer->{display}, $forward->{remote_id}) if $verbose > 1;
    $line->write($CONNECT_REMOTE, pack("wwa*",
                                       @$forward{qw(id remote_id)},
                                       $local->encode));
    return $forward;
}

package TCP::Forward;
# Generic TCP forwarder. Just copies data to the other side
use vars qw(@ISA);
@ISA = qw(Connect);

use Errno qw(ENOTCONN);

sub on_read {
    my ($forward) = @_;

    $forward->info("Forwarding data: %s", ::display($forward->{in})) if $verbose > 1;
    $forward->{parent}->write($TCP_DATA, pack("w", $forward->{id}), $forward->{in});
    $forward->{in} = "";
}

sub eof : method {
    my $forward = shift;

    if ($forward->{socket_out}) {
        $forward->info("@_: Shutdown read, stop writing to remote") if $verbose > 1;
        if (shutdown(delete $forward->{socket_in}, 0)) {
            # Tell the other side that we won't send any more data
            $forward->{parent}->write($TCP_EOF, pack("w", $forward->{id}));
            # Keep writing
            return
        }
        $! == ENOTCONN || $forward->die("Could not shutdown read: $^E");
        # Get error status of socket here ?
        @_ = "Lost connection";
    }
    # We already stopped writing. We are now completely useless
    $forward->info("@_") if $verbose > 1;
    $forward->finished_local(@_);
}

sub write_end {
    my ($forward) = @_;

    if ($forward->{socket_in}) {
        # this implies we are connected and did not yet get EOF
        $forward->info("Shutdown write, keep reading") if $verbose > 1;
        shutdown($forward->{socket_out}, 1) ||
            $forward->die("Could not shutdown write: $^E");
        delete $forward->{socket_out};
        # Keep reading
    } else {
        # !$forward->{local} implies we are connecting. Abort connect
        delete @$forward{qw(socket_out timeout writer)} if !$forward->{local};
        # We already stopped reading. We are now completely useless
        $forward->finished_local($forward->{reason});
    }
}

# Tell remote to finish
sub finish_remote {
    my ($forward, $reason) = @_;

    $forward->info("Tell remote to finish after local $reason") if $verbose > 1;
    $forward->{parent}->write($TCP_FIN, pack("w", $forward->{id}), $reason);
}

# Tell local to finish
sub finish_local {
    my $forward = shift;

    $forward->{reason} = "@_";
    $forward->{reader} = undef if delete $forward->{socket_in};

    # $forward->{local} implies we are connected
    if ($forward->{out} eq "" || !$forward->{local}) {
        $forward->local_end;
    } else {
        $forward->{on_written} = \&local_end;
    }
}

sub local_end {
    my ($forward) = @_;
    $forward->finished_local($forward->{reason});
}

sub error {
    my $forward = shift;

    $forward->info("Error: @_") if $verbose;
    $forward->finished_local(@_);
}

sub status {
    my ($forward, $control, $indent) = @_;

    my $name = $forward->name;
    $control->{out} .= "$indent$name\n";
    $control->{out} .= "$indent  peer:   '$forward->{peer}{user}' [$forward->{peer}{display}]\n" if $forward->{peer};
    $control->{out} .= "$indent  local:  '$forward->{local}{user}' [$forward->{local}{display}]\n" if $forward->{local};
    $control->{out} .= "$indent  remote: '$forward->{remote}{user}' [$forward->{remote}{display}]\n" if $forward->{remote};
}

package Listener::Socks::Local;
# Listen for incoming socks connections
use vars qw(@ISA);
@ISA = qw(Listener);

sub new_suspended {
    my $class = shift;
    my $socks = $class->SUPER::new_suspended(@_);
    $socks->defer_accept;
    return $socks;
}

sub on_accept {
    my ($listener, $accepted, $local, $peer) = @_;

    # Peer is who is connecting to us
    # Local is where we got connected

    my $line = $listener->{parent};

    my $socks = Socks::Local->new(
        $line, undef, $peer,
        socket_in	=> $accepted,
        socket_out	=> $accepted,
        local		=> $local,
        state		=> \&Socks::Local::version,
        request		=> {
            seqno	=> 0,
            type	=> "tcp4",
        },
        finished_remote	=> "No remote (yet)",
    );
    $socks->info("Socks connect from %s", $peer->{display}) if $verbose > 1;
    return $socks;
}

package Socks::Forward;
# Process socks request (local side)
use vars qw(@ISA);
@ISA = qw(TCP::Forward);

sub new_suspended {
    my $class = shift;
    my $forward = $class->SUPER::new_suspended(@_);
    $forward->reclasify("TCP::Forward");
    return $forward;
}

sub _delete {
    my $forward = shift;
    bless $forward, "TCP::Forward";
    $forward->SUPER::_delete(@_);
}

package Socks::Local;
# Process socks request (local side)
use vars qw(@ISA);
@ISA = qw(Socks::Forward);

use Socket qw(inet_ntoa);

sub finish_remote {
    my $socks = shift;

    $socks->SUPER::finish_remote(@_) if $socks->{remote};
}

sub end_on_flushed {
    my $socks = shift;

    $socks->{state} = \&Connection::black_hole;
    $socks->SUPER::end_on_flushed(@_);
}

sub eof {
    my ($socks) = @_;

    $socks->finish_local("Unexpected EOF");
}

sub on_read {
    my ($socks) = @_;

    $socks->{state}->($socks);
}

sub version {
    my ($socks) = @_;

    return if $socks->{in} eq "";
    $socks->{request}{version} = ord substr($socks->{in}, 0, 1, "");
    if ($socks->{request}{version} == 4) {
        $socks->cmd4;
    } elsif ($socks->{request}{version} == 5) {
        $socks->greeting5;
    } else {
        $socks->{state} = \&state_bug;
        $socks->finish_local("Unknown SOCKS version $socks->{request}{version}");
        return;
    }
}

# For a better explanation of SOCKS4 than the wikipedia article see for example
# https://github.com/h12w/socks/blob/master/spec/SOCKS4.protocol.txt
sub cmd4 {
    my ($socks) = @_;

    if ($socks->{in} eq "") {
        $socks->{state} = \&cmd4;
        return;
    }
    $socks->{request}{cmd} = ord substr($socks->{in}, 0, 1, "");
    if ($socks->{request}{cmd} < 1 || $socks->{request}{cmd} > 2) {
        $socks->{state} = \&state_bug;
        $socks->finish_local("Unknown SOCKS4 command $socks->{request}{cmd}");
        return;
    }
    $socks->greeting4;
}

sub greeting4 {
    my ($socks) = @_;

    if (length $socks->{in} < 6) {
        $socks->{state} = \&greeting4;
        return;
    }
    @{$socks->{request}}{qw(port addr)} =
        unpack("na4", substr($socks->{in}, 0, 6, ""));
    $socks->username4;
}

sub username4 {
    my ($socks) = @_;

    if ($socks->{in} !~ s/^([^\0]*)\0//s) {
        $socks->{state} = \&username4;
        return;
    }

    $socks->{request}{username} = $1;
    if ($socks->{request}{addr} =~ /^\0\0\0[^\0]/) {
        $socks->greeting4a;
        return;
    }
    $socks->{request}{host} = inet_ntoa($socks->{request}{addr});
    $socks->execute();
}

sub greeting4a {
    my ($socks) = @_;

    if ($socks->{in} !~ s/^([^\0]*)\0//s) {
        $socks->{state} = \&greeting4a;
        return;
    }
    $socks->{request}{host} = $1;
    $socks->execute();
}

sub greeting5 {
    my ($socks) = @_;

    if ($socks->{in} eq "") {
        $socks->{state} = \&greeting5;
        return;
    }
    $socks->{request}{nauth} = ord substr($socks->{in}, 0, 1, "");
    $socks->auth5;
}

sub auth5 {
    my ($socks) = @_;

    if (length $socks->{in} < $socks->{request}{nauth}) {
        $socks->{state} = \&auth5;
        return;
    }
    $socks->{request}{auth} = substr($socks->{in}, 0, $socks->{request}{nauth}, "");

    if ($socks->{request}{auth} !~ /\0/) {
        $socks->end_on_flushed("User does not support 'No authentication'",
                               "\x05\xff");
        return;
    }
    $socks->write("\x05\x00");
    $socks->request5;
}

sub request5 {
    my ($socks) = @_;

    if (length $socks->{in} < 4) {
        $socks->{state} = \&request5;
        return;
    }
    my ($version, $cmd, $rsv, $type) = unpack("C4", substr($socks->{in}, 0, 4, ""));
    $socks->{request}{cmd} = $cmd;

    if ($version != 5) {
        $socks->{state} = \&state_bug;
        $socks->finish_local("Invalid version $version in client connection request");
        return;
    }
    my ($err, $msg);
    if ($rsv != 0) {
        $msg = "Unknown reserved byte '$rsv'";
        $err = 7; # protocol error
    } elsif ($cmd < 1 || $cmd > 2) {
        $msg = "Unknown command '$cmd'";
        $err = 7; # command not supported
    } elsif ($type == 1) {
        $socks->address_ipv4;
        return;
    } elsif ($type == 3) {
        $socks->address_name_len;
        return;
    } else {
        $msg = "Address type $type not supported";
        $err = 8; # address type not supported
    }
    # Error
    $socks->end_on_flushed("SOCKS5 request error: $msg",
                           pack("CCxCx6", 5, $err, 1));
}

sub address_ipv4 {
    my ($socks) = @_;

    if (length $socks->{in} < 4) {
        $socks->{state} = \&address_ipv4;
        return;
    }
    $socks->{request}{addr} = substr($socks->{in}, 0, 4, "");
    $socks->{request}{host} = inet_ntoa($socks->{request}{addr});
    $socks->port5;
}

sub address_name_len {
    my ($socks) = @_;

    if ($socks->{in} eq "") {
        $socks->{state} = \&address_name_len;
        return;
    }
    $socks->{request}{host_length} = ord substr($socks->{in}, 0, 1, "");
    $socks->address_name;
}

sub address_name {
    my ($socks) = @_;

    if (length $socks->{in} < $socks->{request}{host_length}) {
        $socks->{state} = \&address_name;
        return;
    }
    $socks->{request}{host} = substr($socks->{in}, 0, $socks->{request}{host_length}, "");
    $socks->port5;
}

sub port5 {
    my ($socks) = @_;

    if (length $socks->{in} < 2) {
        $socks->{state} = \&port5;
        return;
    }
    $socks->{request}{port} = unpack("n", substr($socks->{in}, 0, 2, ""));
    $socks->execute;
}

sub execute {
    my ($socks) = @_;

    my $request = delete $socks->{request};
    $request->{user} = $request->{display} = "$request->{host}:$request->{port}";
    if ($request->{cmd} == 1) {
        $request->{command} = "connect";
    } elsif ($request->{cmd} == 2) {
        $request->{command} = "bind";
    } elsif ($request->{cmd} == 3) {
        $request->{command} = "UDP relay";
        $request->{type} = "udp4";
    } else {
        $socks->bug("Unknown command '$request->{cmd}'");
    }

    $socks->info("User %srequests %s to %s using SOCKS%d%s",
                 defined $request->{username} ? "'$request->{username}' " : "",
                 $request->{command}, $request->{user}, $request->{version},
                 $request->{version} == 4 && $request->{addr} =~ /^\0\0\0[^\0]/ ? "a" : $request->{version} == 4 && !$request->{addr} ? "h" : "") if $verbose;

    if ($request->{port} == 0 && $request->{cmd} == 1) {
        $socks->end_on_flushed(
            "Cannot connect to port 0",
            $request->{version} == 4 ? pack("xCx6", 0x5B) :
            $request->{version} == 5 ? pack("CCxCx6", 5, 2, 1) :
            $socks->bug("Unknown SOCKS version '$request->{version}'"));
        return;
    }

    $socks->{parent}->write(
        $SOCKS, pack("www/a*a*", $socks->{id}, @$request{qw(cmd type display)}));
    $socks->{finished_remote} = undef;
    $socks->{remote} = $request;
    # To implement TCP::Forward::on_read pipelining we need to add
    # support for queueing EOF. Instead of setting state we could also check
    # for $socks->{remote} in on_read then call SUPER::on_read, bypassing state
    # $socks->{state} = \&TCP::Forward::on_read;
    $socks->{state} = \&no_input;
    $socks->{state}->($socks, length $socks->{in}) if $socks->{in} ne "";
}

sub no_input {
    my ($socks) = @_;

    $socks->{state} = \&state_bug;
    $socks->finish_local("Spurious input");
}

sub socks_result {
    my ($socks, $seqno, $status, $type, $address) = @_;

    my $remote = $socks->{remote};
    $seqno == ++$remote->{seqno} ||
        $socks->bug("Got result packet $seqno, expected $remote->{seqno}");

    if ($remote->{version} == 5) {
        $socks->write(pack("CCxCa4n", 5, $status, 1, @$address{qw(addr port)}));
    } elsif ($remote->{version} == 4) {
        $socks->write(
            pack("xCna4", $status ? 0x5B : 0x5A, @$address{qw(port addr)}));
    } else {
        $socks->bug("Unknown socks version $remote->{version}");
    }

    # No need for cleanup, the remote side has already sent us a TCP_FIN command
    # (which also includes the error reason)
    return if $status;

    if ($remote->{cmd} == 1) {
        $seqno == 1 || $socks->bug("Response packet $seqno");
    } elsif ($remote->{cmd} == 2) {
        return if $seqno == 1;
        $seqno == 2 || $socks->bug("Response packet $seqno");
        $socks->{remote} = $address->copy2($remote);
    } else {
        $socks->bug("Unimplemented SOCKS command '$remote->{cmd}'");
    }
    $socks->info("Become TCP::Forward[%s] after %s to '%s' [%s] succeeded",
                 $socks->id_full, $remote->{command},
                 $remote->{display}, $address->{display}) if $verbose > 1;
    $socks->suspend_read;
    bless $socks, "TCP::Forward";
    # Replace the reader by the one from TCP::Forward
    $socks->resume_read;
}

sub state_bug {
    shift->bug("Invalid socks state");
}

package Socks::Remote;
# Process socks request (remote side)
use vars qw(@ISA);
@ISA = qw(Socks::Forward);

package Socks::Connect;
# Process socks connect request (remote side)
use vars qw(@ISA);
@ISA = qw(Socks::Remote);

use Errno qw(ENETUNREACH EHOSTUNREACH ECONNREFUSED ETIMEDOUT);

my %SOCKS_STATUS = (
    ENETUNREACH()	=> 3,
    EHOSTUNREACH()	=> 4,
    ECONNREFUSED()	=> 5,
    ETIMEDOUT()		=> 6,
);

sub on_connect {
    my ($connect, $err) = @_;

    my $line = $connect->{parent};
    if ($err) {
        # Send peer as address. We don't HAVE a local and it can be interesting
        # to know what we actually tried to connect to
        $line->write($SOCKS_RESULT,
                     pack("wwww/a*a*", $connect->{id}, 1,
                          $SOCKS_STATUS{$err+0} || 1,
                          @{$connect->{peer}}{qw(type display)}));
        # This will call error() and cause a finish which must come AFTER write
        $connect->SUPER::on_connect($err);
    } else {
        # This will succeed and must come BEFORE write so we get "local"
        $connect->SUPER::on_connect(0);
        # Send "local" as address (as the RFC tells us we must)
        $line->write($SOCKS_RESULT,
                     pack("wwxw/a*a*", $connect->{id}, 1,
                          @{$connect->{local}}{qw(type display)}));
        $connect->info("Become TCP::Forward[%s] now that connect succeeded",
                      $connect->id_full) if $verbose > 1;
        bless $connect, "TCP::Forward"
    }
}

package Listener::Socks::Accept;
# Wait for a single incoming connection
use vars qw(@ISA);
@ISA = qw(Listener);

sub on_accept {
    my ($listener, $socket, $local, $peer) = @_;

    my $accept = $listener->{parent};
    my $line = $accept->{parent};

    if ($accept->{remote}{host} ne "0.0.0.0" &&
        $accept->{remote}{host} ne $peer->{host}) {
        # Paranoia as described in the SOCKS4 specification
        # Only accept connections from the same host that the request mentioned
        # as the destination
        # The SOCKS5 RFC doesn't mention this, but it seems like a good idea
        # A SOCKS4 description describes sending an error back to the client for
        # this case, but I don't want to shut the client down because somebody
        # else connected to the port (on the other hand maybe something is
        # genuinely asymetric and now the user will never know)
        $accept->info("Reject incoming connection from '$peer->{display}', does not match the expected host from '$accept->{remote}{user}' [$accept->{remote}{display}]") if $verbose;
        return;
    }
    $listener->delete("Acceptable connection");
    $accept->{local} = $local;
    $accept->{peer}  = $peer;
    $accept->{socket_in} = $accept->{socket_out} = $socket;
    # Send "peer" as address in the second result (as the RFC tells us we must)
    $line->write($SOCKS_RESULT,
                 pack("wwxw/a*a*", $accept->{id}, 2,
                      @$peer{qw(type display)}));
    $accept->info("Become TCP::Forward[%s] now that accept succeeded",
                  $accept->id_full) if $verbose > 1;
    bless $accept, "TCP::Forward";
    $accept->resume_read;
}

package Socks::Accept;
# Do the SOCKS bind operation (remote side)
use vars qw(@ISA);
@ISA = qw(Socks::Remote);

sub new_suspended {
    my $class = shift;
    my $line  = shift;
    my $accept = $class->SUPER::new_suspended($line, @_);

    # Many (all ?) socks clients don't properly fill the host they want as peer.
    # Instead they just pass where they want to bind. In that case use that
    my $local = $accept->{remote};
    if ($local->{host} ne "0.0.0.0") {
        # Proper client
        $local = ConnUtils->socket_udp_connected($accept->{remote}, 1);
        if (ref $local eq "") {
            # UDP connect failed, errno in $local
            $line->write($SOCKS_RESULT,
                         pack("wwww/a*a*", $accept->{id}, 1,
                              $SOCKS_STATUS{$local+0} || 1,
                              @{$accept->{remote}}{qw(type display)}));
            $accept->error("Failed UDP probe connect to '$accept->{remote}{display}': $local");
            return undef;
        }
        # Local contains the local address as the result of a probe UDP connect
        # The port is meaningless, we want to do a local bind for TCP instead
        $local->{type} = "tcp4";
        $local->{port} = 0;
        # This will not actually look up anything since all addresses and ports
        # are numeric. But it will properly fill in all fields
        $local->resolve("SOCKS");
    }

    # Don't set loops = 1. We may reject some incoming connections
    my $listener = eval { Listener::Socks::Accept->new($accept, $local) };
    if ($@) {
        # bind/listen failed, errno in $!
        my $err = $@;
        $err =~ s/\sat\s.*//s;
        $line->write($SOCKS_RESULT,
                     pack("wwww/a*a*", $accept->{id}, 1,
                          $SOCKS_STATUS{$!+0} || 1,
                          @{$accept->{remote}}{qw(type display)}));
        $accept->error($err);
        return undef;
    }
    # Listener did a bind, so at least the port is filled in now
    $accept->{local} = $listener->{local};
    $line->write($SOCKS_RESULT,
                 pack("wwxw/a*a*", $accept->{id}, 1,
                      @{$listener->{local}}{qw(type display)}));
    # We expect Response -> client, client -> application server (through SOCKS)
    # and application server -> our socket. Let's give it ... two connect times
    $accept->timer($line->{settings}{TIMEOUT_CONNECT} * 2, \&accept_timeout);
    return $accept;
}

sub accept_timeout {
    my ($accept) = @_;

    # 6 = TTL expired which is typically interpreted as "timeout" by the client
    # We have nothing sane to put in the address, so just punt with remote
    $accept->{parent}->write($SOCKS_RESULT,
                             pack("wwww/a*a*", $accept->{id}, 2,
                                  6, @{$accept->{remote}}{qw(type display)}));
    $accept->error("Accept timed out");
}

package LineProtocol;
# Handle traffic between client and server
use vars qw(@ISA);
@ISA = qw(Stream);

use FindBin qw($Script);
use Errno qw(EINTR EAGAIN EWOULDBLOCK);
use Socket qw(inet_ntoa);
use Scalar::Util qw(weaken);
use Carp qw(croak);
use Digest::MD5 qw(md5);

use constant {
    ACK_MASK	=> 0xffffffff,
};

my %process_name = (
    $SET		=> "SET",
    $START		=> "START",
    $KEEP		=> "KEEP",
    $FOU_REMOTE		=> "FOU_REMOTE",
    $UDP_DATA		=> "UDP_DATA",
    $PING		=> "PING",
    $RESPONSE_UDP	=> "RESPONSE_UDP",
    $RESPONSE_PING	=> "RESPONSE_PING",
    $CONNECT		=> "CONNECT",
    $CONNECT_REMOTE	=> "CONNECT_REMOTE",
    $LISTEN_REMOTE	=> "LISTEN_REMOTE",
    $TCP_DATA		=> "TCP_DATA",
    $TCP_EOF		=> "TCP_EOF",
    $TCP_FIN		=> "TCP_FIN",
    $SOCKS		=> "SOCKS",
    $SOCKS_REMOTE	=> "SOCKS_REMOTE",
    $SOCKS_RESULT	=> "SOCKS_RESULT",
);

my %process = %process_name;
$_ = __PACKAGE__->can("process_$_") || die "Unknown sub 'process_$_'" for
    values %process;

sub new_suspended {
    my $class		= shift;
    my $parent		= shift;
    my $socket_in	= shift;
    my $socket_out	= shift;

    my $line = $class->SUPER::new_suspended(
        $parent, $socket_in, $socket_out,
        settings	=> { %{$parent->{settings}} },
        started		=> undef, # Normal operations started
        utime_offset	=> 0,	# Estimated round trip time in microsecond
        keepalive	=> undef,
        map_udp		=> {},
        seqno_echo	=> 0,
        unacked		=> 0,
        in_acked	=> 0,
        out_sent	=> 0,
        out_base	=> 0,
        ping_queued	=> [],
        @_);
    my $ids2 = Ids2->new;
    # These classes share the Ids2 object since they can be reblessed
    $line->ids_set(
        "TCP::Forward"	=> $ids2,
        "Socks::Local"	=> $ids2,
        "Socks::Connect"=> $ids2,
        "Socks::Accept"	=> $ids2,
    );
    return $line;
}

sub error {
    my $line = shift;

    $line->info("Error: @_") if $verbose;
    $line->delete(@_);
}

sub on_read {
    my ($line, $rc) = @_;

    $line->{unacked} += $rc;
    $line->keepalive() if $line->{unacked} >= $line->{settings}{ACK_LIMIT};

    while ($line->{in} =~ /^([\x80-\xff]{0,2}[\x00-\x7f].)/s) {
        my ($length, $command) = unpack("wa", $line->{in});
        last if length($line->{in}) < $length;
        my $message = substr($line->{in}, 0, $length, "");
        substr($message, 0, length $1, "");
        $line->info("Processing %s: %s",
                    $process_name{$command} || "Unknown command $command",
                    ::display($message)) if $verbose > 1;
        my $fun = $process{$command} ||
            die "No handler for proto '$command'";
        $fun->($line, $message, $command);
    }
}

sub writing {
    my ($line) = @_;

    return if $line->{unwritable};
    $line->{writer} ||= Events::add_write($line->{socket_out}, $line, \&writer);
    $line->{timeout} = Timer::timer($line->{settings}{TIMEOUT},
                                    $line, \&_Stream::timeout);
}

sub write : method {
    my $line = shift;
    my $command = shift;

    my $length = 2;
    $length += length for @_;
    ++$length if $length >= 128;
    ++$length if $length >= 128*128;
    # Don't accept more than 3 BER bytes (~ 2**21 byte message)
    croak "Message too long" if $length >= 128*128*128;

    $line->{out} .= pack("wa", $length, $command);
    $line->{out} .= $_ for @_;
    # $line->info("Constructed %s: %s", $command, unpack("H*", substr($line->{out}, -$length)));

    if ($line->{out_sent} + $length == length $line->{out}) {
        $line->{keepalive} = undef;
        $line->writing;
    }
    return $length;
}

sub writer {
    my ($line) = @_;

    while (1) {
        my $rc = syswrite($line->{socket_out}, $line->{out}, $BLOCK_SIZE, $line->{out_sent});
        if (!$rc) {
            $line->die("Zero write. Is this even possible ?") if defined $rc;
            if ($! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK) {
                $line->{timeout} ||= Timer::timer($line->{settings}{TIMEOUT},
                                                  $line, \&timeout);
            } else {
                $line->error("Could not write to $role_peer: $^E");
            }
            return;
        }
        $line->info("Wrote to %s: %s (%d left)",
                    $role_peer,
                    ::display(substr($line->{out}, $line->{out_sent}, $rc)),
                    length($line->{out})-$line->{out_sent}-$rc) if $verbose > 1;

        $line->{timeout} = undef;
        $line->{out_sent} += $rc;
        if (length $line->{out} == $line->{out_sent}) {
            $line->{writer} = undef;
            $line->{keepalive} =
                $line->timer($line->{settings}{KEEPALIVE}, \&keepalive);
            return;
        }
    }
}

sub ready {
    my ($line, $msg, $peer_msg) = @_;

    if ($verbose) {
        ::peer_info($peer_msg) if $line->{client_only};
        if ($verbose > 1) {
            $line->info($msg);
        } else {
            ::info($msg);
        }
        # Add extra line to make this stand out
        print STDERR "\n";
    }
    $line->activate_read;
}

sub activate_read {
    my $line = shift;

    my $children = $line->{children} || return;
    for my $class (sort keys %$children) {
        $class->isa("_Listener") || $class->isa("_UDP") || next;
        $_ && $_->resume_read for @{$children->{$class}};
    }
}

sub keepalive {
    my ($line) = @_;

    $line->info("Sending KEEPALIVE/ACK %d (new base %d)",
                $line->{unacked},
                $line->{in_acked} + $line->{unacked} & ACK_MASK) if $verbose > 1;
    die "Assertion: Unacked $line->{unacked} is out of range" if
        $line->{unacked} > 0xffffffff;
    my $msg = sprintf("%.0f\0%0.f\0%s",
                      (Timer->realtime() - $BASE_TIME)*1e6,
                      $line->{utime_offset}, pack("V", $line->{unacked}));
    $msg =~ s/\0+\z//;
    my $length = $line->write($KEEP, $msg);
    if ($length >= $line->{settings}{ACK_LIMIT}) {
        $line->{settings}{ACK_LIMIT} = ++$length;
        $line->info("Increasing ACK_LIMIT to $length") if $verbose;
    }
    $line->{in_acked} = $line->{in_acked} + $line->{unacked} & ACK_MASK;
    $line->{unacked} = 0;
}

sub ping_activate {
    my ($line, $icmp) = @_;

    if (@{$line->{ping_queued}} || !$line->{parent}->ping_activate($line, $icmp)) {
        weaken($line->{ping_queued}[@{$line->{ping_queued}}] = $icmp);
        return 0;
    }
    return 1;
}

sub ping_finished {
    my ($line, $root) = @_;

    while (@{$line->{ping_queued}}) {
        my $icmp = shift @{$line->{ping_queued}} || next;
        weaken($line->{ping_queued}[@{$line->{ping_queued}}] = $icmp) if
            $icmp->ping_finished($line, $root);
        return scalar @{$line->{ping_queued}};
    }
    return 0;
}

sub status {
    my ($line, $control, $indent) = @_;

    #local $Data::Dumper::Varname = "VAR";
    #my $settings = ::Dumper($line->{settings});
    #$settings =~ s/\$VAR1 = //g || die "Assertion: No VAR1";
    #$settings =~ s/\s+\z//;
    my $name = $line->name;
    my $settings = ::string_from_value($line->{settings});
    $settings =~ s/\n/\n$indent  /g;

    $control->{out} .= <<"EOF"
$indent$name
$indent  Settings: $settings
EOF
        ;
}

sub process_SET {
    my $line  = shift;

    my $i = unpack("C", substr($_[0], 0, 1, ""));
    my $name = $setting_ids[$i] || die "Unknown variable $i";
    # At the moment all values are numbers
    $line->{settings}{$name} = $_[0] =~ /^0\z|^[1-9][0-9]*\z/ ? int($_[0]) : $_[0];
    $line->info("Set %s=%s", $name, $_[0]) if $verbose > 1;
}

sub process_START {
    my $line  = shift;

    defined $line->{settings}{EPOCH} || die "Lost early epoch message";

    $line->{started} = 1;

    my $msg = "$Script $role $me\@$hostname ready (clock $CLOCK_TYPE_NAME, pid $$)";

    $line->write($START, $msg) if $role eq "server";
    $line->ready($msg, shift);
}

sub process_KEEP {
    my $line  = shift;

    # Transit time is of course meaningless if the clocks aren't
    # synchronized very well. offset tries to compensate for that

    # add 5 \0 in case they were trimmed (1 for the last Z and 4 for V)
    my ($utime, $uoffset, $acked) = unpack("Z*Z*V", shift() . "\0" x 5);

    die "Assertion: Impossible ACK" if $acked > $line->{out_sent};
    substr($line->{out}, 0, $acked, "");
    $line->{out_sent} -= $acked;
    $line->{out_base} = $line->{out_base} + $acked & ACK_MASK;

    # uoffset has     peertime - mytime + transit_time (me -> peer)
    # This calculates mytime - peertime + transit_time (peer -> me)
    $line->{utime_offset} = (Timer->realtime() - $line->{settings}{EPOCH})*1e6 -$utime || 1;
    $line->info("Received ACK=%d (base=%d, sent=%d), Keepalive transit=%.3f ms" .
                ($uoffset ? ", roundtrip=%.3f ms, offset=%.0f ms" : ""),
                $acked, $line->{out_base}, $line->{out_sent},
                $line->{utime_offset}/1e3,
                $uoffset ? (
                    ($line->{utime_offset}+$uoffset)/1e3,
                    ($line->{utime_offset}-$uoffset)/2e3) : ()) if $verbose > 1;
}

sub process_FOU_REMOTE {
    my ($line, $udp) = @_;

    my ($from, $to) =
        $udp =~ m{^([^%]+)%([^%]+)\z} or
        die "Invalid fou_remote '$udp'";
    $from = Address->parse($from, "FOU remote", from => "UDP4");
    $to   = Address->parse($to  , "FOU remote", to   => "UDP4", resolve => 1);

    my $fou = Fou::UDP->new($to);
    my $listener = Receiver::Fou->new($line, $from->{host}, $from->{port}, $fou);
}

sub process_UDP_DATA {
    my $line = shift;
    my ($id, $dst, $port, $ttl, $data) = unpack("wa4nCa*", shift);
    $id || die "Assertion: Sender socket id $id == 0";
    $id <= $line->{settings}{UDP_MAX} ||
        die "Assertion: Sender socket id $id > $line->{settings}{UDP_MAX}";
    $line->info("Need to send UDP data (TTL %d) from socket %d to %s:%d: %s",
                $ttl, $id, inet_ntoa($dst), $port, ::display($data)) if $verbose > 1;
    my $sender = $line->child("Sender::UDP", $id) ||
        Sender::UDP->new($line, $id);
    $sender->write($port, $dst, $data, $ttl);
}

sub process_RESPONSE_UDP {
    my $line = shift;

    my ($id, $nsrc, $sprt, $ttl, $data) = unpack("wa4nCa*", shift);
    $id || die "Assertion: Sender socket id $id == 0";
    $id <= $line->{settings}{UDP_MAX} ||
        die "Assertion: Sender socket id $id > $line->{settings}{UDP_MAX}";
    my $src = inet_ntoa($nsrc);
    $line->info("\u$role_peer received UDP data on socket %d from %s:%d: %s",
                $id, $src, $sprt, ::display($data)) if $verbose > 1;
    my $map_src = $line->{map_udp}{"$src:$sprt"};
    if (!$map_src) {
        # We should rate limit this message if $verbose == 1
        $line->info("No map for $src:$sprt. Dropping packet") if $verbose;
        return;
    }
    my $map = $map_src->[2][$id] || die "Assertion: No Sender socket[$id]";
    $map->{seq} = $map_src->[0]++;
    die "Too many packets from $src:$sprt" if $map->{seq} == $map_src->[0];
    my $fou = $root->child("Fou::UDP", $map->{fou_id}) ||
        die "Assertion: No Fou::UDP with id '$map->{fou_id}'";
    my $ndst = $map->{addr};
    my $dprt = $map->{port};

    # Build FOU IP packet

    # Packet ID is meaningless for atomic packets (RFC 6864)
    my $packet_id = int rand 2**16;
    my $flags = $DF;

    my $length = length($data);
    my $new_length = $length + $IHL * 4 + $UDP_HEADER;
    # Currently we don't handle overly large FOU packets
    if ($new_length >= 2**16) {
        $line->info("Cannot build oversized FOU packet. Dropped") if $verbose > 1;
        return;
    }

    my $header = pack("CCnnnCCx2a4a4",
                      $IP_VERSION << 4 | $IHL,
                      0,
                      $new_length,
                      $packet_id,
                      $DF << 13 | 0,
                      $ttl,
                      $PROTO_UDP,
                      $nsrc,
                      $ndst,
                  );
    my $sum = unpack("%32n*", $header);
    while ($sum > 0xffff) {
        my $carry = $sum >> 16;
        $sum &= 0xffff;
        $sum += $carry;
    }
    substr($header, 10, 2, pack("n", 0xffff - $sum));

    my $pseudo10 = pack("a4a4xC", $nsrc, $ndst, $PROTO_UDP);
    my $udp_header = pack("nnn", $sprt, $dprt, $length + $UDP_HEADER);
    # Temporarily add a 0 byte so we can do even padding
    $data .= "\0";

    $sum = unpack("%32n*", $pseudo10) + unpack("%32n*", $udp_header) + unpack("%32n*", $data) + $length + $UDP_HEADER;

    while ($sum > 0xffff) {
        my $carry = $sum >> 16;
        $sum &= 0xffff;
        $sum += $carry;
    }
    chop $data;
    my $buffer = $header . $udp_header . pack("n", 0xffff - $sum || 0xffff) . $data;

    if (0) {
        my $buf = $buffer;
        # For FOU packet construction debug
        my ($ihl, $ecn, $length, $packet_id, $fragment, $ttl, $proto, $chksum, $src, $dst) = unpack("CCnnnCCna4a4", $buf);
        my $version = $ihl >> 4;
        $ihl &= 0xf;
        my $flags = $fragment >> 13;
        $fragment &= 0x1fff;
        # only TCP4
        $version == $IP_VERSION || die "Wrong version $version";
        # Only UDP
        $proto == $PROTO_UDP || die "Wrong proto $proto";
        # Sanity check on buffer
        length($buf) == $length ||
            die "Wrong length ", length($buf);
        # We don't handle IP options (yet)
        $ihl == $IHL || die "Wrong ihl $ihl";
        # Too many hops
        $ttl || die "Bad TTL $ttl";
        # Don't handle fragments (fragment offset)
        die "Unexpected fragment $fragment" if $fragment;
        # Don't handle fragments (MF flag set)
        die "Bad flags $flags" if $flags & 0x1;

        my $pseudo10 = pack("a4a4xC", $src, $dst, $proto);

        $ihl *= 4;
        my $header = substr($buf, 0, $ihl, "");
        $length -= $ihl;

        # No buffer padding needed since length($header) is even
        my $sum = unpack("%32n*", $header);
        while ($sum > 0xffff) {
            my $carry = $sum >> 16;
            $sum &= 0xffff;
            $sum += $carry;
        }
        $sum == 0xffff || die "Bad IP checksum $sum";

        $src = inet_ntoa($src);
        $dst = inet_ntoa($dst);

        my $dscp = $ecn >> 3;
        $ecn &= 0x7;
        $line->info("HEADER: DSCP=$dscp, ECN=$ecn, ID=$packet_id, FLAGS=$flags, FRAGMENT=$fragment, TTL=$ttl, CHKSUM=$chksum, SUM=$sum, SRC=$src, DST=$dst");

        # Must have space for UDP header
        die "Bad UDP length $length" if $length < $UDP_HEADER;

        # Pad buffer 0 so a last single byte still gets processed as "n"
        $sum = unpack("%32n*", $buf . "\x0") + unpack("%32n*", $pseudo10) + $length;
        my ($sprt, $dprt, $udp_len, $udp_chksum) = unpack("nnnn", substr($buf, 0, $UDP_HEADER, ""));
        $udp_len == $length || die "Inconsistent UDP length";
        $length -= $UDP_HEADER;

        if ($udp_chksum) {
            while ($sum > 0xffff) {
                my $carry = $sum >> 16;
                $sum &= 0xffff;
                $sum += $carry;
            }
            $sum == 0xffff || die "Bad UDP chksum $sum";
        }

        ::info("SPRT=$sprt, DPRT=$dprt, LEN=$udp_len, CHK=$udp_chksum");
    }
    $line->info("Queue UDP packet (TTL %d) for %s: %s:%d -> %s:%d",
                $ttl, $fou->name, $src, $sprt, $map->{host}, $map->{port})
        if $verbose > 1;
    $fou->write($buffer, $ttl);
}

sub process_PING {
    my $line = shift;
    my ($id, $dst, $seqno, $ttl, $data) = unpack("wa4nCa*", shift);
    # Currently we only ever use one pinger
    $id == 1 || die "Assertion: Pinger socket id $id != 1";
    # debug info is written by $pinger->write
    my $pinger = $line->child("Sender::ICMP", $id) ||
        Sender::ICMP->new($line, $id);
    $pinger->write($dst, $seqno, $data, $ttl);
}

sub process_RESPONSE_PING {
    my $line = shift;

    my ($id, $nsrc, $ttl, $buffer) = unpack("wa4Ca*", shift);
    my $md5 = substr($buffer, 0, 16, $SECRET);
    md5($buffer) eq $md5 || return;
    my ($ndst, $icmp_id, $seqno, $fou_id, $data) =
        unpack("x20a4n2wa*", $buffer);
    my $fou = $root->child("Fou::UDP", $fou_id) ||
        die "Assertion: No Fou::UDP with id '$fou_id'";

    # Build FOU IP packet
    my $ip_len = $IHL * 4;
    $buffer = pack("x${ip_len}CCx2nna*x", $ICMP_ECHO_REPLY, 0, $icmp_id, $seqno, $data);
    my $new_length = length($buffer)-1;
    substr($buffer, 0, $ip_len, "");
    my $sum = unpack("%32n*", $buffer);
    chop $buffer;
    while ($sum > 0xffff) {
        my $carry = $sum >> 16;
        $sum &= 0xffff;
        $sum += $carry;
    }
    substr($buffer, 2, 2, pack("n", 0xffff - $sum));

    # Packet ID is meaningless for atomic packets (RFC 6864)
    my $packet_id = int rand 2**16;
    my $header = pack("CCnnnCCx2a4a4",
                      $IP_VERSION << 4 | $IHL,
                      0,
                      $new_length,
                      $packet_id,
                      $DF << 13 | 0,
                      $ttl,
                      $PROTO_ICMP,
                      $nsrc,
                      $ndst,
                  );
    $sum = unpack("%32n*", $header);
    while ($sum > 0xffff) {
        my $carry = $sum >> 16;
        $sum &= 0xffff;
        $sum += $carry;
    }
    substr($header, 10, 2, pack("n", 0xffff - $sum));
    substr($buffer, 0, 0, $header);

    # $buffer = pack("x${ip_len}CCx2nna*x", $ICMP_ECHO_REPLY, 0, $icmp_id, $seqno, $data);

    $fou->info("Queue ICMP packet %s -> %s (TTL %d, Type %d, Code %d, Id %d, Seqno %s): %s",
           inet_ntoa($nsrc), inet_ntoa($ndst), $ttl,
           $ICMP_ECHO_REPLY, 0, $icmp_id, $seqno, ::display($data)) if $verbose > 1;
    $fou->write($buffer, $ttl);
}

sub process_LISTEN_REMOTE {
    my $line = shift;

    my ($id, $type, $from) = unpack("ww/a*a*", shift);
    $from = Address->parse($from, "TCP remote", from => $type, resolve => 1);
    Listener::TCP::Remote->new_suspended($line, $from, id => $id);
}

sub process_CONNECT {
    my $line = shift;

    my ($id, $type, $target) = unpack("ww/a*a*", shift);

    my $to = Address->parse($target, "TCP connect",
                            to => $type, resolve => 1);
    TCP::Forward->new($line, undef, $to, id => $id);
}

sub process_CONNECT_REMOTE {
    my $line = shift;

    my ($id, $remote_id, $address) = unpack("wwa*", shift);
    $address = Address->decode($address, "stream");
    my $tcp_remote = $line->child("TCP::Remote", $remote_id) ||
        $line->bug("Unknown TCP::Remote[$remote_id]");
    my $to = $tcp_remote->{remote}->copy0_resolve($address);
    TCP::Forward->new($line, undef, $to, id => $id);
}

sub process_TCP_DATA {
    my $line = shift;

    my ($id, $pos) = unpack("w.", $_[0]);
    substr($_[0], 0, $pos, "");
    my $forward = $line->child("TCP::Forward", $id) ||
        $line->bug("Could not find TCP::Forward[$id]");
    $forward->write(shift) unless $forward->{finished};
}

sub process_TCP_EOF {
    my $line = shift;

    my $id = unpack("w", shift);
    my $forward = $line->child("TCP::Forward", $id) ||
        $line->bug("Could not find TCP::Forward[$id]");
    $forward->_end_on_flushed("Remote EOF") unless $forward->{finished};
}

sub process_TCP_FIN {
    my $line = shift;

    my ($id, $msg) = unpack("wa*", shift);
    my $forward = $line->child("TCP::Forward", $id) ||
        $line->bug("Could not find TCP::Forward[$id]");
    $forward->finished_remote($msg);
}

sub process_SOCKS {
    my $line = shift;

    my ($id, $cmd, $type, $target) = unpack("www/a*a*", shift);
    if ($cmd == 1) {
        my $to = Address->parse($target, "SOCKS connect",
                                to => $type, resolve => 1);

        Socks::Connect->new($line, undef, $to, id => $id);
    } elsif ($cmd == 2) {
        my $to = Address->parse($target, "SOCKS bind",
                                          to => $type, resolve => 1);
        # Just new would also suspend since we pass no peer, so no connect()
        Socks::Accept->new_suspended($line, undef, undef, id => $id, remote => $to);
    } else {
        $line->bug("Unknown socks command '$cmd'");
    }
}

sub process_SOCKS_RESULT {
    my $line = shift;

    my ($id, $seqno, $status, $type, $address) = unpack("wwww/a*a*", shift);
    my $socks_local = $line->child("TCP::Forward", $id) ||
        $line->bug("Could not find Socks::Local[$id]");
    $address = Address->parse($address, "SOCKS local", from => $type, resolve => 1);
    $socks_local->socks_result($seqno, $status, $type, $address);
}

sub process_SOCKS_REMOTE {
    my $line = shift;

    my ($type, $from) = unpack("w/a*a*", shift);
    $from = Address->parse($from, "SOCKS local", from => $type, resolve => 1);
    Listener::Socks::Local->new_suspended($line, $from);
}

sub set_peer {
    my ($line, $name, $value) = @_;

    my $i = $setting_ids{$name};
    defined $i || croak "Unknown global variable '$name'";
    if (!defined $value) {
        defined($value = $line->{settings}{$name}) ||
            die "Assertion: Setting '$name' to undef";
    }
    $line->write($SET, pack("w", $i), $value);
}

package _Listener;
# Listen for incoming connections and start new Connections for them
use vars qw(@ISA);
@ISA = qw(Object);

use Errno qw(EINTR EAGAIN EWOULDBLOCK ECONNABORTED);

sub new_suspended {
    my $class = shift;
    my $parent = shift;
    my $address = shift;	# (Currently) assumed to be resolved

    my %args = (
        local	=> $address,
        loops	=> -1,
        socket	=> undef,
        reader	=> undef,
        @_
    );
    @args{qw(local socket)} = $parent->socket_tcp($args{local}, 1) if
        !$args{socket};
    my $listener = $class->SUPER::new($parent, %args);
    $listener->info("Listening on '%s' [%s]",
                    @{$listener->{local}}{qw(user display)}) if
                        $listener->{local}{user} =~ /:0$/ || $verbose > 1;
    return $listener;
}

sub new {
    my $class = shift;

    my $listener = $class->new_suspended(@_);
    $listener->resume_read;
    return $listener;
}

sub defer_accept {
    ConnUtils->defer_accept(shift->{socket});
}

sub _finish {
    my $listener = shift;

    delete @$listener{qw(reader socket)};
    $listener->SUPER::_finish(@_);
}

sub acceptable {
    my ($listener) = @_;

    my $peer = accept(my $accepted, $listener->{socket});
    if (!$peer) {
        return if $! == EINTR || $! == EAGAIN || $! == EWOULDBLOCK || ECONNABORTED;
        die "Accept failed: $^E";
    }
    $listener->delete("Maximum connections") if --$listener->{loops} == 0;
    my $packed = getsockname($accepted) ||
        die "Assertion: Could not getsockname(): $^E";
    my $local =
        Address->from_packed($packed, "tcp4")->copy2($listener->{local});
    $peer = Address->from_packed($peer, "tcp4");
    $listener->info("Accepted connection from '%s:%d' to '%s' [%s]",
                    @$peer{qw(host port)}, @$local{qw(user display)}) if $verbose;
    $listener->tcp_set($accepted);
    $listener->on_accept($accepted, $local, $peer);
}

sub on_accept {
    my $listener = shift;
    my $accepted = shift;

    my ($target) = ref($listener) =~ /^Listener::(.*)\z/ or
        die "Assertion: Could not parse class of '$listener'";
    $target->new($listener->{parent}, $accepted, $accepted, $listener, @_);
}

sub suspend_read {
    my $listener = shift;

    $listener->info("suspend_read") if $verbose > 1;
    $listener->{reader} || $listener->die("Read already suspended");
    $listener->{reader} = undef;
}

sub status {
    my ($listener, $control, $indent) = @_;

    my $name = $listener->name;

    $control->{out} .= <<"EOF"
$indent$name
$indent  Loops: $listener->{loops}
$indent  Local Listen on '$listener->{local}{user}' [$listener->{local}{display}]
EOF
        ;
}

package Listener;
# Listeners that keep the program alive
use vars qw(@ISA);
@ISA = qw(_Listener);

sub resume_read {
    my $listener = shift;

    $listener->info("resume_read") if $verbose > 1;
    $listener->{reader} && $listener->die("Read not suspended");
    $listener->{reader} = Events::add_read($listener->{socket}, $listener, \&_Listener::acceptable);
}

package Listener0;
# Listeners that don't keep the program alive
use vars qw(@ISA);
@ISA = qw(_Listener);

sub resume_read {
    my $listener = shift;

    $listener->info("resume_read") if $verbose > 1;
    $listener->{reader} && $listener->die("Read not suspended");
    $listener->{reader} = Events::add_read0($listener->{socket}, $listener, \&_Listener::acceptable);
}

package Listener::Control;
# Wait for incoming Control connections
use vars qw(@ISA);
@ISA = qw(Listener0);

package Control;
# Communicate with a Controller
use vars qw(@ISA);
@ISA = qw(Stream0);

my %commands = (
    "?"		=> \&command_help,
    help	=> \&command_help,
    status	=> \&command_status,
    set		=> \&command_set,
    finish	=> \&command_finish,
    dump	=> \&command_dump,
    events	=> \&command_events,
    pid		=> \&command_pid,
    quit	=> \&command_exit,
    exit	=> \&command_exit,
);

sub new_suspended {
    my ($class, $line, $term_in, $term_out, $listener, $local, $peer) = @_;

    $line || die "Assertion: No line";

    $term_in  = \*STDIN  if !defined $term_in;
    $term_out = \*STDOUT if !defined $term_out;
    # STDIN and/or STDOUT can be $null if the program was called with closed
    # STDIN and/or STDOUT
    die "Input is NULL" if fileno($term_in)  == fileno($null);
    die "Ouput is NULL" if fileno($term_out) == fileno($null);
    $term_in ->blocking(0) if fileno($term_in ) == fileno(STDIN);
    $term_out->blocking(0) if fileno($term_out) == fileno(STDOUT);

    return $class->SUPER::new_suspended(
        $line, $term_in, $term_out,
        local	=> $local,
        peer	=> $peer,
        exit	=> fileno($term_in ) == fileno(STDIN));
}

sub _delete {
    my $control = shift;

    $control->SUPER::_delete(@_);
    ::cleanup_all() if $control->{exit};
}

sub error {
    my $control = shift;
    $control->info("Error: @_") if $verbose;
    $control->delete(@_);
}

sub eof : method {
    my ($control, $msg) = @_;

    $control->info($msg) if $verbose > 1;
    $control->end_on_flushed($msg);
}

sub on_read {
    my ($control, $rc) = @_;

    my $len = length($control->{in});
    index($control->{in}, "\n", $len - $rc) >= 0 || return;
    while ($control->{in} =~ s/^(.*)\n//) {
        my ($command, @args) = split " ", $1 or next;
        next if $command =~ m{^#|^//|^--};
        my $fun = $commands{lc $command};
        if (!$fun) {
            $control->{out} .= "Unknown command '$command'\n";
            $control->flush;
            next;
        }
        $fun->($control, $command, @args);
    }
    $control->writing if $control->{out} ne "" && !$control->{writer};
}

sub flush {
}

sub command_help {
    my ($control) = @_;

    $control->{out} .= <<"EOF"
quit               Close connection
exit               Close connection
dump               Dump internal datastructure
events             Dump internal Events
finish             End the program
help, ?            Show this help
pid                Show program pid
set {var=value}    Set variables
status             Show connections status
EOF
        ;
    $control->flush;
}

sub command_status {
    my ($control) = @_;

    my $msghdr = $msghdr_error || Socket::MsgHdr->VERSION;

    my $rlwrap = $ENV{sssssh_rlwrap} || 0;
    $control->{out} .= <<"EOF"
Local:
  Script $::Script (pid $$)
  VERSION $VERSION
  PROTOCOL $PROTOCOL
  Host $hostname
  User $me ($>)
  Socket::MsgHdr $msghdr
  rlwrap $rlwrap
  verbose=$verbose
EOF
        ;
    $root->status_all($control, "  ");
    $control->flush();
}

sub command_set {
    my $control = shift;
    shift;

    if (@_) {
        for my $arg (@_) {
            if ($arg =~ /^verbose=((?:0|[1-9]\d*))\z/ia) {
                $verbose = int $1;
            } else {
                $control->{out} .= "Invalid $arg\n";
            }
        }
    } else {
        $control->{out} .= "Missing arguments";
    }
    $control->flush();
}

sub command_exit {
    my ($control, $command) = @_;

    $control->{out} .= "OK\n";
    $control->flush();
    $control->end_on_flushed("Command '$command'");
}

sub command_finish {
    my $control = shift;

    ::cleanup_all();
    $control->command_exit(@_);
}

sub command_dump {
    my ($control) = @_;

    $control->{out} .= ::Dumper($root);
    $control->flush();
}

sub command_events {
    my ($control) = @_;

    $control->{out} .= Events::events();
    $control->flush();
}

sub command_pid {
    my ($control) = @_;

    $control->{out} .= "$$\n";
    $control->flush();
}

package Listener::LineProtocol;
# Wait for incoming LineProtocol connections
use vars qw(@ISA);
@ISA = qw(Listener);

sub on_accept {
    my ($listener, $accepted) = @_;

    $listener->{parent}->server($accepted, $accepted);
}

package main;
use Scalar::Util qw(blessed);

sub object_name {
    my ($object) = @_;

    return display($object) if ref $object eq "";
    return $object->name if blessed($object) && $object->isa("Object");
    return ref $object;
}

sub _info {
    local ($!, $^E);
    my $role = ucfirst(shift);
    if (!@_) {
        my (undef, $filename, $line) = caller(1);
        @_ = ("$filename $line");
    }
    my $format = shift;
    $format =~ s/\n?\z/\n/;
    if (!@_) {
        @_ = ($format);
        $format = "%s";
    }
    my $time = Timer->realtime;
    my $itime = int($time);
    my ($sec, $min, $hour, $day, $mon, $year) = localtime($itime);
    my $gtime = timegm($sec, $min, $hour, $day, $mon, $year);
    my $offset = ($gtime - $itime) / 60;
    my $sign = "+";
    if ($offset < 0) {
        $sign = "-";
        $offset = -$offset;
    }
    my $hoffset = $offset / 60;
    my $moffset = $offset % 60;
    printf(STDERR "%04d-%02d-%02d %02d:%02d:%06.3f %s%02d%02d %s: $format",
           $year+1900, $mon+1, $day, $hour, $min, $time-$itime+$sec,
           $sign, $hoffset, $moffset,
           $role, @_);
}

sub info {
    _info($role, @_);
}

sub peer_info {
    _info($role_peer, @_);
}

sub callers {
    my (@lines, $line);
    # Skip the entry for callers itself, so by default start $i at 1
    my $i = shift;
    push @lines, $line while (undef, undef, $line) = caller(++$i);
    return join(" ", @lines);
}

sub caller_info {
    my $format = shift;
    if (@_) {
        info("$format [%s]", @_, callers());
    } else {
        my $callers = callers();
        $callers =~ s{%}{%%}g;
        info("$format [$callers]");
    }
}

my %display = (
    "\r"	=> '\r',
    "\n"	=> '\n',
    "\t"	=> '\t',
    "\0"	=> '\0',
    "\\"	=> '\\',
    '"'		=> '\"',
    );

sub display {
    my ($data) = @_;

    defined $data || return "undef";
    my $len = length $data;
    my $long = $len > 30;
    $data = substr($data, 0, 37) if $long;
    # $data =~ s{([^\x20-\x7e])}{sprintf('\x%02x', ord $1)}eg;
    my $hex = unpack("H*", $data);
    $data =~ s{([^\x20-\x7e])}{$display{$1} || "."}eg;
    $data = qq{"$data" ($hex)};
    $data .= " ..." if $long;
    $data .= $len == 1 ? " ($len byte)" : " ($len bytes)";
    return $data;
}

sub string_from_value {
    no warnings "once";
    # local $Data::Dumper::Varname  = "VAR";
    local $Data::Dumper::Trailingcomma = 0;
    local $Data::Dumper::Terse = 1;
    local $Data::Dumper::Quotekeys = 0;
    local $Data::Dumper::Sparseseen = 1;
    my $value = Dumper(shift);
    $value =~ s/\s+\z//;
    return $value;
}

# Try an immediate exit. No references should exist in the call chain
sub _cleanup_all {
    $root->delete("Cleanup all") if $root && !$root->{deleted};
    $root &&= 0;
    Signals->_cleanup_all;
    if ($nr_events && defined $root) {
        $root = undef;
        print STDERR "Pid=$$\n" . Events::events();
        die "Assertion: Still have $nr_events events";
    }
}

# Clean up all events and wait until the next loop in mainloop to exit
# (needed to give references in the callchain to get freed)
sub cleanup_all {
    ::caller_info("cleanup_all()") if $verbose > 1;
    $root->immediate(\&_cleanup_all) if $root;
}

sub add_control {
    my ($parent) = @_;

    my $address = Address->parse("127.0.0.1:0", "Control", from => "TCP4", resolve => 1);
    Listener::Control->new($parent, $address);
}

my @ARGV_OLD = @ARGV;

sub rlwrap {
    if (!$ENV{sssssh_rlwrap}) {
        die "Assertion: Already queued events" if $nr_events;
        local $ENV{sssssh_rlwrap} = "1";
        no warnings "exec";
        { exec("rlwrap", "-w", 100, "-S", "$Script>", "$Bin/$Script", @ARGV_OLD) }
        ;
        $! == ENOENT || die "Could not exec 'rlwrap': $^E";
        ::info("Could not exec 'rlwrap': $^E") if $verbose > 1;
    }
}

my %connection_types = (
    tcp_local		=> "L",
    tcp_remote		=> "R",
    udp_local		=> "l",
    udp_remote		=> "r",
    fou_local		=> "F",
    fou_remote		=> "f",
    socks_local		=> "D",
    socks_remote	=> "d",
    control_local	=> "C",
    control_remote	=> "c",
);
my %connections;

GetOptions("server:s"		=> \my $server,
           "client=s"		=> \my $client,
           "N|loops=o"		=> \$loops,
           "T=o"		=> \$global_timeout,
           "n+"			=> \my $no_control,
           "server_lib=s"	=> \my @server_lib,
           "ssh=s"		=> \$ssh,
           "M|master"		=> \my $ssh_master,
           "perl=s"		=> \my $remote_perl,
           "server_verbose+"	=> \my $server_verbose,
           "client_verbose+"	=> \my $client_verbose,
           "v|verbose+"		=> \$verbose,
           "keepalive=f"	=> \$keepalive,
           "timeout=f"		=> \$timeout,
           "connect_timeout=f"	=> \$timeout_connect,
           "stuff!"		=> \my $stuff,
           (map {; "$connection_types{$_}|$_=s" => \@{$connections{$_}}} keys %connection_types),
           "udp_max=o"		=> \$udp_max,
           "ping_max=o"		=> \$ping_max,
           "version!"		=> \my $version,
           "U|unsafe!"		=> \my $unsafe,
           "h|help!"		=> \my $help) ||
    die "Could not parse your command line. Try $Script -h\n";

if ($version) {
    print<<"EOF";
sssssh $VERSION (Net::Sssssh) $VERSION
EOF
    exit 0;
}

if ($help) {
    require Config;
    $ENV{PATH} .= ":" unless $ENV{PATH} eq "";
    $ENV{PATH} = "$ENV{PATH}$Config::Config{'installscript'}";
    exec("perldoc", "-F", $unsafe ? "-U" : (), $0) || exit 1;
    # make parser happy
    %Config::Config = ();
}

die "timeout $timeout must be positive\n" if $timeout <= 0;
$settings_global{TIMEOUT} = $timeout+0;
die "timeout $timeout_connect must be positive\n" if $timeout_connect <= 0;
$settings_global{TIMEOUT_CONNECT} = $timeout_connect+0;
die "keepalive $keepalive must be positive\n" if $keepalive <= 0;
$settings_global{KEEPALIVE} = $keepalive+0;
die "udp_max must be positive" if $udp_max < 1;
$settings_global{UDP_MAX} = int($udp_max);
die "ping_max must be positive" if $ping_max < 1;
$settings_global{PING_MAX} = int($ping_max);
die "global timeout must not be negative" if
    defined $global_timeout && $global_timeout < 0;

$no_control ||= 0;
$verbose ||= 0;
$client_verbose = $verbose if !defined $client_verbose;
$server_verbose = $verbose if !defined $server_verbose;

$role = "server" if defined $server;
$role_peer = $role eq "server" ? "client" : "server";

if ($role eq "server") {
    # From here on we are the server
    $verbose = $server_verbose;

    die "Cannot be both server and client\n" if defined $client;
    die "Cannot have stuff in server mode\n" if $stuff;

    for my $type (sort keys %connections) {
        die "Cannot set forwards (like --$type) in server mode\n" if
            @{$connections{$type}};
    }
    if (defined $server && $server ne "-") {
        # Manual start
        if ($no_control) {
            open(STDIN, "<&", $null) || die "Could not dup to STDIN: $^E";
            $root = Root->new();
        } else {
            rlwrap();
            $root = Root->new();
            Control->new($root);
            $| = 1;
        }
        my $address = Address->parse($server, "Server", from => "TCP4", resolve => 1);

        $loops = -1 if !defined $loops;
        Listener::LineProtocol->new($root, $address, loops => $loops) if $loops;
    } else {
        $root = Root->new();
        # Make sure that if we fork/exec things they won't get access to
        # our communication channel
        open(my $socket_in,  "<&STDIN")  || die "Could not dup STDIN: $^E";
        open(STDIN, "<&", $null) || die "Could not dup to STDIN: $^E";
        open(my $socket_out, ">&STDOUT") || die "Could not dup STDOUT: $^E";
        open(STDIN, ">&", $null) || die "Could not dup to STDOUT: $^E";
        $socket_in->blocking(0);
        $socket_out->blocking(0);
        $root->server($socket_in, $socket_out);
    }
    $root->signal_add0("USR1", \&add_control) if defined $server && $no_control < 2;
} else {
    # From here on we are the client
    $verbose = $client_verbose;

    if ($no_control) {
        open(STDIN, "<&", $null) || die "Could not dup to STDIN: $^E";
        $root = Root->new();
    } else {
        rlwrap();
        $root = Root->new();
        Control->new($root);
        $| = 1;
    }
    $root->signal_add0("USR1", \&add_control) if $no_control < 2;
    if (defined $client) {
        die "Cannot have arguments in client mode" if @ARGV;
        die "Cannot have stuff in client mode" if $stuff;

        my $to = Address->parse_address($client, "Client", to => "tcp4", resolve => 1);
        my $socket = $root->socket_tcp($to);
        $root->client($socket, $socket, \%connections, 1);
    } else {
        @ARGV || die "Missing remote host argument, Try $Script -h\n";
        $stuff = 1 if !defined $stuff;
        if ($stuff) {
            @ARGV == 1 || die "Spurious arguments\n";
        }

        pipe(my $rd0, my $wr0) || die "Could not pipe: $^E";
        pipe(my $rd1, my $wr1) || die "Could not pipe: $^E";
        defined(my $pid = fork()) || die "could not fork: $^E";

        if (!$pid) {
            # Child
            # This side does the ssh connection so that ^C goes to ssh
            eval {
                close $wr0;
                close $rd1;
                open(STDIN,  "<&", $rd0) || die "Could not dup STDIN: $^E";
                close $rd0;
                open(STDOUT, ">&", $wr1) || die "Could not dup STDOUT: $^E";
                close $wr1;

                $SIG{CHLD} = "DEFAULT";
                if ($stuff) {
                    # delete @ENV{qw(LANGUAGE LC_ALL LANG)};
                    my $remote_host = shift;
                    if ($remote_host eq "") {
                        $remote_perl = $^X if !defined $remote_perl;
                        exec($remote_perl) ||
                            die "Could not exec $remote_perl: $^E";
                    } else {
                        $remote_perl = "/usr/bin/perl" if !defined $remote_perl;
                        exec($ssh, $ssh_master ? "-M" : (), "-e", "none", $remote_host, $remote_perl) ||
                            die "Could not exec $ssh: $^E";
                    }
                } else {
                    push @ARGV, "$Bin/$Script" if @ARGV == 1;
                    exec($ssh, $ssh_master ? "-M" : (), "-e", "none", "-T", @ARGV) ||
                        die "Could not exec $ssh: $^E";
                }
            };
            print STDERR $@ || "No error";
            _exit(1);
        }

        # Parent
        close $rd0;
        close $wr1;
        $wr0->autoflush(1);

        if ($stuff) {
            my $self = "$Bin/$Script";
            # Maybe we could get the same info through DATA (if we didn't close)
            open(my $fh, "<", $self) || die "Could not open $self: $^E";
            my $content = qq(#line 1 "$Bin/$Script"\n);
            $content .= do { local $/; <$fh> };
            $content =~ s/\n__END__\n.*/\n/s || die "Could not find __END__";
            # Remove full line comments, but not #line statements.
            # Leave the \n so line numbers in error messages keep working
            $content =~ s/^[^\S\n]*#(?![^\S\n]*line\s).*//mg;
            # Drop leading spaces. Saves about 20%
            # (less of course if ssh does compression, which it does by default)
            $content =~ s/^[^\S\n]+//mg;

            # Change a few variables in the server code
            my %replace =
                (verbose	=> $server_verbose,
                 role		=> "server",
                 # This is needed because $SET sets the remote timeout for $line
                 # but Fou::UDP is not a child of $line and uses the
                 # global settings
                 timeout	=> $timeout,
                 ping_max	=> $ping_max,
                 global_timeout	=> $global_timeout,
             );
            while (my ($name, $value) = each %replace) {
                $value = string_from_value($value);
                # info("Value $name=<$value>") if $verbose;
                $content =~ s{^([^\S\n]*(?:my|our))\s*\$\Q$name\E\s*=[^;\n]*;[^\S\n]*\n}{$1 \$$name=$value;\n}m || die "Could not set $name";
            }

            print($wr0 $PRE_STUFFER) || die "Write error:$^E";
            for my $server_lib (map split(/:/), @server_lib) {
                print($wr0 qq(use lib "$server_lib";\n)) || die "Write error:$^E";
            }
            # print($wr0 qq(\$Script="\$Script"\n)) || die "Write error:$^E";
            print($wr0 $content) || die "Write error:$^E";
            print($wr0 $POST_STUFFER) || die "Write error:$^E";
            my $line = "";
            while (length($line) < length($STUFFED)) {
                alarm(60);
                my $rc = sysread($rd1, $line, length($STUFFED)-length $line, length $line);
                if (!defined $rc) {
                    next if $! == EINTR;
                    die "Read error: $^E";
                }
                die "Unexpected EOF" if $rc == 0;
            }
            alarm(0);
            $line eq $STUFFED || die "Bad server confirm $line";
        }
        $wr0->blocking(0);
        $rd1->blocking(0);
        $root->client($rd1, $wr0, \%connections, 0);
    }
}

$root->timeout($global_timeout) if defined $global_timeout;

eval {
    for my $control (@{$connections{control_local}}) {
        my $address = Address->parse($control, "Control", from => "TCP4", resolve => 1);
        Listener::Control->new_suspended($root, $address);
    }

    Events->mainloop();
};
$@ || eval { _cleanup_all() };
die "\u$role DIED: $@" if $@;
# die "Assertion: \u$role fell off the mainloop";
exit $exit;

__END__
Implementation notes:
