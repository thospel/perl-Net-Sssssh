#!/usr/bin/perl -w
use strict;
use warnings;

my $VERSION = "1.000";

# modprobe fou
# ip link add name tun1 type ipip remote 127.0.0.1 local 10.252.3.1 ttl 225 encap fou encap-sport auto encap-dport 5555
# ip link set tun1 up
# ip addr add 10.253.4.1/24 dev tun1

# ip link del name tun1

use FindBin qw($Script);
our $Bin;

# If the program runs as /foobar/bin/program, find libraries in /foobar/lib
BEGIN {
    # Even on windows FindBin uses / in the reported path
    $Bin = $FindBin::Bin;
    $Bin =~ s{/+\z}{};
    $Bin =~
        ($^O eq "MSWin32" ?
         qr{^((?:[A-Z]:)?(?:/[a-zA-Z0-9_:.~ -]+)*)/[a-zA-Z0-9_.-]+/*\z} :
         qr{^((?:/[a-zA-Z0-9_:.-]+)*)/[a-zA-Z0-9_.-]+/*\z}) ||
         die "Could not parse bin directory '$Bin'";
    # Use untainted version of lib
    require lib;
    # Support a simple --blib option for pre-install testing
    "lib"->import(@ARGV && $ARGV[0] eq "--blib" ? shift && "$1/blib/lib" : "$1/lib");
}

use Getopt::Long 2.24 qw(:config bundling require_order);
use IO::Socket::INET qw();
use IO::Socket qw(MSG_TRUNC MSG_CTRUNC
                  inet_ntoa unpack_sockaddr_in pack_sockaddr_in);
use Socket::MsgHdr;

use Net::Sssssh qw(IPPROTO_IP IP_PKTINFO IP_RECVTTL IP_RECVDSTADDR IP_TTL
                   fou_decode fou_encode string_from_value);

my $port = 5555;
die "Could not parse your command line. Try $0 -h\n" unless
    GetOptions("f|fou!"		=> \my $fou,
               "a|answer!"	=> \my $answer,
               "p|port=o"	=> \$port,
               "v|verbose!"	=> \my $verbose,
               "version!"	=> \my $version,
               "U|unsafe!"	=> \my $unsafe,
               "h|help!"	=> \my $help);

my $s = IO::Socket::INET->new(
    Proto	=> "udp",
    ReUse	=> 1,
    # LocalHost	=> "127.0.0.1",
    LocalPort	=> $port) || die "Could not create socket: $!";
setsockopt($s, IPPROTO_IP, IP_PKTINFO, 1) ||
    die "setsockopt(IPPROTO_IP, IP_PKTINFO): $^E";
setsockopt($s, IPPROTO_IP, IP_RECVTTL, 1) ||
    die "setsockopt(IPPROTO_IP, IP_RECVTTL): $^E";

# my $buffer = "";
my $msghdr = Socket::MsgHdr->new();
print STDERR "=" x 25 . "\n" if $verbose;
while (1) {
    $msghdr->controllen(256);
    $msghdr->namelen(256);
    $msghdr->buflen(2**16);
    $s->recvmsg($msghdr) || die "Could not recvmsg: $!";
    my $buffer = $msghdr->buf;

    # Socket::MsgHdr 0.05 does in fact not set flags after recvmsg
    die "Yikes! Buffer was truncated\n" if
        $msghdr->flags & MSG_TRUNC;
    die "Yikes! Ancillary data was truncated\n" if
        $msghdr->flags & MSG_CTRUNC;

    my ($local, $msg_dst, $ttl);
    my @cmsg = $msghdr->cmsghdr();
    for my $i (0 .. $#cmsg / 3) {
        $i *= 3;
        my ($level, $type, $data) = @cmsg[$i..$i+2];
        $level == IPPROTO_IP || next;
        if (defined IP_RECVDSTADDR && $type == IP_RECVDSTADDR) {
            # FreeBSD
            length $data == 4 || die "Unexpected IP_RECVDSTADDR length";
            $local = inet_ntoa($data);
            $msg_dst = $local;
        } elsif (defined IP_PKTINFO && $type == IP_PKTINFO) {
            # Linux
            length $data == 12 || die "Unexpected IP_PKTINFO length";
            my ($interface, $dst, $to) = unpack("Ia4a4", $data);
            $local = inet_ntoa($to);
            $msg_dst = inet_ntoa($dst);
        } elsif ($type == IP_TTL) {
            length $data == 4 || die "Unexpected IP_TTL length";
            $ttl = unpack("I", $data);
            $cmsg[$i+2] = pack("I", $ttl-1);
        }
    }
    $local // die "Assertion: No local addr";
    $ttl   // die "Assertion: No TTL";

    my $sender = $msghdr->name;
    my ($peer_port, $peer) = unpack_sockaddr_in($sender);
    $peer = inet_ntoa($peer);

    my $props;
    if ($fou) {
        $props = fou_decode($buffer, $verbose && \*STDERR, 1);
        $buffer = $props->{data} // next;
    }
    print STDERR "Sender $peer:$peer_port, Receiver $local [$msg_dst]\n" if $verbose;
    print STDERR "Received: ", length($buffer), " bytes (TTL $ttl) ", string_from_value($buffer), "'\n" if $verbose;

    if ($answer) {
        if ($ttl > 1) {
            $msghdr->cmsghdr(@cmsg);
            $buffer = time() . ": " . $buffer if $buffer !~ s/^(\d+)/$1+1/ea;
            if ($fou) {
                if ($props->{ttl} <= 1) {
                    print STDERR "Sent nothing (received TTL=$props->{ttl})\n" if $verbose;
                    print STDERR "=" x 25 . "\n" if $verbose;
                    exit;
                }
                $buffer = fou_encode(
                    pack_sockaddr_in($props->{dprt}, $props->{dst}),
                    pack_sockaddr_in($props->{sprt}, $props->{src}),
                    $buffer,
                    $verbose && \*STDERR, $props->{ttl}-1);
                # fou_decode($buffer, \*STDERR) if $verbose;
            }
            $msghdr->buf($buffer);
            $s->sendmsg($msghdr) || die "Could not send: $!";
            printf(STDERR "Sent: %d bytes (TTL %d) %s\n",
                   length($buffer), $ttl-1, string_from_value($buffer)) if $verbose;
        } else {
            print STDERR "Sent nothing (received TTL=$ttl)\n" if $verbose;
        }
    }
    print STDERR "=" x 25 . "\n" if $verbose;
}
