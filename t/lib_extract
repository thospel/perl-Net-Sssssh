#!/usr/bin/perl -w
use strict;
use warnings;

our $VERSION = "1.000";

use FindBin qw($Script);
our $Bin;

# If the program runs as /foobar/bin/program, find libraries in /foobar/lib
BEGIN {
    # Even on windows FindBin uses / in the reported path
    $Bin = $FindBin::Bin;
    $Bin =~ s{/+\z}{};
    $Bin =~
        ($^O eq "MSWin32" ?
         qr{^((?:[A-Z]:)?(?:/[a-zA-Z0-9_:.~ -]+)*)/[a-zA-Z0-9_.-]+/*\z} :
         qr{^((?:/[a-zA-Z0-9_:.-]+)*)/[a-zA-Z0-9_.-]+/*\z}) or
             die "Could not parse bin directory '$Bin'";
    # Use untainted version of lib
    require lib;
    # Support a simple --blib option for pre-install testing
    "lib"->import(@ARGV && $ARGV[0] eq "--blib" ? shift && "$1/blib/lib" : "$1/lib");
}

my ($pre, $lib);

sub uncomment {
    my ($str) = @_;
    $str =~ s{^ ([^\S\n]*) \# [^\S\n]* }{$1}mxg;
    return $str;
}

sub get_body {
    my ($file) = @_;

    open(my $fh, "<", $file) || die "Could not open '$file': $^E";
    my $body = do { local $/; <$fh> };
    $body =~
        m{
             ^ \{ \s*
             ^ [^\S\n]*
             package \s+ \Q$lib\E; [^\S\n]*\n
             (.*?)
             \s*
             ^\}
         |
             ^ package \s+ \Q$lib\E; [^\S\n]*\n
             (.*?)
             \s*
             (?:
                 ^
             |
                 ^ \{ \s*
                 ^ [^\S\n]*
             )
             package \s

     }msx or die "Could not find package $lib in '$file'\n";
    my $code = $+;
    my @exports;
    $code =~
        s{
             ^ [^\S\n]* \# [^\S\n]* Exportable [^\S\n]* \n
             (
                 (?:
                     ^ [^\S\n]* \# .* \n
                 )*
                 ^ [^\S\n]* sub [^\S\n]* (\w+)
             )
     }{push @exports, $2; $1}gemix;

    $code =~
        s{
             ^ [^\S\n]* \# [^\S\n]* for [^\S\n]* lib_extract [^\S\n]* \n
             (
                 (?:
                     ^ [^\S\n]* \# .* (?:\n|\z)
                 )*
             )
     }{uncomment($1)}gemix;
    return $code, \@exports;
}

my @modules = qw(Events Timer Address Object Root);
if (!@ARGV) {
    print "@modules\n";
    exit;
}
@ARGV == 2 || die "Invalid number of arguments";
my ($target, $from) = @ARGV;
($pre, $lib) = $target =~ m{^lib/((?:[^/]+/)*)(.*)\.pm\z} or
    die "Could not parse target '$target'";

$pre =~ s{/}{::}g;

my ($code_old, $exports) = get_body($from);
my $code_verbose = $code_old =~ /\$verbose\b/ ? <<'EOF' : ""
my $verbose = 0;
sub verbose {
    # Should really be an isa test
    shift if @_ && $_[0] eq __PACKAGE__;
    return $verbose unless @_;
    my $old = $verbose;
    $verbose = shift;
    return $old;
}
EOF
;

my $code_exports = @$exports ? <<"EOF" : ""
use Exporter::Tidy
    other => [qw(@$exports)];

EOF
    ;

my $code_new = <<"EOF"
# Modifications of this file will be lost.
# It is autogenerated from $from.
package $lib;
use strict;
use warnings;

$code_exports$code_verbose\{
$code_old
}

1;
EOF
    ;
my $match_modules = join("|", map quotemeta, @modules);
$code_new =~ s/\b($match_modules)\b/$pre$1/g;
open(my $fh, ">", $target) || die "Could not create '$target': $^E";
print $fh $code_new;
print "Created $target\n";
